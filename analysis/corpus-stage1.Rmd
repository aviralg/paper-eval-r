---
title: "Corpus Stage 1"
output: html_document
params:
  base_dir: /var/lib/R/project-evalR
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
local(for (x in c(
  "dplyr", 
  "DT", 
  "fs", 
  "fst",
  "readr",
  "purrr"
  )) {
  suppressPackageStartupMessages(library(x, character.only=TRUE))
})

knitr::opts_chunk$set(echo = TRUE)

source("inc/paths.R")
source("inc/setup.R")
source("inc/latextags.R")
```

## Description

This notebook selects TOP `r fmt(CORPUS_S1_NUM_PKGS)` packages into `r CORPUS_S1_FILE` based on the number of reverse dependencies.
We then run all the tasks on this set.
Finally, we select TOP `r fmt(CORPUS_NUM_PKGS)` packages for the paper for the packages that ran successfully.
The reason is that not all the code in packages is runnable in all environments.
Especially, the way `covr` runs to get code coverage does not work on all.

### Output

- ``r CORPUS_S1_FILE`` - selected packages based on 

## Prepare the corpus

```{r set local mirror}
options(repos=CRAN_MIRROR_LOCAL_URL)
```

```{r get all available packages}
cran_packages_raw <- available.packages()
cran_packages <- as_tibble(cran_packages_raw) %>%
  select(package=Package, version=Version)
```

### Package reverse dependencies

There are two functions `package_dependencies` and `dependsOnPkgs`.
Not sure what is the difference, but the `dependsOnPkgs` is very slow.

```{r compute reverse dependencies}
pkgs_revdeps_raw <- 
  tools::package_dependencies(
    cran_packages$package,
    db=cran_packages_raw,
    which=WHICH_DEPENDENCIES,
    reverse=TRUE,
    recursive=FALSE
  ) %>% 
  imap_dfr(~tibble(package=.y, revdep=.x))

pkgs_revdeps <- 
  pkgs_revdeps_raw %>%
  count(package) %>%
  rename(revdeps=n)
```

### TOP packages based on number of reverse dependencies

```{r compute TOP n packages}
pkgs_top_revdeps <-
  pkgs_revdeps %>%
  top_n(n = CORPUS_S1_NUM_PKGS, wt=revdeps) %>%
  arrange(desc(revdeps))

# cup the number of reverse dependencies to the required number
pkgs_top_revdeps <- head(pkgs_top_revdeps, min(nrow(pkgs_top_revdeps), CORPUS_S1_NUM_PKGS))
```

### Missing packages from TOP 100 downloads

```{r get last month most downloaded packages}
pkgs_top_downloaded <-
  cranlogs::cran_top_downloads("last-month", 100)
```

```{r compute missing packages from the most downloaded ones}
missing <- setdiff(pkgs_top_downloaded$package, pkgs_top_revdeps$package)
missing_revdeps <- filter(pkgs_revdeps, package %in% missing)
missing_revdeps %>%
  left_join(pkgs_top_downloaded, by="package") %>%
  datatable()
```

### Corpus

Putting it all together and outputting the results.

```{r corpus s1}
corpus_s1 <- 
  pkgs_top_revdeps %>%
  left_join(pkgs_top_downloaded, by="package") %>%
  arrange(desc(revdeps))
```


```{r render selected packages}
corpus_s1 %>%
  datatable()
```

```{r write down corpus}
write_lines(corpus_s1$package, CORPUS_S1_FILE)
write_fst(select(corpus_s1, package, revdeps, rank), CORPUS_S1_DETAILS_FILE)
```
