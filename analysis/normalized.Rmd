---
title: "Normalized expressions"
output:
    html_document:
        gallery: false
        toc: true
        toc_depth: 3
        toc_float: true
        df_print: paged
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
params:
  base_dir: Data/package/
  calls_path: summarized.fst
  normalized_path: normalized-expressions.csv
  corpus_path: corpus.txt
  static_path: evals-static.csv
  force_rebuild: FALSE
---

```{r setup, include=FALSE}
library(tidyverse)
library(fst)
library(fs)
library(DT)
library(scales)

knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) { # record the current time before each chunk
      now <<- Sys.time()
    } else { # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now)
      # return a character string to show the time
      paste("Time for this code chunk to run:", round(res, 2), units(res))
    }
  }
}))
now <- Sys.time()
knitr::opts_chunk$set(
  echo = TRUE,
  fig.retina = 2,
  fig.width = 10,
  cache.lazy = FALSE,
  time_it = TRUE
)

source("inc/paths.R")
source("inc/latextags.R")
source("inc/functions.R")
theme_set(theme_minimal())

dataset_name <- basename(params$base_dir)

# Tags will be prefixed by the dataset name
create_tags(path(TAGS_DIR, paste0(dataset_name, "_normalized_expr.tex")), prefix = dataset_name, default = TRUE)
# Also use ggsave_prefix instead of ggsave if you need to save a graph

calls_path <- paste0(params$base_dir, params$calls_path)
corpus_path <- paste0(params$base_dir, params$corpus_path)
static_path <- paste0(params$base_dir, params$static_path)
normalized_path <- paste0(params$base_dir, params$normalized_path)

lock_path <- paste0(params$base_dir, ".normalized-lock.fst")
min_path <- paste0(params$base_dir, "Ecano.fst")
```

# Read

Read in the summarized calls data (`E_raw`) and the file that describes
which package belong to our corpus (`C_raw`). For conciseness, `E` is
the input data set with only the columns that we use. We also read the file with normalized expressions, `N`.

```{r read, message=TRUE, include=F}
tibble(package = read_lines(corpus_path)) -> C_raw
read_csv(static_path) %>% semi_join(C_raw, by = "package") -> P

rebuild <- TRUE

E_cano <- NULL

if (file.exists(lock_path)) {
  saved <- read.fst(lock_path)[[1,1]]
  if (saved == file.size(calls_path)) {
    read_fst(min_path) %>% as_tibble() -> E_cano
    rebuild <- FALSE
  }
}

if(params$force_rebuild || rebuild) {
  read_fst(calls_path) %>% as_tibble() -> E_raw
  
  read_csv(normalized_path, col_types = cols(
    minimized = col_character(),
    topcall = col_character(),
    is_model = col_logical(),
    has_fundef = col_logical(),
    has_calls = col_integer(),
    has_assigns = col_integer(),
    has_var = col_logical(),
    has_bracket = col_logical(),
    is_assign = col_logical(),
    is_value = col_logical(),
    is_ignore = col_logical(),
    has_dollar = col_logical(),
    has_user_call = col_logical(),
    has_block = col_logical(),
    has_meta_op = col_logical(),
    normalized = col_character(),
    trimmed = col_character(),
    hash = col_character()
  )) -> N
  
  E_raw %>% select(
    run_package = package, #      The package which was run to trigger the eval
    ev_variant = eval_function, # Which eval variant was called
    duplicates = nb_ev_calls, #   Number of identical eval calls (weight)
    src_ref = eval_call_srcref, # Source ref for the eval call site
    file, #                       Script file name (name of this run)
    ev_package = eval_source, #   Package of the call site
    type = expr_resolved_type_tag, #   Argument type
    ev_expr = expr_expression,
    expr_resolved,
    func = expr_resolved_function, # the function (if any) at the root of the AST of expr_resolved
    parsed = expr_parsed_expression,
    hash = expr_resolved_hash,
    match.call = expr_match_call,
    n_op = interp_eval,
    envir = envir_expression
  ) -> E
  
  E_cano <- E %>% left_join(N, by = "hash") # Common column is the hash of the full resolved expression
  
  E_cano %>% write_fst(min_path)
  sz <- file.size(calls_path) %>% as_tibble()
  write.fst(sz, lock_path)
}

C_raw -> C
corpus_size <- nrow(C)
```


Some useful numbers:
```{r}
nb_call_sites <- E_cano %>%
  pull(src_ref) %>%
  n_distinct()

r("Nb call sites", nb_call_sites)
```


There are `r nb_call_sites` call sites in the dataset.



# Ranking of normalized and minimized expressions


Normalized: 
```{r}
widespread_canonic <- E_cano %>%
  group_by(normalized) %>%
  summarize(n_call_sites = n_distinct(src_ref), n_packages = n_distinct(ev_package))

widespread_canonic %>%
  arrange(desc(n_call_sites)) %>%
  datatable()
```


Minimized:
```{r}
widespread_minimized <- E_cano %>%
  group_by(minimized) %>%
  summarize(n_call_sites = n_distinct(src_ref), proportion = ratio(n_call_sites, nb_call_sites), n_packages = n_distinct(ev_package), n_operations = round(mean(n_op, na.rm=TRUE), 2), percent_envir = ratio(sum(!is.na(envir)), n())) %>% 
  arrange(desc(n_call_sites))

widespread_minimized %>%
  datatable()
```

```{r}
nrows <- 12
r_vec("MinimizedCallSites", nrows, pull(widespread_minimized, n_call_sites))
r_vec("MinimizedPropSites", nrows, pull(widespread_minimized, proportion))
r_vec("MinimizedPackage", nrows, pull(widespread_minimized, n_packages))
r_vec("MinimizedOperations", nrows, pull(widespread_minimized, n_operations))
r_vec("MinimizedPercentEnvir", nrows, pull(widespread_minimized, percent_envir))
```

`n_operations` is the average of R interpreter eval loop per minimized expression. `prop_envir` shows how much often an *explicit* environment is passed to `eval`. Looking up to a variable and applying a function to a variable, are the two non-trivial categories that most of the time explicitly use the `envir` argument of `eval`.

# How does it evolve per call site

To check whether the normalization makes sense, we have a look at how many normalized expressions we have per call sites.

```{r}
# count hash because resolved expressions are trimmed but hash are on the full expression
by_src_ref <- E_cano %>% group_by(src_ref) %>%
  summarise(n_resolved = n_distinct(hash), n_normalized = n_distinct(normalized), n_minimized = n_distinct(minimized))
```

```{r}
by_src_ref %>% arrange(desc(n_resolved)) %>% datatable()
```

There should always be less normalized expressions than resolved ones. 
We can see for how many there are strictly less (or one when it was already one).


```{r}
decrease_exprs <- by_src_ref %>% filter(n_resolved == 1 | n_resolved > n_minimized)  %>% arrange(desc(n_minimized))
```

It corresponds to `r nrow(decrease_exprs)` call sites so only `r nb_call_sites - nrow(decrease_exprs)` have non-trivially not decreased the number of call sites.

# Top calls

For the functions at the root of the AST, per call site:

```{r}
widespread_topcall <- E_cano %>%
  group_by(topcall) %>%
  summarize(n_call_sites = n_distinct(src_ref), percent = round(ratio(n_call_sites, nb_call_sites), 2)) %>% 
  arrange(desc(n_call_sites))
```

```{r}
widespread_topcall %>% datatable()
```


```{r}
big_topcall <- widespread_topcall %>% filter(n_call_sites > 3) 
```


There are `r nrow(big_topcall)` top calls out of `r nrow(widespread_topcall)` that are present in strictly more than 3 call sites.



# Function definitions

```{r}
fundefs <- E_cano %>% filter(has_fundef)

nb_fundef_callsites <- fundefs %>% pull(src_ref) %>% n_distinct()
```

There are `r nb_fundef_callsites` call sites with function definitions, i.e. `r ratio(nb_fundef_callsites, nb_call_sites)` %.

# Model.frame

```{r}
modelframes <- E_cano %>% filter(is_model)

nb_modelf_call_sites <- modelframes %>% pull(src_ref) %>% n_distinct()
```


There are `r nb_modelf_call_sites` call sites with `mode.frame`, i.e. `r ratio(nb_modelf_call_sites, nb_call_sites)`%.

Is it usually in top call position?

```{r}
modelframes %>% filter(topcall != "model.frame")
```

Yes, always!

Is it correlated with `match.call`?

```{r}
nb_mf_match.call <- modelframes %>% filter(!is.na(match.call)) %>% pull(src_ref) %>% n_distinct()
```

`r nb_mf_match.call` call sites out of `model.frame` `r nb_modelf_call_sites` call sites use the `match.call` pattern, i.e. `r ratio(nb_mf_match.call, nb_modelf_call_sites)`%.

We can also reciprocally look at how many call sites with `match.call` have `model.frame`:

```{r}
match.call_df <- E_cano %>% filter(!is.na(match.call))

nb_m.c_call_sites <- match.call_df %>% pull(src_ref) %>% n_distinct()

nb_m.c_mf_call_sites <- match.call_df %>% filter(is_model) %>% pull(src_ref) %>% n_distinct()
```

So `r ratio(nb_m.c_mf_call_sites, nb_m.c_call_sites)`% of the call sites with the `match.call` pattern use `model.frame`.

# Assignments

When do we perform assignments (causing potentially side effects)?

```{r}
assigns <- E_cano %>% filter(has_assigns > 0)

nb_assigns_call_sites <- assigns %>% pull(src_ref) %>% n_distinct()
```

There are `r nb_assigns_call_sites` call sites with assignments, i.e. `r ratio(nb_assigns_call_sites, nb_call_sites)`%.


Is the `envir` argument non trivial?

```{r}
assign_env <- assigns %>% filter(!is.na(envir))

nb_a_env_call_sites <- assign_env %>% pull(src_ref) %>% n_distinct()
```


There are `r nb_a_env_call_sites` call sites where `envir` is non-trivial, with an assignment, i.e. `r ratio(nb_a_env_call_sites, nb_assigns_call_sites)`% of the call sites with assignments.


# `match.call` pattern

There are `r nb_m.c_call_sites` call sites using the `match.call`pattern, i.e. `r ratio(nb_m.c_call_sites, nb_call_sites)`%.

The top calls for this pattern are:

```{r}
match.call_df %>% 
  group_by(topcall) %>%
  summarize(n_call_sites = n_distinct(src_ref)) %>% 
  arrange(desc(n_call_sites))
```

Most are `model.frame`. If we add other model functions, such as `glm` and `plm`: 

```{r}
stat_functions <- c("model.frame", "glm", "lm", "plm", "elo.model.frame", "lmer", "randomForest", "betareg", "nlreg", "model.frame.default", "model.matrix", "arima", "glm.nb", "glmer") # There are many more

nb_stat_call_sites <- match.call_df %>% 
  filter(topcall %in% stat_functions) %>% 
  pull(src_ref) %>% 
  n_distinct()
  
```

it amounts for `r nb_stat_call_sites` call sites, i.e `r ratio(nb_stat_call_sites, nb_call_sites)`%.

# Substitute&co

`substitute`, `quote` and so on are used to do meta-programming.

```{r}
meta_df <- E_cano %>% filter(has_meta_op)

nb_meta_call_sites <- meta_df %>% pull(src_ref) %>% n_distinct()
```

There are `r nb_meta_call_sites` call sites with `substitute` and `substitute`-like operators.

Are the `substitute` sometimes not placed as a top call?

```{r}
meta_not_top <- meta_df %>% filter(!topcall %in% c("substitute", "quote", "enquote", "bquote"))

nb_m_n_top_call_sites <- meta_not_top %>% pull(src_ref) %>% n_distinct()
```

It happens for `r nb_m_n_top_call_sites` call sites, i.e. `r ratio(nb_m_n_top_call_sites, nb_call_sites)`%.

# Complex blocks

`eval` can evaluate sometimes complex blocks.

```{r}
blocks <- E_cano %>% filter(has_block)

nb_blocks_call_sites <- blocks %>% pull(src_ref) %>% n_distinct()
```


There are `r nb_blocks_call_sites` such call sites, i.e. `r ratio(nb_blocks_call_sites, nb_call_sites)`%.

`eval` is used to insert blocks of code inside the function, for instance as a preprocessing and postprocessing step. There are some examples in the VGAM package. In that case, `{` will be at the root of the AST.

```{r}
pre_post <- blocks %>% filter(topcall == "{")

nb_pre_post_call_sites <- pre_post %>% pull(src_ref) %>% n_distinct()
```

It happens in `r nb_pre_post_call_sites` call sites so most of the call sites with blocks (`r ratio(nb_pre_post_call_sites, nb_blocks_call_sites)`%).

# `Parse` and plotting functions

We approximate the plotting function by just looking for `plot` in their name:

```{r}
plotting <- E_cano %>% filter(str_detect(normalized, fixed("plot"))) # not in topcall because f it results from parse...

nb_plotting_call_sites <- plotting %>% pull(src_ref) %>% n_distinct()
```

There are `r nb_plotting_call_sites` plotting call sites, i.e. `r ratio(nb_plotting_call_sites, nb_call_sites)`%.

Are they built using parse? For that, we look at the non-resolved expression (`parse` will disappear after).

Currently, we use a regex. When `parsed` column is fixed, we will get more accurate results.

```{r}
parse_plot <- plotting %>% filter(str_detect(ev_expr, fixed("parse")))

nb_parse_plot_call_sites <- parse_plot %>% pull(src_ref) %>% n_distinct()
```

This already amounts to `r nb_parse_plot_call_sites` call sites, i.e. `r ratio(nb_parse_plot_call_sites, nb_plotting_call_sites)`% of the plotting call sites.

### Infix operators

```{r}
infix <- E_cano %>% filter(str_detect(topcall, "%[^%]*%"))

nb_infix_call_sites <- infix %>% pull(src_ref) %>% n_distinct()
```

It happens in `r nb_infix_call_sites` call sites, i.e. `r ratio(nb_infix_call_sites, nb_call_sites)`%.

The packages that use or define those infix operators:

```{r}
infix %>% group_by(ev_package) %>% summarize(n_call_sites = n_distinct(src_ref)) %>% arrange(desc(n_call_sites)) %>% datatable()
```


# Polymorphism in more details

We have only 15 different kind of minimized expression. Do some minimized expressions often go together?

```{r}
minimized_exprs <- E_cano %>% pull(minimized) %>% unique()

create_set <- function(l) {
  s <- rep.int("F", length(minimized_exprs))
  names(s) <- minimized_exprs
  
  for(exp in l) {
    s[[exp]] = "T"
  }
  
  return(paste0(s, collapse = ""))
}

show_set <- function(s) {
  l <- strsplit(s, split="")[[1]]
  names(l) <- minimized_exprs
  
  l <- l[which(l == "T")]
  return(paste0(names(l), collapse = "; "))
}

poly <- E_cano %>% group_by(src_ref) %>%
    summarize(common_minimized = create_set(minimized), n_exprs = n_distinct(minimized)) 
```

Now, we can show the mot common minimized expressions when there are more than 2 for one call site:

```{r}
poly %>%
  count(common_minimized,  sort = TRUE) %>%
  mutate(common_minimized = map_chr(common_minimized, show_set)) %>% 
  mutate(percent = round(100 * n / nb_call_sites, 2)) %>% 
  datatable()
```


How many sites have only one minimized expression?

```{r}
n_one_mini <- poly %>% filter(n_expers == 1) %>% nrow()


r("Nb One Minimized", n_one_mini)
r("Nb One Minimized Percent", ratio(n_one_mini, nb_call_sites))
```


