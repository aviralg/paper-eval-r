---
title: "Empirical Evaluation of eval in R"
output:
  rmdformats::readthedown:
        code_folding: hide
        lightbox: true
        gallery: false
        df_print: paged
        toc_depth: 3
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
params:
    data_filepath: "/var/lib/R/project-evalR/run/package-evals-traced-all.1/calls.fst"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center",
                      fig.retina = 2,
                      fig.width = 10,
                      cache.lazy = FALSE)

library(tidyverse)
library(stringr)
library(viridis)
library(vctrs)
library(DT)
library(fst)
library(fs)

source("insights.R", local = knitr::knit_global())
```

# Data

The analysis is being performed on dataset read from file `r params$data_filepath`.

```{r file-info, echo=FALSE}
file_info(params$data_filepath)
```

```{r load-data, echo=FALSE}
eval_calls <-
    read_fst(params$data_filepath) %>%
    as_tibble() %>%
    resolve_sexp_name(expr_expression_type) %>%
    resolve_sexp_name(expr_resolved_type) %>%
    resolve_sexp_name(enclos_type) %>%
    resolve_sexp_name(envir_type)


# A flexible way to document the dataset: it is quick and easy to document a new column
c_names <- names(eval_calls)
column_names <- setNames(data.frame(matrix(ncol = length(c_names), nrow = 0)), c_names)

column_names <- column_names %>% add_row()

column_names["file"] <- "File where the `eval` is executed"
column_names["eval_call_id"] <- "Unique id of a call" 
column_names["expr_parsed_expression"] <- "Contains the expression with a call to `parse` if there is one in the `expr` argument somewhere in the call stack."
column_names["caller_function"] <- "Function in which the `eval` is called."
column_names["caller_package"] <- "Package in which the `eval` is called."
column_names["eval_function"] <- "One of `eval`, `evalq`, `eval.parent`, and `local`."
column_names["eval_call_expression"] <- "The full expression with `eval` that has been traced."
column_names["eval_call_srcref"] <- "File name and line where the `eval` call is. Might ne NA, especially for calls originating from package base."
column_names["caller_expression"] <- "Expression in which the `eval` is called."
column_names["caller_srcref"] <- "File name and line where the caller of the `eval` is located. Might be NA (especially for callers in base)."
column_names["caller_srcref2"] <- "File name and line for some calls for which the caller seemed to be itself (mainly Rcpp and C calls)."

# Pivoting

column_names <- column_names %>% rownames_to_column() %>% 
  pivot_longer(-rowname) %>%
  pivot_wider(names_from=rowname, values_from=value)

column_names <- column_names %>%  rename("Description" = `1`) %>% filter(!is.na(Description))

column_names %>% knitr::kable()
```

# Corpus

TODO

# Research Questions

## RQ1: How many evals are there?

There are four kinds of `eval` in the `base` package. Their definitions are shown below.

```{r, eval-definition, eval=FALSE}
base::eval <-
    function(expr, 
             envir = parent.frame(), 
             enclos = if (is.list(envir)||is.pairlist(envir)) parent.frame() else baseenv())
        .Internal(eval(expr, envir, enclos))

base::evalq <-
    function (expr, 
              envir = parent.frame(), 
              enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv())
        .Internal(eval(substitute(expr), envir, enclos))

base::eval.parent <-
    function (expr, n = 1) {
        p <- parent.frame(n + 1)
        eval(expr, p)
    }

base::local <-
    function (expr, envir = new.env())
        eval.parent(substitute(eval(quote(expr), envir)))
```

```{r eval-count-table}
callsites_with_srcref <-
    eval_calls %>% 
    select(eval_call_srcref) %>% 
    n_distinct(na.rm = TRUE)

callsites_without_srcref <-
    eval_calls %>% 
    filter(is.na(eval_call_srcref)) %>% 
    select(caller_package, caller_function) %>% 
    n_distinct()

eval_calls <-
    eval_calls %>%
    mutate(eval_call_srcref = coalesce(eval_call_srcref, 
                                       str_c("missing", "::", caller_package, "::", caller_function)))
eval_count_table <-
    eval_calls %>%
    group_by(eval_function, eval_call_srcref) %>%
    summarize(count = n()) %>%
    summarize(call_count = sum(count), callsite_count = n())
    
nb_eval_calls <- total_call_count <- sum(eval_count_table$call_count)

nb_call_sites <- total_callsite_count <- sum(eval_count_table$callsite_count)
    
eval_count_table <-
    eval_count_table %>%
    mutate(call_proportion = 100 * call_count / total_call_count,
           callsite_proportion = 100 * callsite_count / total_callsite_count) %>%
    arrange(desc(call_count))

eval_call_proportion <- 
    eval_count_table %>%
    filter(eval_function == "eval") %>%
    pull(call_proportion)
```

There are `r NA` R function calls with `r total_call_count` calls to the four kinds of eval which accounts for `r NA`% of all R function calls.
The table below summarizes the proportion of calls to the different kinds of evals.

<<<<<<< HEAD
```{r }
=======
```{r eval-count-table}
>>>>>>> 9fd53df4085d4210d8ea0ddc95510faef99cd719
eval_count_table %>%
select(eval_function, call_count, call_proportion) %>% 
datatable()
```

We observe that `r eval_call_proportion`% of the calls are made to the `eval` function.

These `eval` calls originate from `r total_callsite_count` call sites. For the number of call sites, we use line number information attached to the AST by the parser. When it is not available (such as in *base*), we use a combination of `caller_package` and `caller_function`. We assume that:

  - the combination `caller_package` and `caller_function` is unique
  - there is only one call site per such `caller_function`
This assumption results in a lower bound for the number of unique callsites for eval.


```{r call-site-table}
eval_callsite_table <-
    eval_calls %>%
    count(eval_function, caller_package, eval_call_srcref, name = "call_count") %>%
    group_by(eval_function, caller_package) %>%
    summarize(call_count = sum(call_count), callsite_count = n()) %>%
    ungroup()

eval_callsite_table %>%
datatable()
```

```{r call-site-distribution}
package_callsite_distribution <-
    eval_callsite_table %>%
    mutate(callsite_count = if_else(callsite_count <= 5, as.character(callsite_count), "> 5")) %>%
    group_by(eval_function, callsite_count) %>%
    summarize(package_count = n())
    
package_callsite_distribution %>%
datatable()

p <-
    package_callsite_distribution %>%
    ggplot(aes(callsite_count, package_count)) +
    geom_col() +
    facet_wrap(vars(eval_function))
p
```

```{r eval_call_sites_base}
eval_calls %>% filter(caller_package == "base") %>% select(caller_function) %>% n_distinct(na.rm = TRUE)
```

<details>
  <summary> Comparing with <code>grep</code></summary>
  Grepping *base* to find eval call sites yields 40 `eval` call sites.
</details>

```{r eval_call_sites_per_package}
eval_calls %>% filter(caller_package != "base") %>% group_by(caller_package) %>% summarize(nb_call_sites =  n_distinct(eval_call_srcref, na.rm = TRUE)) %>% arrange(desc(nb_call_sites))
```

We probably forget the generated ones here, but should we count them in the _call sites_?

```{r nb_eval_calls_per_package}
nb_eval_calls_per_package <- eval_calls %>% group_by(caller_package) %>% summarise(nb_eval_calls_package = n(), per_cent = nb_eval_calls_package / nb_eval_calls * 100) %>% arrange(desc(nb_eval_calls_package))
```

*base* has the highest number of eval calls, i.e. `r nb_eval_calls_per_package["per_cent", 1]`% of them.

  
```{r}
nb_eval_calls_per_package  %>% datatable()
```


## Size of expressions as arguments to `eval`


```{r}
eval_calls %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=1) +
  scale_x_log10() +  scale_y_sqrt()
```

If we remove the outliers:
```{r}
eval_calls %>% filter(expr_expression_length < 25000) %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=2)  + scale_x_sqrt() +  scale_y_sqrt() 
```


<details>
  <summary>More details</summary>
  
  
What about the code size of expressions that seem to be generated?
An approximation of *generated* will be no `srcref` and not in `base`.


```{r code_size_srcref}
eval_calls %>% filter(is.na(eval_call_srcref), caller_package != "base") %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=1) + scale_x_sqrt() + scale_y_sqrt()
```

And the average size per package:
```{r average_size_package}
eval_calls %>% group_by(caller_package) %>% summarize(average_expr_size = mean(expr_expression_length, na.rm = TRUE)) %>% arrange(desc(average_expr_size))
```

If we look at the maxima, the largest ones are in *base*:
```{r max_size_package}
eval_calls %>% group_by(caller_package) %>% summarize(max_expr_size = max(expr_expression_length, na.rm = TRUE)) %>% arrange(desc(max_expr_size))
```

</details>



## Amount of computations performed in `eval`

## Aliases of `eval`


# A taxonomy of `eval`

## The operation mix

## Scope (environments)


## Patterns

### Classifying according to the type of the `expr` argument


```{r types}
per_expr_type <- eval_calls %>% count(expr_expression_type)
```



```{r}
 per_expr_type %>% mutate(per_cent = n / nb_eval_calls * 100 ) %>% arrange(desc(n)) %>% knitr::kable()
```


```{r}
per_expr_type %>% ggplot() +
  geom_col(aes(x = fct_reorder(expr_expression_type, n), y = n)) +
  scale_y_sqrt() + 
  coord_flip() +
  labs(title = "Calls per type", y = "n", x = "type" ) 
```




<details> 
  <summary>Expressions left unchanged by <code>eval</code></summary>
  
  
Expressions of types other than `call`,  `expression`, `name`, `bytecode` and `promise` are just returned unchanged. Here `language` refers to `call` , `name`to `symbol`. `bytecode` refers to bytecode objects, that are generated by the `compile`function:

```{r}
typeof(compiler::compile(1+1))
```


```{r not_unchanged_eval}
changed_evals <- eval_calls %>% mutate(changed =  fct_collapse(expr_expression_type, base_types = c("LANGSXP", "EXPRSXP", "SYMSXP", "PROMSXP", "BCODESXP"))) %>% count(changed) %>% mutate(per_cent = n / nb_eval_calls * 100 ) 
```


We can remove `eval` and leave there the expression in `r changed_evals[2, "per_cent"][[1]]`% of the eval calls (i.e. `r changed_evals[2, "n"][[1]]`).

</details>

## Provenance

Some `eval` result from parsing text (directly or through a file) with `parse`.

```{r eval_from_parse}
parsed_evals <- eval_calls %>% filter(!is.na(expr_parsed_expression))
nb_parsed_evals <- parsed_evals %>% nrow()
```

There are `r nb_parsed_evals` such calls, `r nb_parsed_evals / nb_eval_calls * 100`%.

```{r, hide = TRUE}
nb_parsed_call_sites <- nb_eval_call_sites(parsed_evals)
```

In terms of call sites, there are `r nb_parsed_call_sites` i.e. `r nb_parsed_call_sites / nb_call_sites * 100`%.

<details>
  <summary>More about <code>parse</code> </summary>
  
  We can differentiate further the provenance, i.e. whether the evaluated string comes from `file` or from `text`. However, we can only do it for `parse`, `str2lang` and `str2expression` at the top level of `expr_expression`, not buried in a function call.
  
```{r parsed_evals_source}
parsed_evals_args <- parsed_evals %>% filter(str_detect(expr_parsed_expression, "(parse|str2lang|str2expression)\\(")) %>% mutate(parse_args = map(expr_parsed_expression, extract_args_parse)) %>% unnest_wider(parse_args,  names_sep = "_")
```

```{r}
parsed_files <- parsed_evals_args %>% filter(!is.na(parse_args_file))
nb_file <- parsed_files %>% nrow()
nb_file_call_sites <- nb_eval_call_sites(parsed_files)
```

```{r}
parsed_texts <- parsed_evals_args %>% filter(!is.na(parse_args_text) | !is.na(parse_args_s))
nb_text <-  parsed_texts %>% nrow()
nb_text_call_sites <- nb_eval_call_sites(parsed_texts)
```

There are `r nb_file` calls with the `file` argument, and `r nb_text` with the `text` argument, i.e. `r  nb_file / nb_parsed_evals * 100`%, and `r nb_text / nb_parsed_evals *100`% respectively.

There are `r nb_file_call_sites` call sites with the `file` argument, and `r nb_text_call_sites` with the `text` argument, i.e. `r  nb_file_call_sites / nb_parsed_call_sites * 100`%, and `r nb_text_call_sites / nb_parsed_call_sites *100`% respectively.
  
</details>

## Consistence

# Other faces of `eval`

# Case studies
