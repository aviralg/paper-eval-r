---
title: "Empirical Evaluation of eval in R"
output:
  rmdformats::readthedown:
        code_folding: hide
        lightbox: true
        gallery: false
        df_print: paged
        toc_depth: 3
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
params:
    data_filepath: "/var/lib/R/project-evalR/run/package-evals-traced-corpus.2/calls.fst"
    #data_filepath: "/var/lib/R/project-evalR/run/package-evals-traced-all.1/calls.fst"
    # The trace data on all CRAN does not have all the columns of the smaller corpus. The analysis will fail for the big corpus.

# This makes it possible to generate the html file in the html subfolder
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "html") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center",
                      fig.retina = 2,
                      fig.width = 10,
                      cache.lazy = FALSE)

library(tidyverse)
library(stringr)
library(viridis)
library(vctrs)
library(DT)
library(fst)
library(fs)

source("insights.R", local = knitr::knit_global())
```

# Data

The analysis is being performed on dataset read from file `r params$data_filepath`.

```{r file-info, echo=FALSE}
file_info(params$data_filepath)
```

```{r load-data, echo=FALSE}
eval_calls <-
    read_fst(params$data_filepath) %>%
    as_tibble() %>%
    resolve_sexp_name(expr_expression_type) %>%
    resolve_sexp_name(expr_resolved_type) %>%
    resolve_sexp_name(enclos_type) %>%
    resolve_sexp_name(envir_type)


# A flexible way to document the dataset: it is quick and easy to document a new column
c_names <- names(eval_calls)
column_names <- setNames(data.frame(matrix(ncol = length(c_names), nrow = 0)), c_names)

column_names <- column_names %>% add_row()

column_names["file"] <- "File where the `eval` is executed"
column_names["eval_call_id"] <- "Unique id of a call" 
column_names["expr_parsed_expression"] <- "Contains the expression with a call to `parse` if there is one in the `expr` argument somewhere in the call stack."
column_names["caller_function"] <- "Function in which the `eval` is called."
column_names["caller_package"] <- "Package in which the `eval` is called."
column_names["eval_function"] <- "One of `eval`, `evalq`, `eval.parent`, and `local`."
column_names["eval_call_expression"] <- "The full expression with `eval` that has been traced."
column_names["eval_call_srcref"] <- "File name and line where the `eval` call is. Might ne NA, especially for calls originating from package base."
column_names["caller_expression"] <- "Expression in which the `eval` is called."
column_names["caller_srcref"] <- "File name and line where the caller of the `eval` is located. Might be NA (especially for callers in base)."
# The following ones were in package-evals-traced-corpus.1/calls.fst
#column_names["caller_srcref2"] <- "File name and line for some calls for which the caller seemed to be itself (mainly Rcpp and C calls)."
#column_names["caller_expression_2"] <- "Caller expression when the caller seems to call itself (see `caller_srcref2`)."
#column_names["caller_expression_2"] <- "Same as `caller_expression_2` but uses `format` to print, not `expr_to_string`."
column_names["caller_stack_expression"] <-"When `eval_function` == `caller_function`, climb up the stack to find the first different caller."
column_names["caller_stack_expression_raw"] <- "See `caller_stack_expression`. Does not use `expr_to_str` but `format`."
column_names["caller_stack_expression_srcref"] <- "srcref for `caller_stack_expression."
# To continue

# Pivoting

column_names <- column_names %>% rownames_to_column() %>% 
  pivot_longer(-rowname) %>%
  pivot_wider(names_from=rowname, values_from=value)

column_names <- column_names %>%  rename("Description" = `1`) %>% filter(!is.na(Description))

```


The columns of the dataset are the following ones:
```{r column_names}
column_names %>% knitr::kable()
```


# Corpus

TODO

# Research Questions

## RQ1: How many evals are there?

There are four kinds of `eval` in the `base` package. Their definitions are shown below.

```{r, eval-definition, eval=FALSE}
base::eval <-
    function(expr, 
             envir = parent.frame(), 
             enclos = if (is.list(envir)||is.pairlist(envir)) parent.frame() else baseenv())
        .Internal(eval(expr, envir, enclos))

base::evalq <-
    function (expr, 
              envir = parent.frame(), 
              enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv())
        .Internal(eval(substitute(expr), envir, enclos))

base::eval.parent <-
    function (expr, n = 1) {
        p <- parent.frame(n + 1)
        eval(expr, p)
    }

base::local <-
    function (expr, envir = new.env())
        eval.parent(substitute(eval(quote(expr), envir)))
```

```{r eval-count-table}
callsites_with_srcref <-
    eval_calls %>% 
    select(eval_call_srcref) %>% 
    n_distinct(na.rm = TRUE)

callsites_without_srcref <-
    eval_calls %>% 
    filter(is.na(eval_call_srcref)) %>% 
    select(caller_package, caller_function) %>% 
    n_distinct()

eval_calls <-
    eval_calls %>%
    mutate(eval_call_srcref = coalesce(eval_call_srcref, 
                                       str_c("missing", "::", caller_package, "::", caller_function)))
eval_count_table <-
    eval_calls %>%
    group_by(eval_function, eval_call_srcref) %>%
    summarize(count = n()) %>%
    summarize(call_count = sum(count), callsite_count = n())
    
nb_eval_calls <- total_call_count <- sum(eval_count_table$call_count)

nb_call_sites <- total_callsite_count <- sum(eval_count_table$callsite_count)
    
eval_count_table <-
    eval_count_table %>%
    mutate(call_proportion = 100 * call_count / total_call_count,
           callsite_proportion = 100 * callsite_count / total_callsite_count) %>%
    arrange(desc(call_count))

eval_call_proportion <- 
    eval_count_table %>%
    filter(eval_function == "eval") %>%
    pull(call_proportion)
```

There are `r NA` R function calls with `r total_call_count` calls to the four kinds of eval which accounts for `r NA`% of all R function calls.
The table below summarizes the proportion of calls to the different kinds of evals.


```{r }
eval_count_table %>%
select(eval_function, call_count, call_proportion) %>% 
datatable()
```

We observe that `r eval_call_proportion`% of the calls are made to the `eval` function.

These `eval` calls originate from `r total_callsite_count` call sites. For the number of call sites, we use line number information attached to the AST by the parser. When it is not available (such as in *base*), we use a combination of `caller_package` and `caller_function`. We assume that:

  - the combination `caller_package` and `caller_function` is unique
  - there is only one call site per such `caller_function`
This assumption results in a lower bound for the number of unique callsites for eval.


```{r call-site-table}
eval_callsite_table <-
    eval_calls %>%
    count(eval_function, caller_package, eval_call_srcref, name = "call_count") %>%
    group_by(eval_function, caller_package) %>%
    summarize(call_count = sum(call_count), callsite_count = n()) %>%
    ungroup()

eval_callsite_table %>%
datatable()
```

```{r call-site-distribution}
package_callsite_distribution <-
    eval_callsite_table %>%
    mutate(callsite_count = if_else(callsite_count <= 5, as.character(callsite_count), "> 5")) %>%
    group_by(eval_function, callsite_count) %>%
    summarize(package_count = n())
    
package_callsite_distribution %>%
datatable()

p <-
    package_callsite_distribution %>%
    ggplot(aes(callsite_count, package_count)) +
    geom_col() +
    facet_wrap(vars(eval_function))
p
```


To asses how precise the call site estimate is for calls that do not have `srcref`, we compare it on *base* with the actual count given by `grep`.

```{r eval_call_sites_base}
nb_call_site_base <- eval_calls %>% filter(caller_package == "base") %>% select(caller_function) %>% n_distinct(na.rm = TRUE)
```
The estimate for *base* is `r nb_call_site_base` call sites, while `grep` yields 40 `eval` call sites.

For the other packages, ranked by call sites:
```{r eval_call_sites_per_package}
eval_calls %>% filter(caller_package != "base") %>% group_by(caller_package) %>% summarize(nb_call_sites =  n_distinct(eval_call_srcref, na.rm = TRUE)) %>% arrange(desc(nb_call_sites))
```

We probably forget the generated ones here, but should we count them in the _call sites_?


What are the packages with the highest number of `eval` calls?

```{r nb_eval_calls_per_package}
nb_eval_calls_per_package <- eval_calls %>% group_by(caller_package) %>% summarise(nb_eval_calls_package = n(), per_cent = nb_eval_calls_package / nb_eval_calls * 100) %>% arrange(desc(nb_eval_calls_package))
```

*base* has the highest number of eval calls, i.e. `r nb_eval_calls_per_package[1, "per_cent"][[1]]`% of them.

  
```{r}
nb_eval_calls_per_package  %>% datatable()
```


### Excluding *base* from the data set

We tried to replace the 40 `eval` call sites in *base* and could do it in about 50% of the cases. The rest of the cases are legitimate uses of `eval`, basically variations of `eval`.

TODO: show some examples, replacements and non replacements

We argue that `eval` in *base* should be considered apart from the other `eval` calls.

`eval` in *base* does not use `parse`, so does not take strings potentially coming from users as input,  and thus are deemed to be _safe_.

```{r parse_in_base}
parsed_base <- eval_calls %>% filter(!is.na(expr_parsed_expression), caller_package == "base")

nb_call_site_parse_base <-  nb_eval_call_sites(parsed_base)
```

There are `r nrow(parsed_base)` `eval` calls with `parse` in *base*, which is `r nrow(parsed_base) / nrow(filter(eval_calls, caller_package == "base"))`%. In terms of call sites, there are `r nb_call_site_parse_base` such ones, i.e. `r nb_call_site_parse_base / nb_call_site_base * 100`.

They are the following ones:

```{r call_site_parse_base}
parsed_base %>% count(file, caller_function, caller_expression, expr_parsed_expression) %>% 
  arrange(desc(n)) %>% knitr::kable()
```


## Size of expressions as arguments to `eval`


```{r}
eval_calls %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=1) +
  scale_x_log10() +  scale_y_sqrt()
```

If we remove the outliers:
```{r}
eval_calls %>% filter(expr_expression_length < 25000) %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=2)  + scale_x_sqrt() +  scale_y_sqrt() 
```


<details>
  <summary>More details</summary>
  
  
What about the code size of expressions that seem to be generated?
An approximation of *generated* will be no `srcref` and not in `base`.


```{r code_size_srcref}
eval_calls %>% filter(is.na(eval_call_srcref), caller_package != "base") %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=1) + scale_x_sqrt() + scale_y_sqrt()
```

And the average size per package:
```{r average_size_package}
eval_calls %>% group_by(caller_package) %>% summarize(average_expr_size = mean(expr_expression_length, na.rm = TRUE)) %>% arrange(desc(average_expr_size))
```

If we look at the maxima, the largest ones are in *base*:
```{r max_size_package}
eval_calls %>% group_by(caller_package) %>% summarize(max_expr_size = max(expr_expression_length, na.rm = TRUE)) %>% arrange(desc(max_expr_size))
```

</details>



## Amount of computations performed in `eval`

## Aliases of `eval`


# A taxonomy of `eval`

## The operation mix

## Scope (environments)


## Patterns

### Classifying according to the type of the `expr` argument


```{r types}
per_expr_type <- eval_calls %>% count(expr_expression_type)
```



```{r}
 per_expr_type %>% mutate(per_cent = n / nb_eval_calls * 100 ) %>% arrange(desc(n)) %>% knitr::kable()
```


```{r}
per_expr_type %>% ggplot() +
  geom_col(aes(x = fct_reorder(expr_expression_type, n), y = n)) +
  scale_y_sqrt() + 
  coord_flip() +
  labs(title = "Calls per type", y = "n", x = "type" ) 
```

  
  
Expressions of types other than `call`,  `expression`, `name`, `bytecode` and `promise` are just returned unchanged. Here `language` refers to `call` , `name`to `symbol`. `bytecode` refers to bytecode objects, that are generated by the `compile`function:

```{r}
typeof(compiler::compile(1+1))
```


```{r not_unchanged_eval}
changed_evals <- eval_calls %>% mutate(changed =  fct_collapse(expr_expression_type, base_types = c("LANGSXP", "EXPRSXP", "SYMSXP", "PROMSXP", "BCODESXP"))) %>% count(changed) %>% mutate(per_cent = n / nb_eval_calls * 100 ) 
```


We can remove `eval` and leave there the expression in `r changed_evals[2, "per_cent"][[1]]`% of the eval calls (i.e. `r changed_evals[2, "n"][[1]]`).


## Provenance

Some `eval` result from parsing text (directly or through a file) with `parse`.

```{r eval_from_parse}
parsed_evals <- eval_calls %>% filter(!is.na(expr_parsed_expression))
nb_parsed_evals <- parsed_evals %>% nrow()
```

There are `r nb_parsed_evals` such calls, `r nb_parsed_evals / nb_eval_calls * 100`%.

```{r, echo = FALSE}
nb_parsed_call_sites <- nb_eval_call_sites(parsed_evals)
```

In terms of call sites, there are `r nb_parsed_call_sites` i.e. `r nb_parsed_call_sites / nb_call_sites * 100`%.

  
  We can differentiate further the provenance, i.e. whether the evaluated string comes from `file` or from `text`. However, we can only do it for `parse`, `str2lang` and `str2expression` at the top level of `expr_expression`, not buried in a function call.
  
```{r parsed_evals_source}
parsed_evals_args <- parsed_evals %>% filter(str_detect(expr_parsed_expression, "(parse|str2lang|str2expression)\\(")) %>% mutate(parse_args = map(expr_parsed_expression, extract_args_parse)) %>% unnest_wider(parse_args,  names_sep = "_")
```

```{r}
parsed_files <- parsed_evals_args %>% filter(!is.na(parse_args_file))
nb_file <- parsed_files %>% nrow()
nb_file_call_sites <- nb_eval_call_sites(parsed_files)
```

```{r}
parsed_texts <- parsed_evals_args %>% filter(!is.na(parse_args_text) | !is.na(parse_args_s))
nb_text <-  parsed_texts %>% nrow()
nb_text_call_sites <- nb_eval_call_sites(parsed_texts)
```

There are `r nb_file` calls with the `file` argument, and `r nb_text` with the `text` argument, i.e. `r  nb_file / nb_parsed_evals * 100`%, and `r nb_text / nb_parsed_evals *100`% respectively.

There are `r nb_file_call_sites` call sites with the `file` argument, and `r nb_text_call_sites` with the `text` argument, i.e. `r  nb_file_call_sites / nb_parsed_call_sites * 100`%, and `r nb_text_call_sites / nb_parsed_call_sites *100`% respectively.


## Consistence

# Other faces of `eval`

# Case studies
