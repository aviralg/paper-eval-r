---
title: "Empirical Evaluation of eval in R"
output:
  rmdformats::readthedown:
        code_folding: hide
        lightbox: true
        gallery: false
        df_print: paged
        toc_depth: 3
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
params:
    data_filepath: "/var/lib/R/project-evalR/run/package-evals-traced-all.1/calls.fst"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center",
                      fig.retina = 2,
                      fig.width = 10,
                      cache.lazy = FALSE)

library(tidyverse)
library(stringr)
library(viridis)
library(vctrs)
library(DT)
library(fst)

source("insights.R", local = knitr::knit_global())
```

# Data

```{r load-data, echo=FALSE}
eval_calls <-
    read_fst(params$data_filepath) %>%
    as_tibble() %>%
    resolve_sexp_name(expr_expression_type) %>%
    resolve_sexp_name(expr_resolved_type) %>%
    resolve_sexp_name(enclos_type) %>%
    resolve_sexp_name(envir_type)

c_names <- names(eval_calls)
column_names <- setNames(data.frame(matrix(ncol = length(c_names), nrow = 0)), c_names)

column_names <- column_names %>% add_row()

column_names["file"] <- "File where the `eval` is executed"
column_names["eval_call_id"] <- "Unique id of a call" 
column_names["expr_parsed_expression"] <- "Contains the expression with a call to `parse` if there is one in the `expr` argument somewhere in the call stack."

# Pivoting

column_names <- column_names %>% rownames_to_column() %>% 
  pivot_longer(-rowname) %>%
  pivot_wider(names_from=rowname, values_from=value)

column_names <- column_names %>%  rename("Description" = `1`) %>% filter(!is.na(Description))

column_names %>% knitr::kable()
```

# Research Questions

## RQ1: How many evals are there?

For the number of call sites, we either use the `srcref` when there is one. When there is not (such as in *base*), we use a combination of `caller_package` and `caller_function`.

```{r}
nb_call_sites <- eval_calls %>% select(eval_call_srcref) %>% n_distinct(na.rm = TRUE)  + eval_calls %>% filter(is.na(eval_call_srcref)) %>% select(caller_package, caller_function)%>% n_distinct()
```

<details>
  <summary>More information about when there is no <code>srcref</code> </summary>
  
  We assume that:
  
  - the combination `caller_package` and `caller_function` is unique
  - there is only one call site per such `caller_function`
  
  It means that we get a lower bound.
</details> 

There are `r nb_call_sites` different `eval` call sites.

### Per package

```{r eval_call_sites_base}
eval_calls %>% filter(caller_package == "base") %>% select(caller_function) %>% n_distinct(na.rm = TRUE)
```

<details>
  <summary> Comparing with <code>grep</code></summary>
  Grepping *base* to find eval call sites yields 40 `eval` call sites.
</details>

```{r eval_call_sites_per_package}
eval_calls %>% filter(caller_package != "base") %>% group_by(caller_package) %>% summarize(nb_call_sites =  n_distinct(eval_call_srcref, na.rm = TRUE)) %>% arrange(desc(nb_call_sites))
```

We probably forget the generated ones here, but should we count them in the _call sites_?

## Number of calls to `eval`

```{r}
nb_eval_calls <- eval_calls %>% nrow()
```

There are `r nb_eval_calls` eval calls.


```{r nb_eval_calls_per_package}
nb_eval_calls_per_package <- eval_calls %>% group_by(caller_package) %>% summarise(nb_eval_calls_package = n(), per_cent = nb_eval_calls_package / nb_eval_calls * 100) %>% arrange(desc(nb_eval_calls_package))
```

*base* has the highest number of eval calls, i.e. `r nb_eval_calls_per_package["per_cent", 1]`% of them.

  
```{r}
nb_eval_calls_per_package  %>% datatable()
```


## Size of expressions as arguments to `eval`


```{r}
eval_calls %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=1) +
  scale_x_log10() +  scale_y_sqrt()
```

If we remove the outliers:
```{r}
eval_calls %>% filter(expr_expression_length < 25000) %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=2)  + scale_x_sqrt() +  scale_y_sqrt() 
```


<details>
  <summary>More details</summary>
  
  
What about the code size of expressions that seem to be generated?
An approximation of *generated* will be no `srcref` and not in `base`.


```{r code_size_srcref}
eval_calls %>% filter(is.na(eval_call_srcref), caller_package != "base") %>% ggplot() +
  geom_histogram(aes(x = expr_expression_length), na.rm = TRUE, binwidth=1) + scale_x_sqrt() + scale_y_sqrt()
```

And the average size per package:
```{r average_size_package}
eval_calls %>% group_by(caller_package) %>% summarize(average_expr_size = mean(expr_expression_length, na.rm = TRUE)) %>% arrange(desc(average_expr_size))
```

If we look at the maxima, the largest ones are in *base*:
```{r max_size_package}
eval_calls %>% group_by(caller_package) %>% summarize(max_expr_size = max(expr_expression_length, na.rm = TRUE)) %>% arrange(desc(max_expr_size))
```

</details>



## Amount of computations performed in `eval`

## Aliases of `eval`


# A taxonomy of `eval`

## The operation mix

## Scope (environments)


## Patterns

### Classifying according to the type of the `expr` argument


```{r types}
per_expr_type <- eval_calls %>% count(expr_expression_type)
```



```{r}
 per_expr_type %>% mutate(per_cent = n / nb_eval_calls * 100 ) %>% arrange(desc(n)) %>% knitr::kable()
```


```{r}
per_expr_type %>% ggplot() +
  geom_col(aes(x = fct_reorder(expr_expression_type, n), y = n)) +
  scale_y_sqrt() + 
  coord_flip() +
  labs(title = "Calls per type", y = "n", x = "type" ) 
```




<details> 
  <summary>Expressions left unchanged by <code>eval</code></summary>
  
  
Expressions of types other than `call`,  `expression`, `name`, `bytecode` and `promise` are just returned unchanged. Here `language` refers to `call` , `name`to `symbol`. `bytecode` refers to bytecode objects, that are generated by the `compile`function:

```{r}
typeof(compiler::compile(1+1))
```


```{r not_unchanged_eval}
changed_evals <- eval_calls %>% mutate(changed =  fct_collapse(expr_expression_type, base_types = c("LANGSXP", "EXPRSXP", "SYMSXP", "PROMSXP", "BCODESXP"))) %>% count(changed) %>% mutate(per_cent = n / nb_eval_calls * 100 ) 
```


We can remove `eval` and leave there the expression in `r changed_evals[2, "per_cent"][[1]]`% of the eval calls (i.e. `r changed_evals[2, "n"][[1]]`).

</details>

## Provenance

Some `eval` result from parsing text (directly or through a file) with `parse`.

```{r eval_from_parse}
parsed_evals <- eval_calls %>% filter(!is.na(expr_parsed_expression))
nb_parsed_evals <- parsed_evals %>% nrow()
```

There are `r nb_parsed_evals` such calls, `r nb_parsed_evals / nb_eval_calls * 100`%.

```{r, hide = TRUE}
nb_parsed_call_sites <- nb_eval_call_sites(parsed_evals)
```

In terms of call sites, there are `r nb_parsed_call_sites` i.e. `r nb_parsed_call_sites / nb_call_sites * 100`%.

<details>
  <summary>More about <code>parse</code> </summary>
  
  We can differentiate further the provenance, i.e. whether the evaluated string comes from `file` or from `text`. However, we can only do it for `parse`, `str2lang` and `str2expression` at the top level of `expr_expression`, not buried in a function call.
  
```{r parsed_evals_source}
parsed_evals_args <- parsed_evals %>% filter(str_detect(expr_parsed_expression, "(parse|str2lang|str2expression)\\(")) %>% mutate(parse_args = map(expr_parsed_expression, extract_args_parse)) %>% unnest_wider(parse_args,  names_sep = "_")
```

```{r}
parsed_files <- parsed_evals_args %>% filter(!is.na(parse_args_file))
nb_file <- parsed_files %>% nrow()
nb_file_call_sites <- nb_eval_call_sites(parsed_files)
```

```{r}
parsed_texts <- parsed_evals_args %>% filter(!is.na(parse_args_text) | !is.na(parse_args_s))
nb_text <-  parsed_texts %>% nrow()
nb_text_call_sites <- nb_eval_call_sites(parsed_texts)
```

There are `r nb_file` calls with the `file` argument, and `r nb_text` with the `text` argument, i.e. `r  nb_file / nb_parsed_evals * 100`%, and `r nb_text / nb_parsed_evals *100`% respectively.

There are `r nb_file_call_sites` call sites with the `file` argument, and `r nb_text_call_sites` with the `text` argument, i.e. `r  nb_file_call_sites / nb_parsed_call_sites * 100`%, and `r nb_text_call_sites / nb_parsed_call_sites *100`% respectively.
  
</details>

## Consistence

# Other faces of `eval`

# Case studies
