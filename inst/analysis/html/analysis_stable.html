<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="date" content="2020-08-23" />

<title>Empirical Evaluation of eval in R</title>

<script src="analysis_stable_files/jquery-1.12.4/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="analysis_stable_files/bootstrap-3.3.7/css/bootstrap.min.css" rel="stylesheet" />
<script src="analysis_stable_files/bootstrap-3.3.7/js/bootstrap.min.js"></script>
<script src="analysis_stable_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<script src="analysis_stable_files/navigation-1.1/tabsets.js"></script>
<script src="analysis_stable_files/navigation-1.1/codefolding.js"></script>
<link href="analysis_stable_files/magnific-popup-1.1.0/magnific-popup.css" rel="stylesheet" />
<script src="analysis_stable_files/magnific-popup-1.1.0/jquery.magnific-popup.min.js"></script>
<link href="analysis_stable_files/readthedown-0.1/readthedown.css" rel="stylesheet" />
<script src="analysis_stable_files/readthedown-0.1/readthedown.js"></script>
<script src="analysis_stable_files/accessible-code-block-0.0.1/empty-anchor.js"></script>
<link href="analysis_stable_files/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="analysis_stable_files/pagedtable-1.1/js/pagedtable.js"></script>
<script src="analysis_stable_files/htmlwidgets-1.5.1/htmlwidgets.js"></script>
<link href="analysis_stable_files/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
<script src="analysis_stable_files/datatables-binding-0.14/datatables.js"></script>
<link href="analysis_stable_files/dt-core-1.10.20/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="analysis_stable_files/dt-core-1.10.20/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="analysis_stable_files/dt-core-1.10.20/js/jquery.dataTables.min.js"></script>
<link href="analysis_stable_files/crosstalk-1.1.0.1/css/crosstalk.css" rel="stylesheet" />
<script src="analysis_stable_files/crosstalk-1.1.0.1/js/crosstalk.min.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */
</style>


</head>

<body>


<div id="content" data-toggle="wy-nav-shift">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("text-table-of-contents");
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("hide" === "show");
});
</script>

<nav id="nav-top" role="navigation" aria-label="top navigation">
    <a role="button" href="#" data-toggle="wy-nav-top"><span class="glyphicon glyphicon-menu-hamburger"></span></a>
</nav>

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span class="text-muted">Code</span> <span class="text-muted caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All</a></li>
</ul>
</div>

<div id="header">
<h1 class="title">Empirical Evaluation of eval in R</h1>
</div>


<div id="sidebar">
    <h2><a href="#content">Empirical Evaluation of eval in R</a></h2>
    <div id="table-of-contents">
      <ul>
      <li><a href="#data">Data</a></li>
      <li><a href="#corpus">Corpus</a></li>
      <li><a href="#research-questions">Research Questions</a><ul>
      <li><a href="#rq1-how-many-evals-are-there">RQ1: How many evals are there?</a><ul>
      <li><a href="#excluding-base-from-the-data-set">Excluding <em>base</em> from the data set</a></li>
      </ul></li>
      <li><a href="#size-of-expressions-as-arguments-to-eval">Size of expressions as arguments to <code>eval</code></a></li>
      <li><a href="#amount-of-computations-performed-in-eval">Amount of computations performed in <code>eval</code></a></li>
      <li><a href="#aliases-of-eval">Aliases of <code>eval</code></a></li>
      </ul></li>
      <li><a href="#a-taxonomy-of-eval">A taxonomy of <code>eval</code></a><ul>
      <li><a href="#the-operation-mix">The operation mix</a></li>
      <li><a href="#scope-environments">Scope (environments)</a></li>
      <li><a href="#patterns">Patterns</a></li>
      <li><a href="#provenance">Provenance</a></li>
      <li><a href="#consistence">Consistence</a></li>
      </ul></li>
      <li><a href="#other-faces-of-eval">Other faces of <code>eval</code></a></li>
      <li><a href="#case-studies">Case studies</a></li>
      </ul>
    </div>
    
    <div id="postamble" data-toggle="wy-nav-shift" class="status">
              <p class="date"><span class="glyphicon glyphicon-calendar"></span> 2020-08-23</p>
        </div>
</div>

<div id="main">
<div id="data" class="section level1">
<h1>Data</h1>
<p>The analysis is being performed on dataset read from file /var/lib/R/project-evalR/run/package-evals-traced-corpus.5/summarized-packages.fst.</p>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["path"],"name":[1],"type":["S3: fs_path"],"align":["right"]},{"label":["type"],"name":[2],"type":["fctr"],"align":["left"]},{"label":["size"],"name":[3],"type":["S3: fs_bytes"],"align":["right"]},{"label":["permissions"],"name":[4],"type":["S3: fs_perms"],"align":["right"]},{"label":["modification_time"],"name":[5],"type":["S3: POSIXct"],"align":["right"]},{"label":["user"],"name":[6],"type":["chr"],"align":["left"]},{"label":["group"],"name":[7],"type":["chr"],"align":["left"]},{"label":["device_id"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["hard_links"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["special_device_id"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["inode"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["block_size"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["blocks"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["flags"],"name":[14],"type":["int"],"align":["right"]},{"label":["generation"],"name":[15],"type":["dbl"],"align":["right"]},{"label":["access_time"],"name":[16],"type":["S3: POSIXct"],"align":["right"]},{"label":["change_time"],"name":[17],"type":["S3: POSIXct"],"align":["right"]},{"label":["birth_time"],"name":[18],"type":["S3: POSIXct"],"align":["right"]}],"data":[{"1":"/var/lib/R/project-evalR/run/package-evals-traced-corpus.5/summarized-packages.fst","2":"file","3":"444.82M","4":"rw-r--r--","5":"2020-08-22 16:29:59","6":"rstudio","7":"rstudio","8":"66304","9":"1","10":"0","11":"6555025014","12":"4096","13":"911000","14":"0","15":"0","16":"2020-08-22 15:58:01","17":"2020-08-22 16:29:59","18":"2020-08-22 16:29:59"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>The columns of the dataset are the following ones:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>column_names <span class="op">%&gt;%</span><span class="st"> </span>knitr<span class="op">::</span><span class="kw">kable</span>()</span></code></pre></div>
<table>
<colgroup>
<col width="21%" />
<col width="78%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">file</td>
<td align="left">File where the <code>eval</code> is executed</td>
</tr>
<tr class="even">
<td align="left">eval_function</td>
<td align="left">One of <code>eval</code>, <code>evalq</code>, <code>eval.parent</code>, and <code>local</code>.</td>
</tr>
<tr class="odd">
<td align="left">eval_call_expression</td>
<td align="left">The full expression with <code>eval</code> that has been traced.</td>
</tr>
<tr class="even">
<td align="left">eval_call_srcref</td>
<td align="left">File name and line where the <code>eval</code> call is. Might ne NA, especially for calls originating from package base.</td>
</tr>
<tr class="odd">
<td align="left">caller_package</td>
<td align="left">Package in which the <code>eval</code> is called.</td>
</tr>
<tr class="even">
<td align="left">caller_function</td>
<td align="left">Function in which the <code>eval</code> is called.</td>
</tr>
<tr class="odd">
<td align="left">caller_expression</td>
<td align="left">Expression in which the <code>eval</code> is called.</td>
</tr>
<tr class="even">
<td align="left">caller_srcref</td>
<td align="left">File name and line where the caller of the <code>eval</code> is located. Might be NA (especially for callers in base).</td>
</tr>
<tr class="odd">
<td align="left">expr_parsed_expression</td>
<td align="left">Contains the expression with a call to <code>parse</code> if there is one in the <code>expr</code> argument somewhere in the call stack.</td>
</tr>
<tr class="even">
<td align="left">eval_call_id</td>
<td align="left">Unique id of a call</td>
</tr>
<tr class="odd">
<td align="left">caller_stack_expression</td>
<td align="left">When <code>eval_function</code> == <code>caller_function</code>, climb up the stack to find the first different caller.</td>
</tr>
<tr class="even">
<td align="left">caller_stack_expression_raw</td>
<td align="left">See <code>caller_stack_expression</code>. Does not use <code>expr_to_str</code> but <code>format</code>.</td>
</tr>
<tr class="odd">
<td align="left">caller_stack_expression_srcref</td>
<td align="left">srcref for <code>caller_stack_expression</code>.</td>
</tr>
</tbody>
</table>
</div>
<div id="corpus" class="section level1">
<h1>Corpus</h1>
<p>TODO</p>
</div>
<div id="research-questions" class="section level1">
<h1>Research Questions</h1>
<div id="rq1-how-many-evals-are-there" class="section level2">
<h2>RQ1: How many evals are there?</h2>
<p>There are four kinds of <code>eval</code> in the <code>base</code> package. Their definitions are shown below.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>base<span class="op">::</span>eval &lt;-</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="st">    </span><span class="cf">function</span>(expr, </span>
<span id="cb2-3"><a href="#cb2-3"></a>             <span class="dt">envir =</span> <span class="kw">parent.frame</span>(), </span>
<span id="cb2-4"><a href="#cb2-4"></a>             <span class="dt">enclos =</span> <span class="cf">if</span> (<span class="kw">is.list</span>(envir)<span class="op">||</span><span class="kw">is.pairlist</span>(envir)) <span class="kw">parent.frame</span>() <span class="cf">else</span> <span class="kw">baseenv</span>())</span>
<span id="cb2-5"><a href="#cb2-5"></a>        <span class="kw">.Internal</span>(<span class="kw">eval</span>(expr, envir, enclos))</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>base<span class="op">::</span>evalq &lt;-</span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="st">    </span><span class="cf">function</span> (expr, </span>
<span id="cb2-9"><a href="#cb2-9"></a>              <span class="dt">envir =</span> <span class="kw">parent.frame</span>(), </span>
<span id="cb2-10"><a href="#cb2-10"></a>              <span class="dt">enclos =</span> <span class="cf">if</span> (<span class="kw">is.list</span>(envir) <span class="op">||</span><span class="st"> </span><span class="kw">is.pairlist</span>(envir)) <span class="kw">parent.frame</span>() <span class="cf">else</span> <span class="kw">baseenv</span>())</span>
<span id="cb2-11"><a href="#cb2-11"></a>        <span class="kw">.Internal</span>(<span class="kw">eval</span>(<span class="kw">substitute</span>(expr), envir, enclos))</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a>base<span class="op">::</span>eval.parent &lt;-</span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="st">    </span><span class="cf">function</span> (expr, <span class="dt">n =</span> <span class="dv">1</span>) {</span>
<span id="cb2-15"><a href="#cb2-15"></a>        p &lt;-<span class="st"> </span><span class="kw">parent.frame</span>(n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb2-16"><a href="#cb2-16"></a>        <span class="kw">eval</span>(expr, p)</span>
<span id="cb2-17"><a href="#cb2-17"></a>    }</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a>base<span class="op">::</span>local &lt;-</span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="st">    </span><span class="cf">function</span> (expr, <span class="dt">envir =</span> <span class="kw">new.env</span>())</span>
<span id="cb2-21"><a href="#cb2-21"></a>        <span class="kw">eval.parent</span>(<span class="kw">substitute</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(expr), envir)))</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>callsites_with_srcref &lt;-</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="st">    </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="st">    </span><span class="kw">select</span>(eval_call_srcref) <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="st">    </span><span class="kw">n_distinct</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a>callsites_without_srcref &lt;-</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="st">    </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="st">    </span><span class="kw">filter</span>(<span class="kw">is.na</span>(eval_call_srcref)) <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="st">    </span><span class="kw">select</span>(caller_package, caller_function) <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="st">    </span><span class="kw">n_distinct</span>()</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>eval_calls &lt;-</span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="st">    </span>eval_calls <span class="op">%&gt;%</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">eval_call_srcref =</span> <span class="kw">coalesce</span>(eval_call_srcref, </span>
<span id="cb3-15"><a href="#cb3-15"></a>                                       <span class="kw">str_c</span>(<span class="st">&quot;missing&quot;</span>, <span class="st">&quot;::&quot;</span>, caller_package, <span class="st">&quot;::&quot;</span>, caller_function)))</span>
<span id="cb3-16"><a href="#cb3-16"></a>eval_count_table &lt;-</span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="st">    </span>eval_calls <span class="op">%&gt;%</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="st">    </span><span class="kw">group_by</span>(eval_function, eval_call_srcref) <span class="op">%&gt;%</span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">count =</span> <span class="kw">sum</span>(nb_ev_calls)) <span class="op">%&gt;%</span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">call_count =</span> <span class="kw">sum</span>(count), <span class="dt">callsite_count =</span> <span class="kw">n</span>())</span></code></pre></div>
<pre><code>## `summarise()` regrouping output by &#39;eval_function&#39; (override with `.groups` argument)</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>nb_eval_calls &lt;-<span class="st"> </span>total_call_count &lt;-<span class="st"> </span><span class="kw">sum</span>(eval_count_table<span class="op">$</span>call_count)</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>nb_call_sites &lt;-<span class="st"> </span>total_callsite_count &lt;-<span class="st"> </span><span class="kw">sum</span>(eval_count_table<span class="op">$</span>callsite_count)</span>
<span id="cb6-4"><a href="#cb6-4"></a>    </span>
<span id="cb6-5"><a href="#cb6-5"></a>eval_count_table &lt;-</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="st">    </span>eval_count_table <span class="op">%&gt;%</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">call_proportion =</span> <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>call_count <span class="op">/</span><span class="st"> </span>total_call_count,</span>
<span id="cb6-8"><a href="#cb6-8"></a>           <span class="dt">callsite_proportion =</span> <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>callsite_count <span class="op">/</span><span class="st"> </span>total_callsite_count) <span class="op">%&gt;%</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="st">    </span><span class="kw">arrange</span>(<span class="kw">desc</span>(call_count))</span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a>eval_call_proportion &lt;-<span class="st"> </span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="st">    </span>eval_count_table <span class="op">%&gt;%</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="st">    </span><span class="kw">filter</span>(eval_function <span class="op">==</span><span class="st"> &quot;eval&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="st">    </span><span class="kw">pull</span>(call_proportion)</span></code></pre></div>
<p>There are NA R function calls with 5074913 calls to the four kinds of eval which accounts for NA% of all R function calls. The table below summarizes the proportion of calls to the different kinds of evals.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>eval_count_table <span class="op">%&gt;%</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">select</span>(eval_function, call_count, call_proportion) <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">datatable</span>()</span></code></pre></div>
<div id="htmlwidget-9867ea9a3cd048798924" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-9867ea9a3cd048798924">{"x":{"filter":"none","data":[["1","2","3","4"],["eval","eval.parent","local","evalq"],[5021240,52130,1251,292],[98.9423858103577,1.02720972753622,0.0246506688883139,0.00575379321773595]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>eval_function<\/th>\n      <th>call_count<\/th>\n      <th>call_proportion<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"columnDefs":[{"className":"dt-right","targets":[2,3]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<p>We observe that 98.9423858% of the calls are made to the <code>eval</code> function.</p>
<p>These <code>eval</code> calls originate from 2814 call sites. For the number of call sites, we use line number information attached to the AST by the parser. When it is not available (such as in <em>base</em>), we use a combination of <code>caller_package</code> and <code>caller_function</code>. We assume that:</p>
<ul>
<li>the combination <code>caller_package</code> and <code>caller_function</code> is unique</li>
<li>there is only one call site per such <code>caller_function</code> This assumption results in a lower bound for the number of unique callsites for eval.</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>eval_callsite_table &lt;-</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="st">    </span>eval_calls <span class="op">%&gt;%</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="st">    </span><span class="kw">count</span>(eval_function, caller_package, eval_call_srcref, <span class="dt">name =</span> <span class="st">&quot;call_count&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="st">    </span><span class="kw">group_by</span>(eval_function, caller_package) <span class="op">%&gt;%</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">call_count =</span> <span class="kw">sum</span>(call_count), <span class="dt">callsite_count =</span> <span class="kw">n</span>()) <span class="op">%&gt;%</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="st">    </span><span class="kw">ungroup</span>()</span></code></pre></div>
<pre><code>## `summarise()` regrouping output by &#39;eval_function&#39; (override with `.groups` argument)</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>eval_callsite_table <span class="op">%&gt;%</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">datatable</span>()</span></code></pre></div>
<div id="htmlwidget-739b36c8df2d89ae94ef" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-739b36c8df2d89ae94ef">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260","261","262","263","264","265","266","267","268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288","289","290","291","292","293","294","295","296","297","298","299","300","301","302","303","304","305","306","307","308","309","310","311","312","313","314","315","316","317","318","319","320","321","322","323","324","325","326","327","328","329","330","331","332","333","334","335","336","337","338","339","340","341","342","343","344","345","346","347","348","349","350","351","352","353","354","355","356","357","358","359","360","361","362","363","364","365","366","367","368","369","370","371","372","373","374","375","376","377","378","379","380","381","382","383","384","385","386","387","388","389","390","391","392","393","394","395","396","397","398","399","400","401","402","403","404","405","406","407","408","409","410","411","412","413","414","415","416","417","418","419","420","421","422","423","424","425","426","427","428","429","430","431","432","433","434","435","436","437","438","439","440","441","442","443","444","445","446","447","448","449","450","451","452","453","454","455","456","457","458","459","460","461","462","463","464","465","466","467","468","469","470","471","472","473","474","475","476","477","478","479","480","481","482","483","484","485","486","487","488","489","490","491","492","493","494","495","496","497","498","499","500","501","502","503","504","505","506","507"],["eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","evalq","evalq","evalq","evalq","local","local","local","local","local","local"],["_generator","A_generator","abind","AC_generator","AccumulateCallback_generator","actuar","Adapter_generator","ade4","adehabitatLT","AER","afex","animation","aod","ape","Appender_generator","AppenderConsole_generator","AppWrapper_generator","arm","arules","assertive.base","assertthat","Async_generator","AsyncVaried_generator","B_generator","backports","Bar_generator","base","BBmisc","bbmle","BC_generator","benchr","betareg","bit","bit64","blme","bnlearn","brms","btergm","C_generator","C1_generator","C2_generator","C2_inherit_generator","C2_override_generator","C3_generator","C3_inherit_inherit_generator","C3_inherit_override_generator","C3_override_inherit_generator","C3_override_override_generator","C4_generator","Callbacks_generator","car","caret","Cassette_generator","CC_generator","censReg","cgam","changepoint","checkmate","CheckReporter_generator","ChunkCallback_generator","circular","ClassSelector_generator","cli","ClientValue_generator","Cloner_generator","clue","cluster","coin","CombinedSelector_generator","content_type_generator","Context_generator","ContextBuilder_generator","ContinuousRange_generator","copula","CountingQueue_generator","cowplot","coxme","cplm","crch","CrulAdapter_generator","CustomCloner_generator","cvTools","data.table","DataFrameCallback_generator","DataMask_generator","DBI","DC_generator","DebugReporter_generator","DefinedHooks_generator","Dependents_generator","Deriv","desc","description_generator","DescTools","deSolve","dfidx","DiagrammeR","dir_collection_generator","dir_layout_generator","dir_master_generator","dir_sheet_generator","dir_slide_generator","directlabels","DiscreteRange_generator","DiskCache_generator","dismo","distr","distrEx","docx_part_generator","DoE.base","doRNG","doSNOW","dynlm","e1071","earth","effects","Element_generator","ellipse","emdbook","emmeans","EnvHash_generator","EOFToken_generator","ergm","estimatr","evaluate","factoextra","fBasics","feisr","ff","fGarch","fields","FileSystem_generator","Filterable_generator","fixest","flexclust","flextable","foreach","forecast","formatR","functional","futile.logger","future","future.apply","GA","gam","gamlss","gamlss.dist","gbm","gdata","gee","geepack","GenericTranslator_generator","GGally","ggplot2","ggthemes","glmmTMB","glmnet","globals","glue","gmm","gmnl","gnm","gplots","gridExtra","gss","gsubfn","gtools","Hash_generator","hexbin","HistoryQueue_generator","Hmisc","HoardClient_generator","HoardFile_generator","Hooks_generator","htmltools","HTTPInteraction_generator","HTTPInteractionList_generator","HttpLibAdapaterRegistry_generator","HttpRequest_generator","HttpResponse_generator","HttrAdapter_generator","igraph","imager","InputStream_generator","insight","irlba","iterators","jsonlite","kernlab","knitr","lambda.r","lattice","latticeExtra","lavaan","Layout_generator","LayoutFormat_generator","lazyeval","leaflet","leaps","lfe","ListCallback_generator","listenv","ListReporter_generator","lme4","lmerTest","lmodel2","locfit","LogEvent_generator","Logger_generator","LoggerRoot_generator","logistf","ltm","lubridate","magic","magrittr","Map_generator","maps","mapview","MASS","Matcher_generator","Matrix","maxLik","mboost","mc2d","mclust","MCMCpack","mda","memoise","MemoryCache_generator","metafor","MethodPattern_generator","mgcv","MinimalReporter_generator","minpack.lm","mitools","mlogit","mlr","mnormt","MockableTimerCallbacks_generator","mockery","MockSession_generator","MockShinySession_generator","modeltools","msm","multcomp","multgee","MultiReporter_generator","Mutable_generator","nlme","nloptr","NLP","nnet","Node_generator","np","NP_generator","NullList_generator","Numbers_generator","Observable_generator","Observer_generator","officer","openxml_document_generator","optimx","ordinal","pander","ParamHelpers","party","partykit","patchwork","PBSmapping","pcaPP","penalized","PerformanceAnalytics","permute","Persisters_generator","phangorn","pkgload","plm","plot3D","plotly","plotrix","pls","plyr","presentation_generator","PriorityQueue_generator","pROC","process_generator","processx","prodlim","progress_bar_generator","Progress_generator","progressor_generator","ProgressReporter_generator","Promise_generator","promises","proto","pryr","pscl","purrr","quanteda","quantmod","quantreg","Query_generator","Queue_generator","R_GlobalEnv","r_process_generator","r_session_generator","R.cache","R.devices","R.methodsS3","R.oo","R.rsp","R.utils","R2HTML","RandomFields","randomForest","randomForestSRC","Range_generator","ranger","raster","rcmd_process_generator","Rcpp","Rdpack","ReactiveEnvironment_generator","ReactiveVal_generator","ReactiveValues_generator","recipes","relationship_generator","Reporter_generator","Request_generator","RequestHandler_generator","RequestHandlerHttr_generator","RequestIgnorer_generator","RequestMatcherRegistry_generator","RequestPattern_generator","RequestSignature_generator","reshape","Response_generator","RestoreContext_generator","RestoreInputSet_generator","reticulate","Rfast","rgl","rJava","rjson","rlang","rlist","rmarkdown","Rmpfr","rms","robustbase","ROCR","rootSolve","roxygen2","RoxyTopic_generator","RoxyTopics_generator","rpart.plot","rprojroot","rrcov","rscript_process_generator","rsm","rstan","rstanarm","RUnit","RWeka","sampleSelection","sampling","Selector_generator","Serializers_generator","Server_generator","sets","sfsmisc","SharedData_generator","sheet_generator","shiny","SideEffectChunkCallback_generator","SilentReporter_generator","Simple_generator","slam","slide_generator","slide_layout_generator","slide_master_generator","sm","sn","sna","sp","SparseM","spatialreg","spatstat","speedglm","splines","Stack_generator","stars","statmod","statnet.common","stats","StopReporter_generator","stopwords","strucchange","StubbedRequest_generator","styler","SummaryReporter_generator","survey","survival","svUnit","systemfit","tables","taxon_state_generator","TeachingDemos","testit","testthat","tidyselect","TimerCallbacks_generator","timeSeries","tinytest","TMB","Token_generator","Token2.0_generator","TokenStream_generator","TopoSort_generator","tram","truncreg","units","unzip_process_generator","UriPattern_generator","usethis","utf8","utils","vars","vcd","vcr","VCRConfig_generator","VcrResponse_generator","vegan","Vertex_generator","VGAM","WebServer_generator","withr","worksheets_generator","XML","XPathExpr_generator","xts","YAML_generator","zip_process_generator","zoo","actuar","ade4","arm","base","bbmle","boot","caret","checkmate","coxme","cvTools","DescTools","distr","e1071","ff","forecast","future.apply","gdata","gsubfn","hexbin","lattice","latticeExtra","lfe","lme4","lmerTest","MASS","minpack.lm","network","nlme","nnet","np","ordinal","pbapply","PerformanceAnalytics","plyr","pROC","quantreg","R_GlobalEnv","Rcpp","rms","robustbase","rpart","rpart.plot","rrcov","spatstat","survey","survival","tree","tseries","vars","vegan","VGAM","withr","xts","data.table","globals","lfe","svUnit","bbmle","doRNG","estimatr","future","lfe","TMB"],[2,8,80,28,4,208,3,61,1,61,2,2,4,11,4,2,10,29,11,30,3799,2,2,5,38,4,77082,57,2029,19,3,75,3,42,3,12,170,2,3,7,2,5,5,2,2,2,2,2,2,6,101,7,2,14,1,1,25,452,28,15,23,2,44,10,2,75,29,1651,6,220,20,2,2,2150,2,1,2,6,1,2,2,4755,67827,10,1390,53,4,2,2,26,7,77,176,303,111,22,24,196,98,98,10,98,7,2,2,14,881,1,124,8,3,2,203,197,167,38,30,2,1,176,2,14,6342,2,799,18,224,1,244,11,4,2,3,7,24,22,1204,15,3,1,1,396,15,22,95,5049,59,8,3,51,110,30,2,1580,9,60,6,142,6234,1,4,1,173,1,2,7,14,2,17,2,183,6,4,2,26,2,2,2,2,2,2,5350,76,4,42,306,10,104,54,50,13,4792,88,39,3,2,156,23,4,19,6,1,36,12263,163,1,389,2,5,2,1,17,1321,308,67260,32,395,4,158,2,15,305,88,29,3334,1,1,50,4,3719,2,17,8,49,2,97,54,33,4,9,2,4,840,58,22,1,38,8,5556,1018,3,8,44,106,2,2,2,8,6,4,384,34,22,42,27,32,302,1,15,10,40,4456,318,2,28,301,1670,1,76,36,97,2232,98,20,74,134,1874,74,2,44,2,2,10,20,10,27,126,26,110,6,38,2,5,466,12,10,4,7,328,9577,1,34,3,540,50,1,4,9,1,4,1723,20,20,2,26,17,222,84,2,3,2,2,2,2,2,32,2,2,2,3,1,41,27,93,2057,875,4,113,160,2052,893,55,134,58,56,32,218,8,2,19,3,25,123,7,22,5,30,2,15,45,19,10,10,167,6,2,2,19,98,98,98,850,33,5,10,4,2,3655,19,2,4236,18,2,2980,96,2,27,60,2,1,6,610,913,5,63,20,2,1,379,14989,33,4,13,755,13,43,4,14,58,2,2,249,4,2,6,59,26,24,82,2,2,2,372,58,11778,10,2340,10,218,30,199,2,4,73,49,170,26,902,8424,132,4,81,3,6,12,1,207,15,53,6,2,16,4,179,14,4,9,710,449,8,4688,16,23,17,6,4,4,52,55,57,5,18,85,43,152,105,215,2,702,263,3,4,1,9,3,7,13,10,22,9,5,1043,3,2,8,1,4],[1,1,3,1,1,40,1,4,1,5,1,1,4,2,1,1,1,5,2,1,8,1,1,1,1,1,5,2,9,1,1,4,1,2,2,6,2,2,1,1,1,1,1,1,1,1,1,1,1,1,33,5,1,1,1,1,2,2,1,1,1,1,3,1,1,3,3,2,1,1,1,1,1,61,1,1,1,6,1,1,1,6,46,1,1,1,1,1,1,1,2,2,1,65,14,2,4,1,1,1,1,1,1,1,1,6,12,1,1,3,1,1,3,5,3,8,1,2,1,6,1,1,12,1,1,1,1,1,14,1,2,1,1,4,1,2,7,5,1,1,1,14,1,3,12,117,36,1,1,2,8,1,1,2,1,6,1,1,6,1,4,1,15,1,1,2,6,1,2,1,26,1,1,1,2,1,1,1,1,1,1,9,4,1,6,6,1,1,11,2,1,54,7,5,1,1,6,1,1,6,1,1,1,54,7,1,25,1,1,1,1,1,4,1,6,1,2,1,9,1,3,7,7,9,34,1,1,4,1,153,1,11,1,9,1,7,2,1,1,5,1,1,3,7,1,1,1,1,118,1,1,1,1,21,1,1,1,1,1,2,1,1,8,4,7,1,7,1,8,1,4,11,5,1,4,6,29,1,1,7,9,13,1,1,6,1,2,3,1,1,1,1,1,2,1,6,28,2,3,6,11,1,1,31,1,1,1,4,5,12,1,6,1,25,5,1,1,1,1,1,1,2,1,1,1,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,2,4,14,1,2,17,30,1,4,14,1,1,3,6,4,1,4,2,7,2,3,6,3,1,1,1,4,6,1,1,5,1,1,1,3,1,1,1,3,1,5,2,1,1,69,5,1,1,4,1,11,1,1,1,10,1,1,1,65,27,1,2,4,1,1,2,6,1,1,2,1,4,1,1,1,1,2,1,2,1,1,2,1,1,7,9,2,1,1,30,1,285,1,5,1,5,1,5,1,1,3,3,90,2,2,13,1,2,1,1,3,2,1,1,5,4,1,1,2,2,12,3,1,1,11,17,1,71,1,3,2,4,1,1,4,1,2,3,1,8,2,2,17,11,1,18,4,1,2,1,3,1,1,2,1,1,2,3,1,3,1,1,1,1]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>eval_function<\/th>\n      <th>caller_package<\/th>\n      <th>call_count<\/th>\n      <th>callsite_count<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"columnDefs":[{"className":"dt-right","targets":[3,4]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>package_callsite_distribution &lt;-</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="st">    </span>eval_callsite_table <span class="op">%&gt;%</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">callsite_count =</span> <span class="kw">if_else</span>(callsite_count <span class="op">&lt;=</span><span class="st"> </span><span class="dv">5</span>, <span class="kw">as.character</span>(callsite_count), <span class="st">&quot;&gt; 5&quot;</span>)) <span class="op">%&gt;%</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="st">    </span><span class="kw">group_by</span>(eval_function, callsite_count) <span class="op">%&gt;%</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">package_count =</span> <span class="kw">n</span>())</span></code></pre></div>
<pre><code>## `summarise()` regrouping output by &#39;eval_function&#39; (override with `.groups` argument)</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>package_callsite_distribution <span class="op">%&gt;%</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">datatable</span>()</span></code></pre></div>
<div id="htmlwidget-f30055a4bd4bd500a15d" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-f30055a4bd4bd500a15d">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17"],["eval","eval","eval","eval","eval","eval","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","eval.parent","evalq","evalq","evalq","local","local"],["&gt; 5","1","2","3","4","5","&gt; 5","1","2","3","4","5","1","2","3","1","3"],[89,256,41,18,22,18,10,20,12,6,4,1,2,1,1,5,1]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>eval_function<\/th>\n      <th>callsite_count<\/th>\n      <th>package_count<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"columnDefs":[{"className":"dt-right","targets":3},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>p &lt;-</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="st">    </span>package_callsite_distribution <span class="op">%&gt;%</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="st">    </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(callsite_count, package_count)) <span class="op">+</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="st">    </span><span class="kw">geom_col</span>() <span class="op">+</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="kw">vars</span>(eval_function))</span>
<span id="cb14-6"><a href="#cb14-6"></a>p</span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/call-site-distribution-2.png" width="960" style="display: block; margin: auto;" /></p>
<p>To asses how precise the call site estimate is for calls that do not have <code>srcref</code>, we compare it on <em>base</em> with the actual count given by <code>grep</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>nb_call_site_base &lt;-<span class="st"> </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(caller_package <span class="op">==</span><span class="st"> &quot;base&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(caller_function) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">n_distinct</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<p>The estimate for <em>base</em> is 5 call sites, while <code>grep</code> yields 40 <code>eval</code> call sites.</p>
<p>For the other packages, ranked by call sites:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(caller_package <span class="op">!=</span><span class="st"> &quot;base&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(caller_package) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">nb_call_sites =</span>  <span class="kw">n_distinct</span>(eval_call_srcref, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(nb_call_sites))</span></code></pre></div>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["caller_package"],"name":[1],"type":["chr"],"align":["left"]},{"label":["nb_call_sites"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"VGAM","2":"286"},{"1":"metafor","2":"153"},{"1":"nlme","2":"119"},{"1":"gamlss","2":"117"},{"1":"ade4","2":"94"},{"1":"survey","2":"83"},{"1":"network","2":"71"},{"1":"spatstat","2":"70"},{"1":"DescTools","2":"67"},{"1":"lattice","2":"66"},{"1":"copula","2":"61"},{"1":"lme4","2":"55"},{"1":"data.table","2":"47"},{"1":"actuar","2":"43"},{"1":"gamlss.dist","2":"36"},{"1":"mclust","2":"34"},{"1":"R_GlobalEnv","2":"34"},{"1":"car","2":"33"},{"1":"vegan","2":"33"},{"1":"robustbase","2":"32"},{"1":"plm","2":"29"},{"1":"survival","2":"29"},{"1":"pscl","2":"28"},{"1":"Hmisc","2":"26"},{"1":"MASS","2":"26"},{"1":"locfit","2":"25"},{"1":"RandomFields","2":"25"},{"1":"rms","2":"25"},{"1":"bbmle","2":"23"},{"1":"np","2":"23"},{"1":"rpart.plot","2":"20"},{"1":"ff","2":"19"},{"1":"lmerTest","2":"18"},{"1":"plyr","2":"17"},{"1":"gplots","2":"15"},{"1":"rrcov","2":"15"},{"1":"deSolve","2":"14"},{"1":"future","2":"14"},{"1":"rlist","2":"14"},{"1":"roxygen2","2":"14"},{"1":"distr","2":"13"},{"1":"quantreg","2":"13"},{"1":"ergm","2":"12"},{"1":"gam","2":"12"},{"1":"ordinal","2":"12"},{"1":"PerformanceAnalytics","2":"12"},{"1":"R.oo","2":"12"},{"1":"kernlab","2":"11"},{"1":"mgcv","2":"11"},{"1":"statnet.common","2":"11"},{"1":"latticeExtra","2":"10"},{"1":"lfe","2":"10"},{"1":"minpack.lm","2":"10"},{"1":"strucchange","2":"10"},{"1":"cvTools","2":"9"},{"1":"forecast","2":"9"},{"1":"igraph","2":"9"},{"1":"mc2d","2":"9"},{"1":"pls","2":"9"},{"1":"vcd","2":"9"},{"1":"assertthat","2":"8"},{"1":"effects","2":"8"},{"1":"geepack","2":"8"},{"1":"PBSmapping","2":"8"},{"1":"vars","2":"8"},{"1":"arm","2":"7"},{"1":"caret","2":"7"},{"1":"foreach","2":"7"},{"1":"maxLik","2":"7"},{"1":"mboost","2":"7"},{"1":"mlogit","2":"7"},{"1":"msm","2":"7"},{"1":"ParamHelpers","2":"7"},{"1":"partykit","2":"7"},{"1":"plotrix","2":"7"},{"1":"pROC","2":"7"},{"1":"rstanarm","2":"7"},{"1":"xts","2":"7"},{"1":"bnlearn","2":"6"},{"1":"cplm","2":"6"},{"1":"dismo","2":"6"},{"1":"e1071","2":"6"},{"1":"emmeans","2":"6"},{"1":"glmmTMB","2":"6"},{"1":"glue","2":"6"},{"1":"gtools","2":"6"},{"1":"insight","2":"6"},{"1":"irlba","2":"6"},{"1":"lazyeval","2":"6"},{"1":"magrittr","2":"6"},{"1":"pkgload","2":"6"},{"1":"pryr","2":"6"},{"1":"quantmod","2":"6"},{"1":"R.utils","2":"6"},{"1":"rprojroot","2":"6"},{"1":"sampleSelection","2":"6"},{"1":"sfsmisc","2":"6"},{"1":"testthat","2":"6"},{"1":"withr","2":"6"},{"1":"AER","2":"5"},{"1":"lavaan","2":"5"},{"1":"mockery","2":"5"},{"1":"permute","2":"5"},{"1":"R.methodsS3","2":"5"},{"1":"randomForest","2":"5"},{"1":"recipes","2":"5"},{"1":"shiny","2":"5"},{"1":"sna","2":"5"},{"1":"speedglm","2":"5"},{"1":"TMB","2":"5"},{"1":"XML","2":"5"},{"1":"aod","2":"4"},{"1":"betareg","2":"4"},{"1":"DiagrammeR","2":"4"},{"1":"doRNG","2":"4"},{"1":"fixest","2":"4"},{"1":"gmnl","2":"4"},{"1":"gsubfn","2":"4"},{"1":"hexbin","2":"4"},{"1":"imager","2":"4"},{"1":"lubridate","2":"4"},{"1":"memoise","2":"4"},{"1":"nnet","2":"4"},{"1":"pander","2":"4"},{"1":"penalized","2":"4"},{"1":"phangorn","2":"4"},{"1":"R.devices","2":"4"},{"1":"rJava","2":"4"},{"1":"rlang","2":"4"},{"1":"rootSolve","2":"4"},{"1":"rsm","2":"4"},{"1":"sets","2":"4"},{"1":"stars","2":"4"},{"1":"svUnit","2":"4"},{"1":"tables","2":"4"},{"1":"abind","2":"3"},{"1":"checkmate","2":"3"},{"1":"cli","2":"3"},{"1":"clue","2":"3"},{"1":"cluster","2":"3"},{"1":"DoE.base","2":"3"},{"1":"dynlm","2":"3"},{"1":"earth","2":"3"},{"1":"GA","2":"3"},{"1":"Matrix","2":"3"},{"1":"modeltools","2":"3"},{"1":"prodlim","2":"3"},{"1":"quanteda","2":"3"},{"1":"RWeka","2":"3"},{"1":"sampling","2":"3"},{"1":"slam","2":"3"},{"1":"sm","2":"3"},{"1":"zoo","2":"3"},{"1":"ape","2":"2"},{"1":"arules","2":"2"},{"1":"BBmisc","2":"2"},{"1":"bit64","2":"2"},{"1":"blme","2":"2"},{"1":"brms","2":"2"},{"1":"btergm","2":"2"},{"1":"changepoint","2":"2"},{"1":"coin","2":"2"},{"1":"coxme","2":"2"},{"1":"Deriv","2":"2"},{"1":"desc","2":"2"},{"1":"dfidx","2":"2"},{"1":"ellipse","2":"2"},{"1":"estimatr","2":"2"},{"1":"fields","2":"2"},{"1":"flextable","2":"2"},{"1":"future.apply","2":"2"},{"1":"gdata","2":"2"},{"1":"gee","2":"2"},{"1":"ggplot2","2":"2"},{"1":"globals","2":"2"},{"1":"htmltools","2":"2"},{"1":"knitr","2":"2"},{"1":"maps","2":"2"},{"1":"mlr","2":"2"},{"1":"officer","2":"2"},{"1":"processx","2":"2"},{"1":"promises","2":"2"},{"1":"purrr","2":"2"},{"1":"Rcpp","2":"2"},{"1":"Rdpack","2":"2"},{"1":"rjson","2":"2"},{"1":"Rmpfr","2":"2"},{"1":"rpart","2":"2"},{"1":"rstan","2":"2"},{"1":"RUnit","2":"2"},{"1":"sp","2":"2"},{"1":"systemfit","2":"2"},{"1":"testit","2":"2"},{"1":"timeSeries","2":"2"},{"1":"tram","2":"2"},{"1":"tseries","2":"2"},{"1":"units","2":"2"},{"1":"usethis","2":"2"},{"1":"vcr","2":"2"},{"1":"_generator","2":"1"},{"1":"A_generator","2":"1"},{"1":"AC_generator","2":"1"},{"1":"AccumulateCallback_generator","2":"1"},{"1":"Adapter_generator","2":"1"},{"1":"adehabitatLT","2":"1"},{"1":"afex","2":"1"},{"1":"animation","2":"1"},{"1":"Appender_generator","2":"1"},{"1":"AppenderConsole_generator","2":"1"},{"1":"AppWrapper_generator","2":"1"},{"1":"assertive.base","2":"1"},{"1":"Async_generator","2":"1"},{"1":"AsyncVaried_generator","2":"1"},{"1":"B_generator","2":"1"},{"1":"backports","2":"1"},{"1":"Bar_generator","2":"1"},{"1":"BC_generator","2":"1"},{"1":"benchr","2":"1"},{"1":"bit","2":"1"},{"1":"boot","2":"1"},{"1":"C_generator","2":"1"},{"1":"C1_generator","2":"1"},{"1":"C2_generator","2":"1"},{"1":"C2_inherit_generator","2":"1"},{"1":"C2_override_generator","2":"1"},{"1":"C3_generator","2":"1"},{"1":"C3_inherit_inherit_generator","2":"1"},{"1":"C3_inherit_override_generator","2":"1"},{"1":"C3_override_inherit_generator","2":"1"},{"1":"C3_override_override_generator","2":"1"},{"1":"C4_generator","2":"1"},{"1":"Callbacks_generator","2":"1"},{"1":"Cassette_generator","2":"1"},{"1":"CC_generator","2":"1"},{"1":"censReg","2":"1"},{"1":"cgam","2":"1"},{"1":"CheckReporter_generator","2":"1"},{"1":"ChunkCallback_generator","2":"1"},{"1":"circular","2":"1"},{"1":"ClassSelector_generator","2":"1"},{"1":"ClientValue_generator","2":"1"},{"1":"Cloner_generator","2":"1"},{"1":"CombinedSelector_generator","2":"1"},{"1":"content_type_generator","2":"1"},{"1":"Context_generator","2":"1"},{"1":"ContextBuilder_generator","2":"1"},{"1":"ContinuousRange_generator","2":"1"},{"1":"CountingQueue_generator","2":"1"},{"1":"cowplot","2":"1"},{"1":"crch","2":"1"},{"1":"CrulAdapter_generator","2":"1"},{"1":"CustomCloner_generator","2":"1"},{"1":"DataFrameCallback_generator","2":"1"},{"1":"DataMask_generator","2":"1"},{"1":"DBI","2":"1"},{"1":"DC_generator","2":"1"},{"1":"DebugReporter_generator","2":"1"},{"1":"DefinedHooks_generator","2":"1"},{"1":"Dependents_generator","2":"1"},{"1":"description_generator","2":"1"},{"1":"dir_collection_generator","2":"1"},{"1":"dir_layout_generator","2":"1"},{"1":"dir_master_generator","2":"1"},{"1":"dir_sheet_generator","2":"1"},{"1":"dir_slide_generator","2":"1"},{"1":"directlabels","2":"1"},{"1":"DiscreteRange_generator","2":"1"},{"1":"DiskCache_generator","2":"1"},{"1":"distrEx","2":"1"},{"1":"docx_part_generator","2":"1"},{"1":"doSNOW","2":"1"},{"1":"Element_generator","2":"1"},{"1":"emdbook","2":"1"},{"1":"EnvHash_generator","2":"1"},{"1":"EOFToken_generator","2":"1"},{"1":"evaluate","2":"1"},{"1":"factoextra","2":"1"},{"1":"fBasics","2":"1"},{"1":"feisr","2":"1"},{"1":"fGarch","2":"1"},{"1":"FileSystem_generator","2":"1"},{"1":"Filterable_generator","2":"1"},{"1":"flexclust","2":"1"},{"1":"formatR","2":"1"},{"1":"functional","2":"1"},{"1":"futile.logger","2":"1"},{"1":"gbm","2":"1"},{"1":"GenericTranslator_generator","2":"1"},{"1":"GGally","2":"1"},{"1":"ggthemes","2":"1"},{"1":"glmnet","2":"1"},{"1":"gmm","2":"1"},{"1":"gnm","2":"1"},{"1":"gridExtra","2":"1"},{"1":"gss","2":"1"},{"1":"Hash_generator","2":"1"},{"1":"HistoryQueue_generator","2":"1"},{"1":"HoardClient_generator","2":"1"},{"1":"HoardFile_generator","2":"1"},{"1":"Hooks_generator","2":"1"},{"1":"HTTPInteraction_generator","2":"1"},{"1":"HTTPInteractionList_generator","2":"1"},{"1":"HttpLibAdapaterRegistry_generator","2":"1"},{"1":"HttpRequest_generator","2":"1"},{"1":"HttpResponse_generator","2":"1"},{"1":"HttrAdapter_generator","2":"1"},{"1":"InputStream_generator","2":"1"},{"1":"iterators","2":"1"},{"1":"jsonlite","2":"1"},{"1":"lambda.r","2":"1"},{"1":"Layout_generator","2":"1"},{"1":"LayoutFormat_generator","2":"1"},{"1":"leaflet","2":"1"},{"1":"leaps","2":"1"},{"1":"ListCallback_generator","2":"1"},{"1":"listenv","2":"1"},{"1":"ListReporter_generator","2":"1"},{"1":"lmodel2","2":"1"},{"1":"LogEvent_generator","2":"1"},{"1":"Logger_generator","2":"1"},{"1":"LoggerRoot_generator","2":"1"},{"1":"logistf","2":"1"},{"1":"ltm","2":"1"},{"1":"magic","2":"1"},{"1":"Map_generator","2":"1"},{"1":"mapview","2":"1"},{"1":"Matcher_generator","2":"1"},{"1":"MCMCpack","2":"1"},{"1":"mda","2":"1"},{"1":"MemoryCache_generator","2":"1"},{"1":"MethodPattern_generator","2":"1"},{"1":"MinimalReporter_generator","2":"1"},{"1":"mitools","2":"1"},{"1":"mnormt","2":"1"},{"1":"MockableTimerCallbacks_generator","2":"1"},{"1":"MockSession_generator","2":"1"},{"1":"MockShinySession_generator","2":"1"},{"1":"multcomp","2":"1"},{"1":"multgee","2":"1"},{"1":"MultiReporter_generator","2":"1"},{"1":"Mutable_generator","2":"1"},{"1":"nloptr","2":"1"},{"1":"NLP","2":"1"},{"1":"Node_generator","2":"1"},{"1":"NP_generator","2":"1"},{"1":"NullList_generator","2":"1"},{"1":"Numbers_generator","2":"1"},{"1":"Observable_generator","2":"1"},{"1":"Observer_generator","2":"1"},{"1":"openxml_document_generator","2":"1"},{"1":"optimx","2":"1"},{"1":"party","2":"1"},{"1":"patchwork","2":"1"},{"1":"pbapply","2":"1"},{"1":"pcaPP","2":"1"},{"1":"Persisters_generator","2":"1"},{"1":"plot3D","2":"1"},{"1":"plotly","2":"1"},{"1":"presentation_generator","2":"1"},{"1":"PriorityQueue_generator","2":"1"},{"1":"process_generator","2":"1"},{"1":"progress_bar_generator","2":"1"},{"1":"Progress_generator","2":"1"},{"1":"progressor_generator","2":"1"},{"1":"ProgressReporter_generator","2":"1"},{"1":"Promise_generator","2":"1"},{"1":"proto","2":"1"},{"1":"Query_generator","2":"1"},{"1":"Queue_generator","2":"1"},{"1":"r_process_generator","2":"1"},{"1":"r_session_generator","2":"1"},{"1":"R.cache","2":"1"},{"1":"R.rsp","2":"1"},{"1":"R2HTML","2":"1"},{"1":"randomForestSRC","2":"1"},{"1":"Range_generator","2":"1"},{"1":"ranger","2":"1"},{"1":"raster","2":"1"},{"1":"rcmd_process_generator","2":"1"},{"1":"ReactiveEnvironment_generator","2":"1"},{"1":"ReactiveVal_generator","2":"1"},{"1":"ReactiveValues_generator","2":"1"},{"1":"relationship_generator","2":"1"},{"1":"Reporter_generator","2":"1"},{"1":"Request_generator","2":"1"},{"1":"RequestHandler_generator","2":"1"},{"1":"RequestHandlerHttr_generator","2":"1"},{"1":"RequestIgnorer_generator","2":"1"},{"1":"RequestMatcherRegistry_generator","2":"1"},{"1":"RequestPattern_generator","2":"1"},{"1":"RequestSignature_generator","2":"1"},{"1":"reshape","2":"1"},{"1":"Response_generator","2":"1"},{"1":"RestoreContext_generator","2":"1"},{"1":"RestoreInputSet_generator","2":"1"},{"1":"reticulate","2":"1"},{"1":"Rfast","2":"1"},{"1":"rgl","2":"1"},{"1":"rmarkdown","2":"1"},{"1":"ROCR","2":"1"},{"1":"RoxyTopic_generator","2":"1"},{"1":"RoxyTopics_generator","2":"1"},{"1":"rscript_process_generator","2":"1"},{"1":"Selector_generator","2":"1"},{"1":"Serializers_generator","2":"1"},{"1":"Server_generator","2":"1"},{"1":"SharedData_generator","2":"1"},{"1":"sheet_generator","2":"1"},{"1":"SideEffectChunkCallback_generator","2":"1"},{"1":"SilentReporter_generator","2":"1"},{"1":"Simple_generator","2":"1"},{"1":"slide_generator","2":"1"},{"1":"slide_layout_generator","2":"1"},{"1":"slide_master_generator","2":"1"},{"1":"sn","2":"1"},{"1":"SparseM","2":"1"},{"1":"spatialreg","2":"1"},{"1":"splines","2":"1"},{"1":"Stack_generator","2":"1"},{"1":"statmod","2":"1"},{"1":"stats","2":"1"},{"1":"StopReporter_generator","2":"1"},{"1":"stopwords","2":"1"},{"1":"StubbedRequest_generator","2":"1"},{"1":"styler","2":"1"},{"1":"SummaryReporter_generator","2":"1"},{"1":"taxon_state_generator","2":"1"},{"1":"TeachingDemos","2":"1"},{"1":"tidyselect","2":"1"},{"1":"TimerCallbacks_generator","2":"1"},{"1":"tinytest","2":"1"},{"1":"Token_generator","2":"1"},{"1":"Token2.0_generator","2":"1"},{"1":"TokenStream_generator","2":"1"},{"1":"TopoSort_generator","2":"1"},{"1":"tree","2":"1"},{"1":"truncreg","2":"1"},{"1":"unzip_process_generator","2":"1"},{"1":"UriPattern_generator","2":"1"},{"1":"utf8","2":"1"},{"1":"utils","2":"1"},{"1":"VCRConfig_generator","2":"1"},{"1":"VcrResponse_generator","2":"1"},{"1":"Vertex_generator","2":"1"},{"1":"WebServer_generator","2":"1"},{"1":"worksheets_generator","2":"1"},{"1":"XPathExpr_generator","2":"1"},{"1":"YAML_generator","2":"1"},{"1":"zip_process_generator","2":"1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>We probably forget the generated ones here, but should we count them in the <em>call sites</em>?</p>
<p>What are the packages with the highest number of <code>eval</code> calls?</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>nb_eval_calls_per_package &lt;-<span class="st"> </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(caller_package) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarise</span>(<span class="dt">nb_eval_calls_package =</span> <span class="kw">sum</span>(nb_ev_calls), <span class="dt">per_cent =</span> nb_eval_calls_package <span class="op">/</span><span class="st"> </span>nb_eval_calls <span class="op">*</span><span class="st"> </span><span class="dv">100</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(nb_eval_calls_package))</span></code></pre></div>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<p><em>base</em> has the highest number of eval calls, i.e. 39.9364285% of them.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>nb_eval_calls_per_package  <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">datatable</span>()</span></code></pre></div>
<div id="htmlwidget-45ca6d88f8572b0f59b0" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-45ca6d88f8572b0f59b0">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260","261","262","263","264","265","266","267","268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288","289","290","291","292","293","294","295","296","297","298","299","300","301","302","303","304","305","306","307","308","309","310","311","312","313","314","315","316","317","318","319","320","321","322","323","324","325","326","327","328","329","330","331","332","333","334","335","336","337","338","339","340","341","342","343","344","345","346","347","348","349","350","351","352","353","354","355","356","357","358","359","360","361","362","363","364","365","366","367","368","369","370","371","372","373","374","375","376","377","378","379","380","381","382","383","384","385","386","387","388","389","390","391","392","393","394","395","396","397","398","399","400","401","402","403","404","405","406","407","408","409","410","411","412","413","414","415","416","417","418","419","420","421","422","423","424","425","426","427","428","429","430","431","432","433","434","435","436","437","438","439","440","441","442","443","444","445","446","447","448","449","450"],["ggplot2","base","magrittr","data.table","glue","copula","brms","np","plyr","statnet.common","Stack_generator","VGAM","nlme","lme4","assertthat","igraph","testthat","withr","rlang","ergm","coin","processx","mclust","R_GlobalEnv","rprojroot","DataMask_generator","gamlss","nloptr","spatstat","bbmle","actuar","Node_generator","R.oo","maxLik","metafor","lattice","units","robustbase","checkmate","plm","network","foreach","xts","cvTools","survival","Vertex_generator","PerformanceAnalytics","sm","sna","TopoSort_generator","Reporter_generator","modeltools","description_generator","openxml_document_generator","ff","relationship_generator","magic","quantreg","Rcpp","survey","utf8","rlist","vegan","Matrix","distr","Map_generator","lubridate","future","lmerTest","dir_collection_generator","TMB","ROCR","DescTools","globals","RandomFields","evaluate","MASS","zoo","tinytest","Context_generator","process_generator","minpack.lm","rjson","msm","Promise_generator","earth","Dependents_generator","MultiReporter_generator","Rmpfr","ListReporter_generator","maps","R.utils","permute","Matcher_generator","irlba","rms","docx_part_generator","locfit","plotrix","RoxyTopic_generator","e1071","XML","testit","content_type_generator","slide_generator","shiny","pkgload","quanteda","ade4","BBmisc","partykit","R.methodsS3","RoxyTopics_generator","promises","pROC","AC_generator","insight","rrcov","mlr","future.apply","rpart","rpart.plot","Token_generator","cli","emmeans","vars","changepoint","forecast","mc2d","fBasics","nnet","desc","lazyeval","Element_generator","XPathExpr_generator","dynlm","phangorn","Callbacks_generator","sets","gam","Selector_generator","Hmisc","prodlim","roxygen2","gplots","dismo","rstan","dir_layout_generator","dir_master_generator","dir_slide_generator","presentation_generator","slide_layout_generator","slide_master_generator","Progress_generator","car","glmmTMB","GenericTranslator_generator","ReactiveValues_generator","Server_generator","deSolve","MemoryCache_generator","Request_generator","imager","pls","BC_generator","directlabels","boot","pscl","ChunkCallback_generator","mboost","utils","RUnit","doSNOW","kernlab","speedglm","lambda.r","latticeExtra","flexclust","gbm","geepack","Observer_generator","backports","rgl","tidyselect","jsonlite","effects","TimerCallbacks_generator","mlogit","knitr","penalized","stats","vcd","multcomp","party","betareg","memoise","abind","randomForest","DoE.base","bit64","GA","gamlss.dist","pander","arm","plotly","clue","ParamHelpers","DebugReporter_generator","Observable_generator","AppWrapper_generator","WebServer_generator","strucchange","AER","systemfit","Mutable_generator","purrr","MockableTimerCallbacks_generator","MockShinySession_generator","RequestMatcherRegistry_generator","ranger","stars","mnormt","C1_generator","tables","VcrResponse_generator","htmltools","Rdpack","RestoreInputSet_generator","rootSolve","vcr","stopwords","DBI","gee","mda","lfe","MethodPattern_generator","r_process_generator","RequestPattern_generator","sfsmisc","UriPattern_generator","leaflet","factoextra","mockery","r_session_generator","fields","lavaan","CC_generator","optimx","rsm","pcaPP","SideEffectChunkCallback_generator","rstanarm","pryr","recipes","sn","reshape","dfidx","slam","assertive.base","hexbin","mgcv","ordinal","Range_generator","rJava","cluster","Adapter_generator","CheckReporter_generator","ClientValue_generator","DiagrammeR","flextable","RestoreContext_generator","PBSmapping","gsubfn","sampleSelection","sheet_generator","circular","EOFToken_generator","TokenStream_generator","fGarch","HTTPInteraction_generator","PriorityQueue_generator","ReactiveEnvironment_generator","RequestHandler_generator","RequestSignature_generator","Response_generator","HoardFile_generator","ltm","Filterable_generator","HoardClient_generator","ReactiveVal_generator","usethis","DataFrameCallback_generator","dir_sheet_generator","gtools","SharedData_generator","SummaryReporter_generator","worksheets_generator","benchr","bnlearn","GGally","ggthemes","R.devices","timeSeries","HttrAdapter_generator","MinimalReporter_generator","Query_generator","Queue_generator","taxon_state_generator","A_generator","ape","arules","C2_inherit_generator","C2_override_generator","caret","Deriv","sp","CombinedSelector_generator","fixest","glmnet","iterators","mitools","proto","RequestHandlerHttr_generator","Simple_generator","StubbedRequest_generator","styler","svUnit","Logger_generator","AccumulateCallback_generator","B_generator","Bar_generator","DiskCache_generator","HttpRequest_generator","HttpResponse_generator","Persisters_generator","R.cache","rcmd_process_generator","Serializers_generator","SilentReporter_generator","quantmod","RWeka","sampling","Cassette_generator","ContinuousRange_generator","coxme","cplm","DiscreteRange_generator","doRNG","FileSystem_generator","HTTPInteractionList_generator","ListCallback_generator","LogEvent_generator","NLP","NullList_generator","progressor_generator","Token2.0_generator","YAML_generator","zip_process_generator","Appender_generator","blme","gdata","randomForestSRC","adehabitatLT","aod","AsyncVaried_generator","C_generator","C2_generator","C3_generator","C4_generator","DC_generator","estimatr","gmnl","InputStream_generator","Layout_generator","leaps","mapview","officer","pbapply","reticulate","rmarkdown","SparseM","StopReporter_generator","tseries","unzip_process_generator","bit","formatR","gridExtra","R2HTML","TeachingDemos","tree","_generator","afex","animation","AppenderConsole_generator","Async_generator","btergm","C3_inherit_inherit_generator","C3_inherit_override_generator","C3_override_inherit_generator","C3_override_override_generator","ClassSelector_generator","Cloner_generator","ContextBuilder_generator","CountingQueue_generator","CrulAdapter_generator","CustomCloner_generator","DefinedHooks_generator","ellipse","EnvHash_generator","gmm","gss","Hash_generator","HistoryQueue_generator","Hooks_generator","HttpLibAdapaterRegistry_generator","LayoutFormat_generator","LoggerRoot_generator","MCMCpack","MockSession_generator","NP_generator","Numbers_generator","progress_bar_generator","ProgressReporter_generator","RequestIgnorer_generator","rscript_process_generator","spatialreg","splines","statmod","tram","truncreg","VCRConfig_generator","censReg","cgam","cowplot","crch","distrEx","emdbook","feisr","functional","futile.logger","gnm","listenv","lmodel2","logistf","multgee","patchwork","plot3D","R.rsp","raster","Rfast"],[2026739,579801,536016,229073,192418,183587,166136,141967,118408,109455,65378,57234,44539,42149,40922,32940,28839,25010,24108,22833,22004,21550,20389,17866,16098,14700,13713,13679,13566,13429,12621,12520,11948,11705,10938,9859,8753,8388,7924,6714,6533,6262,6009,5890,5075,4850,4741,4246,4001,3966,3413,3316,3174,2930,2699,2604,2560,2232,2226,2095,2002,1635,1625,1595,1552,1360,1324,1317,1138,1105,1096,1079,1068,1057,874,844,840,819,807,790,790,784,782,712,672,639,618,616,616,610,600,575,562,528,480,477,472,468,463,460,435,428,415,400,394,385,374,370,365,353,349,333,332,328,323,322,312,297,294,282,271,271,267,261,251,250,242,239,227,224,223,211,209,208,208,207,206,204,199,198,198,194,192,183,176,175,172,170,170,170,170,170,170,166,164,157,150,150,144,142,142,142,141,141,140,140,132,132,128,127,126,125,122,120,119,118,118,114,113,111,108,107,107,106,104,100,99,97,96,96,96,95,93,92,87,87,86,85,84,82,81,78,78,77,76,75,75,74,74,72,72,71,69,69,68,68,66,66,66,63,63,61,60,60,60,59,59,56,56,56,55,53,51,50,48,44,44,44,44,44,43,41,40,40,39,39,38,38,37,36,36,35,34,33,33,32,31,31,30,30,30,30,30,30,29,28,28,28,28,28,28,27,26,26,26,24,24,24,22,20,20,20,20,20,20,18,17,16,16,16,15,14,14,14,14,14,14,13,13,13,13,13,13,12,12,12,12,12,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,9,8,8,8,8,8,8,8,8,8,8,8,7,7,7,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[39.9364284668525,11.42484610081,10.562072689719,4.51383107454256,3.79155268277505,3.61753984748113,3.27367188363623,2.79742726624082,2.33320255933451,2.15678574194277,1.28825853763404,1.12778288021883,0.877630808646375,0.830536405254632,0.806358650877365,0.64907516641172,0.568265899336599,0.492816330053343,0.475042626346501,0.44991904294714,0.433583787544732,0.424637821377431,0.401760581905542,0.352045443931748,0.317207408284635,0.289660138016159,0.27021152874936,0.269541566525377,0.267314927369198,0.264615373701973,0.248693918496731,0.246703736596076,0.235432607416127,0.230644347991778,0.215530788409575,0.194269340183763,0.172475863133023,0.165283621610853,0.156140607730615,0.13229783446534,0.128731270861195,0.123391277840625,0.11840597070334,0.1160611029194,0.100001714315103,0.0955681407740389,0.0934203207030347,0.0836664589126947,0.0788387899457587,0.0781491229504821,0.0672523844251123,0.0653410216096315,0.062542944085938,0.0577349798902957,0.0531831777214703,0.0513112244485767,0.0504442145116576,0.0439810495273515,0.0438628208995898,0.0412814958601261,0.0394489521298198,0.0322173010650626,0.0320202533521264,0.0314291102133179,0.0305818050476924,0.0267984889593181,0.0260891171927479,0.0259511837936926,0.0224240297321353,0.021773772279446,0.0215964293378034,0.021261448225812,0.0210446957415822,0.0208279432573524,0.0172219701106206,0.0166308269718121,0.0165520078866377,0.0161382076894717,0.0159017504339483,0.0155667693219568,0.0155667693219568,0.0154485406941952,0.0154091311516079,0.0140297971610548,0.0132416063093101,0.0125913488566208,0.0121775486594549,0.0121381391168676,0.0121381391168676,0.0120199104891059,0.0118228627761698,0.0113302434938294,0.0110740814670123,0.0104041192430294,0.00945829022093581,0.00939917590705496,0.00930065205058688,0.00922183296541241,0.00912330910894433,0.00906419479506348,0.00857157551272308,0.00843364211366776,0.00817748008685075,0.00788190851744651,0.00776367988968481,0.00758633694804226,0.00736958446381248,0.00729076537863802,0.00719224152216994,0.00695578426664654,0.00687696518147208,0.00656168884077422,0.0065419840694806,0.00646316498430613,0.00636464112783805,0.00634493635654444,0.00614788864360827,0.00585231707420403,0.00579320276032318,0.00555674550479979,0.00533999302057001,0.00533999302057001,0.00526117393539554,0.00514294530763384,0.00494589759469768,0.00492619282340407,0.00476855465305514,0.00470944033917429,0.00447298308365089,0.00441386876977004,0.00439416399847643,0.00415770674295303,0.0041182972003658,0.00409859242907218,0.00409859242907218,0.00407888765777857,0.00405918288648495,0.00401977334389772,0.00392124948742964,0.00390154471613602,0.00390154471613602,0.00382272563096156,0.00378331608837432,0.00360597314673178,0.00346803974767646,0.00344833497638285,0.003389220662502,0.00334981111991477,0.00334981111991477,0.00334981111991477,0.00334981111991477,0.00334981111991477,0.00334981111991477,0.0032709920347403,0.00323158249215307,0.00309364909309775,0.00295571569404244,0.00295571569404244,0.00283748706628074,0.00279807752369351,0.00279807752369351,0.00279807752369351,0.00277837275239989,0.00277837275239989,0.00275866798110628,0.00275866798110628,0.00260102981075735,0.00260102981075735,0.00252221072558288,0.00250250595428927,0.00248280118299565,0.00246309641170203,0.00240398209782118,0.00236457255523395,0.00234486778394034,0.00232516301264672,0.00232516301264672,0.00224634392747225,0.00222663915617864,0.00218722961359141,0.00212811529971056,0.00210841052841694,0.00210841052841694,0.00208870575712332,0.00204929621453609,0.00197047712936163,0.00195077235806801,0.00191136281548078,0.00189165804418716,0.00189165804418716,0.00189165804418716,0.00187195327289355,0.00183254373030631,0.0018128389590127,0.00171431510254462,0.00171431510254462,0.001694610331251,0.00167490555995738,0.00165520078866377,0.00161579124607653,0.00159608647478292,0.00153697216090207,0.00153697216090207,0.00151726738960845,0.00149756261831484,0.00147785784702122,0.00147785784702122,0.0014581530757276,0.0014581530757276,0.00141874353314037,0.00141874353314037,0.00139903876184675,0.00135962921925952,0.00135962921925952,0.00133992444796591,0.00133992444796591,0.00130051490537867,0.00130051490537867,0.00130051490537867,0.00124140059149782,0.00124140059149782,0.00120199104891059,0.00118228627761698,0.00118228627761698,0.00118228627761698,0.00116258150632336,0.00116258150632336,0.00110346719244251,0.00110346719244251,0.00110346719244251,0.00108376242114889,0.00104435287856166,0.00100494333597443,0.000985238564680813,0.000945829022093581,0.000867009936919116,0.000867009936919116,0.000867009936919116,0.000867009936919116,0.000867009936919116,0.000847305165625499,0.000807895623038267,0.000788190851744651,0.000788190851744651,0.000768486080451034,0.000768486080451034,0.000748781309157418,0.000748781309157418,0.000729076537863802,0.000709371766570186,0.000709371766570186,0.000689666995276569,0.000669962223982953,0.000650257452689337,0.000650257452689337,0.00063055268139572,0.000610847910102104,0.000610847910102104,0.000591143138808488,0.000591143138808488,0.000591143138808488,0.000591143138808488,0.000591143138808488,0.000591143138808488,0.000571438367514872,0.000551733596221255,0.000551733596221255,0.000551733596221255,0.000551733596221255,0.000551733596221255,0.000551733596221255,0.000532028824927639,0.000512324053634023,0.000512324053634023,0.000512324053634023,0.00047291451104679,0.00047291451104679,0.00047291451104679,0.000433504968459558,0.000394095425872325,0.000394095425872325,0.000394095425872325,0.000394095425872325,0.000394095425872325,0.000394095425872325,0.000354685883285093,0.000334981111991477,0.00031527634069786,0.00031527634069786,0.00031527634069786,0.000295571569404244,0.000275866798110628,0.000275866798110628,0.000275866798110628,0.000275866798110628,0.000275866798110628,0.000275866798110628,0.000256162026817011,0.000256162026817011,0.000256162026817011,0.000256162026817011,0.000256162026817011,0.000256162026817011,0.000236457255523395,0.000236457255523395,0.000236457255523395,0.000236457255523395,0.000236457255523395,0.000216752484229779,0.000216752484229779,0.000216752484229779,0.000216752484229779,0.000216752484229779,0.000216752484229779,0.000216752484229779,0.000216752484229779,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000197047712936163,0.000177342941642546,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.00015763817034893,0.000137933399055314,0.000137933399055314,0.000137933399055314,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,0.000118228627761698,9.85238564680813e-05,9.85238564680813e-05,9.85238564680813e-05,9.85238564680813e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,7.88190851744651e-05,5.91143138808488e-05,5.91143138808488e-05,5.91143138808488e-05,5.91143138808488e-05,5.91143138808488e-05,5.91143138808488e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,3.94095425872325e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05,1.97047712936163e-05]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>caller_package<\/th>\n      <th>nb_eval_calls_package<\/th>\n      <th>per_cent<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"columnDefs":[{"className":"dt-right","targets":[2,3]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div id="excluding-base-from-the-data-set" class="section level3">
<h3>Excluding <em>base</em> from the data set</h3>
<p>When using <code>grep</code> , we find 30 call sites that use <code>eval</code> in <em>base</em>. We tried to replace the 30 <code>eval</code> call sites in <em>base</em> and could do it in 50% of the cases.</p>
<p>We reckon that <code>eval</code> in <em>base</em> should be considered apart from the other <code>eval</code> calls.</p>
<p><code>eval</code> in <em>base</em> does not consume user input, i.e. input coming from <code>parse</code>, except in 5 legitimate cases, such as the <code>sys.source</code> function that is used to <code>eval</code> a file.</p>
<table>
<colgroup>
<col width="19%" />
<col width="11%" />
<col width="4%" />
<col width="6%" />
<col width="58%" />
</colgroup>
<thead>
<tr class="header">
<th>Function name</th>
<th>File</th>
<th>Line</th>
<th>Parse ?</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>autoload</td>
<td>autoload</td>
<td>25</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>autoloader</td>
<td>autoload</td>
<td>43</td>
<td></td>
<td>To execute a call to library</td>
</tr>
<tr class="odd">
<td>autoloader</td>
<td>autoload</td>
<td>49</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>bquote</td>
<td>backquote</td>
<td>33</td>
<td></td>
<td>In subfunction unquote. To eval what is in .() . Metaprogramming</td>
</tr>
<tr class="odd">
<td>bquote</td>
<td>backquote</td>
<td>56</td>
<td></td>
<td>idem (in unquote.list, defined inside bquote)</td>
</tr>
<tr class="even">
<td>by.default</td>
<td>by</td>
<td>35</td>
<td></td>
<td>eval(substitute pattern?</td>
</tr>
<tr class="odd">
<td>by.data.frame</td>
<td>by</td>
<td>50</td>
<td></td>
<td>idem</td>
</tr>
<tr class="even">
<td>invokeRestartInteractively</td>
<td>conditions</td>
<td>245</td>
<td>yes</td>
<td>prompt</td>
</tr>
<tr class="odd">
<td>invokeRestartInteractively</td>
<td>conditions</td>
<td>249</td>
<td>yes</td>
<td>prompt</td>
</tr>
<tr class="even">
<td>Ops.data.frame</td>
<td>dataframe</td>
<td>1678</td>
<td></td>
<td>for arithmetic operators on data frames ; do.call could be probably used here also</td>
</tr>
<tr class="odd">
<td>dget</td>
<td>dput</td>
<td>32</td>
<td>yes</td>
<td>from file</td>
</tr>
<tr class="even">
<td>eval</td>
<td>eval</td>
<td>26</td>
<td></td>
<td>Call Internal eval</td>
</tr>
<tr class="odd">
<td>eval.parent</td>
<td>eval</td>
<td>30</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>evalq</td>
<td>eval</td>
<td>36</td>
<td></td>
<td>evalq is basically eval(substitute</td>
</tr>
<tr class="odd">
<td>local</td>
<td>eval</td>
<td>49</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>with.default</td>
<td>eval</td>
<td>57</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>within.data.frame</td>
<td>eval</td>
<td>63</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>within.list</td>
<td>eval</td>
<td>77</td>
<td></td>
<td>evalq</td>
</tr>
<tr class="odd">
<td>replicate</td>
<td>replicate</td>
<td>21</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>subset.data.frame</td>
<td>frametools</td>
<td>25</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>subset.data.frame</td>
<td>frametools</td>
<td>34</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>subset.matrix</td>
<td>frametools</td>
<td>56</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>transform.data.frame</td>
<td>frametools</td>
<td>69</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>match.arg</td>
<td>match</td>
<td>45</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>char.expand</td>
<td>match</td>
<td>79</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>max.col</td>
<td>max</td>
<td>22</td>
<td></td>
<td>To access formals</td>
</tr>
<tr class="odd">
<td>parseNamespaceFile</td>
<td>namespace</td>
<td>1315</td>
<td>yes</td>
<td>To parse directives</td>
</tr>
<tr class="even">
<td>idem</td>
<td>namespace</td>
<td>1319</td>
<td>yes</td>
<td></td>
</tr>
<tr class="odd">
<td>idem</td>
<td>namespace</td>
<td>1442</td>
<td>yes</td>
<td>evaluate a call from a parse</td>
</tr>
<tr class="even">
<td>source</td>
<td>source</td>
<td>123</td>
<td>yes</td>
<td>Use the internal parse function (here it is a comment)</td>
</tr>
<tr class="odd">
<td>source</td>
<td>source</td>
<td>170</td>
<td>yes</td>
<td>comment</td>
</tr>
<tr class="even">
<td>source</td>
<td>source</td>
<td>219</td>
<td>yes</td>
<td>the actual eval</td>
</tr>
<tr class="odd">
<td>sys.source</td>
<td>source</td>
<td>277</td>
<td>yes</td>
<td>the non-internal parse is used</td>
</tr>
<tr class="even">
<td>stopifnot</td>
<td>stop</td>
<td>54</td>
<td></td>
<td>change of caller pattern</td>
</tr>
<tr class="odd">
<td>as.data.frame.table</td>
<td>table</td>
<td>244</td>
<td></td>
<td>Build a call?</td>
</tr>
<tr class="even">
<td>match.fun</td>
<td>match.fun</td>
<td>28</td>
<td></td>
<td>eval.parent</td>
</tr>
<tr class="odd">
<td>trace</td>
<td>methodsSupport</td>
<td>38</td>
<td></td>
<td>eval.parent</td>
</tr>
<tr class="even">
<td>untrace</td>
<td>methodsSupport</td>
<td>53</td>
<td></td>
<td>eval.parent</td>
</tr>
<tr class="odd">
<td>.doTrace</td>
<td>methodsSupport</td>
<td>78</td>
<td></td>
<td>eval.parent</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>parsed_base &lt;-<span class="st"> </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(expr_parsed_expression), eval_call_package <span class="op">==</span><span class="st"> &quot;base&quot;</span>)</span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a>nb_call_site_parse_base &lt;-<span class="st">  </span><span class="kw">nb_eval_call_sites</span>(parsed_base)</span></code></pre></div>
There are
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["n"],"name":[1],"type":["int"],"align":["right"]}],"data":[{"1":"0"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<code>eval</code> calls with <code>parse</code> in <em>base</em>, which is
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["n"],"name":[1],"type":["dbl"],"align":["right"]}],"data":[{"1":"NaN"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>%.</p>
</div>
</div>
<div id="size-of-expressions-as-arguments-to-eval" class="section level2">
<h2>Size of expressions as arguments to <code>eval</code></h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(<span class="dt">x =</span> expr_expression_length, <span class="dt">weight =</span> nb_ev_calls), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">binwidth=</span><span class="dv">1</span>) <span class="op">+</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="st">  </span><span class="kw">scale_x_log10</span>() <span class="op">+</span><span class="st">  </span><span class="kw">scale_y_sqrt</span>()</span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/unnamed-chunk-3-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>If we remove the outliers:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(expr_expression_length <span class="op">&lt;</span><span class="st"> </span><span class="dv">25000</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(<span class="dt">x =</span> expr_expression_length, <span class="dt">weight =</span> nb_ev_calls), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">binwidth=</span><span class="dv">2</span>)  <span class="op">+</span><span class="st"> </span><span class="kw">scale_x_sqrt</span>() <span class="op">+</span><span class="st">  </span><span class="kw">scale_y_sqrt</span>() </span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/unnamed-chunk-4-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>What about the code size of expressions that seem to be generated? An approximation of <em>generated</em> will be no <code>srcref</code> and not in <code>base</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="kw">is.na</span>(eval_call_srcref), caller_package <span class="op">!=</span><span class="st"> &quot;base&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(<span class="dt">x =</span> expr_expression_length, <span class="dt">weight =</span> nb_ev_calls), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">binwidth=</span><span class="dv">1</span>) <span class="op">+</span><span class="st"> </span><span class="kw">scale_x_sqrt</span>() <span class="op">+</span><span class="st"> </span><span class="kw">scale_y_sqrt</span>()</span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/code_size_srcref-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>And the average size per package:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(caller_package) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">average_expr_size =</span> <span class="kw">mean</span>(expr_expression_length, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(average_expr_size))</span></code></pre></div>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["caller_package"],"name":[1],"type":["chr"],"align":["left"]},{"label":["average_expr_size"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"doRNG","2":"559.500000"},{"1":"memoise","2":"513.160000"},{"1":"estimatr","2":"505.500000"},{"1":"VGAM","2":"302.296919"},{"1":"utf8","2":"280.000000"},{"1":"effects","2":"246.078947"},{"1":"Rcpp","2":"183.273406"},{"1":"rprojroot","2":"164.770642"},{"1":"ROCR","2":"159.000000"},{"1":"np","2":"121.382114"},{"1":"lubridate","2":"111.894777"},{"1":"PerformanceAnalytics","2":"89.876906"},{"1":"DBI","2":"83.000000"},{"1":"future","2":"77.202970"},{"1":"R.utils","2":"74.352941"},{"1":"bit","2":"73.000000"},{"1":"clue","2":"72.493333"},{"1":"GGally","2":"62.000000"},{"1":"lfe","2":"60.696970"},{"1":"rjson","2":"60.000000"},{"1":"mnormt","2":"59.000000"},{"1":"raster","2":"58.000000"},{"1":"RandomFields","2":"56.350000"},{"1":"flextable","2":"55.500000"},{"1":"nloptr","2":"53.000000"},{"1":"stopwords","2":"53.000000"},{"1":"party","2":"51.000000"},{"1":"svUnit","2":"50.000000"},{"1":"fBasics","2":"49.000000"},{"1":"lme4","2":"46.877037"},{"1":"coin","2":"46.582677"},{"1":"shiny","2":"45.131737"},{"1":"DiagrammeR","2":"45.125000"},{"1":"sna","2":"44.400000"},{"1":"functional","2":"44.000000"},{"1":"sfsmisc","2":"43.421053"},{"1":"Rfast","2":"42.000000"},{"1":"gsubfn","2":"41.000000"},{"1":"quantmod","2":"40.666667"},{"1":"knitr","2":"40.420000"},{"1":"rstan","2":"40.000000"},{"1":"proto","2":"37.000000"},{"1":"globals","2":"35.841463"},{"1":"gamlss","2":"35.791840"},{"1":"mlr","2":"35.592593"},{"1":"changepoint","2":"34.800000"},{"1":"glue","2":"33.851781"},{"1":"strucchange","2":"32.483333"},{"1":"emmeans","2":"31.585227"},{"1":"gamlss.dist","2":"31.525424"},{"1":"promises","2":"31.500000"},{"1":"future.apply","2":"30.714286"},{"1":"pbapply","2":"30.000000"},{"1":"zoo","2":"28.726027"},{"1":"DescTools","2":"28.612698"},{"1":"magrittr","2":"28.603628"},{"1":"PBSmapping","2":"28.466667"},{"1":"magic","2":"28.000000"},{"1":"vcr","2":"28.000000"},{"1":"lambda.r","2":"27.000000"},{"1":"slam","2":"26.894737"},{"1":"data.table","2":"26.570559"},{"1":"gtools","2":"26.071429"},{"1":"rsm","2":"25.894737"},{"1":"btergm","2":"25.500000"},{"1":"formatR","2":"25.000000"},{"1":"stars","2":"24.833333"},{"1":"mockery","2":"24.444444"},{"1":"plotrix","2":"24.166667"},{"1":"spatstat","2":"24.064534"},{"1":"R.methodsS3","2":"23.734756"},{"1":"dismo","2":"23.500000"},{"1":"cplm","2":"22.500000"},{"1":"pscl","2":"22.293651"},{"1":"benchr","2":"22.000000"},{"1":"flexclust","2":"22.000000"},{"1":"multcomp","2":"22.000000"},{"1":"reticulate","2":"22.000000"},{"1":"styler","2":"22.000000"},{"1":"tseries","2":"22.000000"},{"1":"rJava","2":"21.555556"},{"1":"nlme","2":"21.508076"},{"1":"usethis","2":"21.500000"},{"1":"ltm","2":"21.000000"},{"1":"latticeExtra","2":"20.970588"},{"1":"distr","2":"20.763039"},{"1":"phangorn","2":"20.428571"},{"1":"mgcv","2":"20.411765"},{"1":"maps","2":"19.772152"},{"1":"DoE.base","2":"19.750000"},{"1":"hexbin","2":"19.666667"},{"1":"glmmTMB","2":"19.100000"},{"1":"factoextra","2":"19.000000"},{"1":"rgl","2":"19.000000"},{"1":"aod","2":"18.750000"},{"1":"pryr","2":"18.703704"},{"1":"htmltools","2":"18.423077"},{"1":"irlba","2":"18.333333"},{"1":"deSolve","2":"18.324324"},{"1":"sm","2":"18.263529"},{"1":"ordinal","2":"18.107143"},{"1":"mboost","2":"18.022727"},{"1":"arules","2":"18.000000"},{"1":"futile.logger","2":"18.000000"},{"1":"reshape","2":"18.000000"},{"1":"rmarkdown","2":"18.000000"},{"1":"systemfit","2":"17.095238"},{"1":"glmnet","2":"17.000000"},{"1":"network","2":"17.000000"},{"1":"Rdpack","2":"17.000000"},{"1":"msm","2":"16.793103"},{"1":"GA","2":"16.590909"},{"1":"vars","2":"16.280000"},{"1":"purrr","2":"16.115385"},{"1":"Matrix","2":"16.000000"},{"1":"car","2":"15.841584"},{"1":"Hmisc","2":"15.644809"},{"1":"cluster","2":"15.310345"},{"1":"xts","2":"15.179245"},{"1":"bit64","2":"15.000000"},{"1":"desc","2":"14.883117"},{"1":"lmerTest","2":"14.754868"},{"1":"vegan","2":"14.648294"},{"1":"rootSolve","2":"14.436364"},{"1":"penalized","2":"14.425000"},{"1":"survey","2":"14.293445"},{"1":"mc2d","2":"13.586207"},{"1":"statnet.common","2":"13.578188"},{"1":"gdata","2":"13.200000"},{"1":"insight","2":"13.023810"},{"1":"assertthat","2":"12.828639"},{"1":"forecast","2":"12.573529"},{"1":"withr","2":"12.283340"},{"1":"processx","2":"12.135539"},{"1":"rlang","2":"12.089451"},{"1":"timeSeries","2":"12.076923"},{"1":"pcaPP","2":"12.000000"},{"1":"stats","2":"12.000000"},{"1":"ergm","2":"11.911069"},{"1":"copula","2":"11.789767"},{"1":"TMB","2":"11.764706"},{"1":"gam","2":"11.705263"},{"1":"speedglm","2":"11.631579"},{"1":"ape","2":"11.454545"},{"1":"checkmate","2":"11.431520"},{"1":"lattice","2":"10.997385"},{"1":"ade4","2":"10.987013"},{"1":"pkgload","2":"10.810631"},{"1":"BBmisc","2":"10.719298"},{"1":"bbmle","2":"10.624913"},{"1":"rms","2":"10.608163"},{"1":"actuar","2":"10.513619"},{"1":"Rmpfr","2":"10.283186"},{"1":"minpack.lm","2":"10.157895"},{"1":"officer","2":"10.000000"},{"1":"splines","2":"10.000000"},{"1":"utils","2":"10.000000"},{"1":"pROC","2":"9.767442"},{"1":"fixest","2":"9.714286"},{"1":"coxme","2":"9.600000"},{"1":"roxygen2","2":"9.119403"},{"1":"ggthemes","2":"9.000000"},{"1":"gnm","2":"9.000000"},{"1":"listenv","2":"9.000000"},{"1":"mapview","2":"9.000000"},{"1":"mitools","2":"9.000000"},{"1":"igraph","2":"8.949907"},{"1":"sets","2":"8.444444"},{"1":"maxLik","2":"8.245902"},{"1":"bnlearn","2":"8.166667"},{"1":"ggplot2","2":"8.001266"},{"1":"permute","2":"7.861635"},{"1":"dfidx","2":"7.363636"},{"1":"rpart.plot","2":"7.291971"},{"1":"_generator","2":"7.000000"},{"1":"A_generator","2":"7.000000"},{"1":"AC_generator","2":"7.000000"},{"1":"AccumulateCallback_generator","2":"7.000000"},{"1":"Adapter_generator","2":"7.000000"},{"1":"Appender_generator","2":"7.000000"},{"1":"AppenderConsole_generator","2":"7.000000"},{"1":"AppWrapper_generator","2":"7.000000"},{"1":"Async_generator","2":"7.000000"},{"1":"AsyncVaried_generator","2":"7.000000"},{"1":"B_generator","2":"7.000000"},{"1":"Bar_generator","2":"7.000000"},{"1":"BC_generator","2":"7.000000"},{"1":"C_generator","2":"7.000000"},{"1":"C1_generator","2":"7.000000"},{"1":"C2_generator","2":"7.000000"},{"1":"C2_inherit_generator","2":"7.000000"},{"1":"C2_override_generator","2":"7.000000"},{"1":"C3_generator","2":"7.000000"},{"1":"C3_inherit_inherit_generator","2":"7.000000"},{"1":"C3_inherit_override_generator","2":"7.000000"},{"1":"C3_override_inherit_generator","2":"7.000000"},{"1":"C3_override_override_generator","2":"7.000000"},{"1":"C4_generator","2":"7.000000"},{"1":"Callbacks_generator","2":"7.000000"},{"1":"caret","2":"7.000000"},{"1":"Cassette_generator","2":"7.000000"},{"1":"CC_generator","2":"7.000000"},{"1":"CheckReporter_generator","2":"7.000000"},{"1":"ChunkCallback_generator","2":"7.000000"},{"1":"ClassSelector_generator","2":"7.000000"},{"1":"ClientValue_generator","2":"7.000000"},{"1":"Cloner_generator","2":"7.000000"},{"1":"CombinedSelector_generator","2":"7.000000"},{"1":"content_type_generator","2":"7.000000"},{"1":"Context_generator","2":"7.000000"},{"1":"ContextBuilder_generator","2":"7.000000"},{"1":"ContinuousRange_generator","2":"7.000000"},{"1":"CountingQueue_generator","2":"7.000000"},{"1":"CrulAdapter_generator","2":"7.000000"},{"1":"CustomCloner_generator","2":"7.000000"},{"1":"DataFrameCallback_generator","2":"7.000000"},{"1":"DataMask_generator","2":"7.000000"},{"1":"DC_generator","2":"7.000000"},{"1":"DebugReporter_generator","2":"7.000000"},{"1":"DefinedHooks_generator","2":"7.000000"},{"1":"Dependents_generator","2":"7.000000"},{"1":"description_generator","2":"7.000000"},{"1":"dir_collection_generator","2":"7.000000"},{"1":"dir_layout_generator","2":"7.000000"},{"1":"dir_master_generator","2":"7.000000"},{"1":"dir_sheet_generator","2":"7.000000"},{"1":"dir_slide_generator","2":"7.000000"},{"1":"DiscreteRange_generator","2":"7.000000"},{"1":"DiskCache_generator","2":"7.000000"},{"1":"docx_part_generator","2":"7.000000"},{"1":"Element_generator","2":"7.000000"},{"1":"EnvHash_generator","2":"7.000000"},{"1":"EOFToken_generator","2":"7.000000"},{"1":"fields","2":"7.000000"},{"1":"FileSystem_generator","2":"7.000000"},{"1":"Filterable_generator","2":"7.000000"},{"1":"GenericTranslator_generator","2":"7.000000"},{"1":"Hash_generator","2":"7.000000"},{"1":"HistoryQueue_generator","2":"7.000000"},{"1":"HoardClient_generator","2":"7.000000"},{"1":"HoardFile_generator","2":"7.000000"},{"1":"Hooks_generator","2":"7.000000"},{"1":"HTTPInteraction_generator","2":"7.000000"},{"1":"HTTPInteractionList_generator","2":"7.000000"},{"1":"HttpLibAdapaterRegistry_generator","2":"7.000000"},{"1":"HttpRequest_generator","2":"7.000000"},{"1":"HttpResponse_generator","2":"7.000000"},{"1":"HttrAdapter_generator","2":"7.000000"},{"1":"InputStream_generator","2":"7.000000"},{"1":"Layout_generator","2":"7.000000"},{"1":"LayoutFormat_generator","2":"7.000000"},{"1":"ListCallback_generator","2":"7.000000"},{"1":"ListReporter_generator","2":"7.000000"},{"1":"LogEvent_generator","2":"7.000000"},{"1":"Logger_generator","2":"7.000000"},{"1":"LoggerRoot_generator","2":"7.000000"},{"1":"Map_generator","2":"7.000000"},{"1":"Matcher_generator","2":"7.000000"},{"1":"MemoryCache_generator","2":"7.000000"},{"1":"MethodPattern_generator","2":"7.000000"},{"1":"MinimalReporter_generator","2":"7.000000"},{"1":"MockableTimerCallbacks_generator","2":"7.000000"},{"1":"MockSession_generator","2":"7.000000"},{"1":"MockShinySession_generator","2":"7.000000"},{"1":"MultiReporter_generator","2":"7.000000"},{"1":"Mutable_generator","2":"7.000000"},{"1":"Node_generator","2":"7.000000"},{"1":"NP_generator","2":"7.000000"},{"1":"NullList_generator","2":"7.000000"},{"1":"Numbers_generator","2":"7.000000"},{"1":"Observable_generator","2":"7.000000"},{"1":"Observer_generator","2":"7.000000"},{"1":"openxml_document_generator","2":"7.000000"},{"1":"Persisters_generator","2":"7.000000"},{"1":"presentation_generator","2":"7.000000"},{"1":"PriorityQueue_generator","2":"7.000000"},{"1":"process_generator","2":"7.000000"},{"1":"progress_bar_generator","2":"7.000000"},{"1":"Progress_generator","2":"7.000000"},{"1":"progressor_generator","2":"7.000000"},{"1":"ProgressReporter_generator","2":"7.000000"},{"1":"Promise_generator","2":"7.000000"},{"1":"Query_generator","2":"7.000000"},{"1":"Queue_generator","2":"7.000000"},{"1":"r_process_generator","2":"7.000000"},{"1":"r_session_generator","2":"7.000000"},{"1":"randomForestSRC","2":"7.000000"},{"1":"Range_generator","2":"7.000000"},{"1":"rcmd_process_generator","2":"7.000000"},{"1":"ReactiveEnvironment_generator","2":"7.000000"},{"1":"ReactiveVal_generator","2":"7.000000"},{"1":"ReactiveValues_generator","2":"7.000000"},{"1":"relationship_generator","2":"7.000000"},{"1":"Reporter_generator","2":"7.000000"},{"1":"Request_generator","2":"7.000000"},{"1":"RequestHandler_generator","2":"7.000000"},{"1":"RequestHandlerHttr_generator","2":"7.000000"},{"1":"RequestIgnorer_generator","2":"7.000000"},{"1":"RequestMatcherRegistry_generator","2":"7.000000"},{"1":"RequestPattern_generator","2":"7.000000"},{"1":"RequestSignature_generator","2":"7.000000"},{"1":"Response_generator","2":"7.000000"},{"1":"RestoreContext_generator","2":"7.000000"},{"1":"RestoreInputSet_generator","2":"7.000000"},{"1":"RoxyTopic_generator","2":"7.000000"},{"1":"RoxyTopics_generator","2":"7.000000"},{"1":"rscript_process_generator","2":"7.000000"},{"1":"Selector_generator","2":"7.000000"},{"1":"Serializers_generator","2":"7.000000"},{"1":"Server_generator","2":"7.000000"},{"1":"SharedData_generator","2":"7.000000"},{"1":"sheet_generator","2":"7.000000"},{"1":"SideEffectChunkCallback_generator","2":"7.000000"},{"1":"SilentReporter_generator","2":"7.000000"},{"1":"Simple_generator","2":"7.000000"},{"1":"slide_generator","2":"7.000000"},{"1":"slide_layout_generator","2":"7.000000"},{"1":"slide_master_generator","2":"7.000000"},{"1":"Stack_generator","2":"7.000000"},{"1":"StopReporter_generator","2":"7.000000"},{"1":"StubbedRequest_generator","2":"7.000000"},{"1":"SummaryReporter_generator","2":"7.000000"},{"1":"taxon_state_generator","2":"7.000000"},{"1":"TeachingDemos","2":"7.000000"},{"1":"TimerCallbacks_generator","2":"7.000000"},{"1":"Token_generator","2":"7.000000"},{"1":"Token2.0_generator","2":"7.000000"},{"1":"TokenStream_generator","2":"7.000000"},{"1":"TopoSort_generator","2":"7.000000"},{"1":"unzip_process_generator","2":"7.000000"},{"1":"UriPattern_generator","2":"7.000000"},{"1":"VCRConfig_generator","2":"7.000000"},{"1":"VcrResponse_generator","2":"7.000000"},{"1":"Vertex_generator","2":"7.000000"},{"1":"WebServer_generator","2":"7.000000"},{"1":"worksheets_generator","2":"7.000000"},{"1":"XPathExpr_generator","2":"7.000000"},{"1":"YAML_generator","2":"7.000000"},{"1":"zip_process_generator","2":"7.000000"},{"1":"ParamHelpers","2":"6.925926"},{"1":"plyr","2":"6.864273"},{"1":"foreach","2":"6.703488"},{"1":"dynlm","2":"6.561576"},{"1":"pander","2":"6.547619"},{"1":"metafor","2":"6.491261"},{"1":"earth","2":"6.449102"},{"1":"recipes","2":"6.411765"},{"1":"rlist","2":"6.410286"},{"1":"quantreg","2":"6.378947"},{"1":"sp","2":"6.100000"},{"1":"base","2":"6.052331"},{"1":"distrEx","2":"6.000000"},{"1":"jsonlite","2":"6.000000"},{"1":"leaflet","2":"6.000000"},{"1":"patchwork","2":"6.000000"},{"1":"ranger","2":"6.000000"},{"1":"Deriv","2":"5.714286"},{"1":"R.oo","2":"5.660332"},{"1":"R_GlobalEnv","2":"5.571125"},{"1":"cli","2":"5.454545"},{"1":"rstanarm","2":"5.440000"},{"1":"geepack","2":"5.436364"},{"1":"arm","2":"5.418182"},{"1":"gplots","2":"5.398844"},{"1":"lazyeval","2":"5.352564"},{"1":"imager","2":"5.328947"},{"1":"vcd","2":"5.268293"},{"1":"R.devices","2":"5.142857"},{"1":"rrcov","2":"5.098655"},{"1":"assertive.base","2":"5.000000"},{"1":"doSNOW","2":"5.000000"},{"1":"survival","2":"4.947279"},{"1":"XML","2":"4.922018"},{"1":"prodlim","2":"4.567568"},{"1":"plm","2":"4.508982"},{"1":"testit","2":"4.506596"},{"1":"testthat","2":"4.191274"},{"1":"MASS","2":"4.046129"},{"1":"cvTools","2":"4.035917"},{"1":"animation","2":"4.000000"},{"1":"backports","2":"4.000000"},{"1":"blme","2":"4.000000"},{"1":"boot","2":"4.000000"},{"1":"brms","2":"4.000000"},{"1":"circular","2":"4.000000"},{"1":"cowplot","2":"4.000000"},{"1":"emdbook","2":"4.000000"},{"1":"evaluate","2":"4.000000"},{"1":"R.cache","2":"4.000000"},{"1":"R.rsp","2":"4.000000"},{"1":"R2HTML","2":"4.000000"},{"1":"RUnit","2":"4.000000"},{"1":"RWeka","2":"4.000000"},{"1":"tidyselect","2":"4.000000"},{"1":"tinytest","2":"4.000000"},{"1":"ff","2":"3.849421"},{"1":"rpart","2":"3.842105"},{"1":"e1071","2":"3.784653"},{"1":"randomForest","2":"3.580000"},{"1":"AER","2":"3.540984"},{"1":"ellipse","2":"3.500000"},{"1":"abind","2":"3.350000"},{"1":"robustbase","2":"3.297852"},{"1":"kernlab","2":"3.277778"},{"1":"gmnl","2":"3.250000"},{"1":"directlabels","2":"3.000000"},{"1":"gridExtra","2":"3.000000"},{"1":"sampleSelection","2":"3.000000"},{"1":"mclust","2":"2.809838"},{"1":"units","2":"2.445783"},{"1":"pls","2":"2.288660"},{"1":"modeltools","2":"2.264286"},{"1":"lavaan","2":"2.256410"},{"1":"betareg","2":"2.106667"},{"1":"partykit","2":"2.026490"},{"1":"adehabitatLT","2":"2.000000"},{"1":"afex","2":"2.000000"},{"1":"censReg","2":"2.000000"},{"1":"cgam","2":"2.000000"},{"1":"crch","2":"2.000000"},{"1":"feisr","2":"2.000000"},{"1":"fGarch","2":"2.000000"},{"1":"gbm","2":"2.000000"},{"1":"gmm","2":"2.000000"},{"1":"gss","2":"2.000000"},{"1":"leaps","2":"2.000000"},{"1":"lmodel2","2":"2.000000"},{"1":"logistf","2":"2.000000"},{"1":"MCMCpack","2":"2.000000"},{"1":"sampling","2":"2.000000"},{"1":"sn","2":"2.000000"},{"1":"spatialreg","2":"2.000000"},{"1":"statmod","2":"2.000000"},{"1":"tram","2":"2.000000"},{"1":"truncreg","2":"2.000000"},{"1":"locfit","2":"1.907455"},{"1":"nnet","2":"1.741935"},{"1":"mlogit","2":"1.525773"},{"1":"gee","2":"1.490196"},{"1":"tables","2":"1.150000"},{"1":"iterators","2":"1.000000"},{"1":"mda","2":"1.000000"},{"1":"multgee","2":"1.000000"},{"1":"NLP","2":"1.000000"},{"1":"optimx","2":"1.000000"},{"1":"plot3D","2":"1.000000"},{"1":"plotly","2":"1.000000"},{"1":"quanteda","2":"1.000000"},{"1":"SparseM","2":"1.000000"},{"1":"tree","2":"1.000000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>If we look at the maxima, the largest ones are in <em>base</em>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(caller_package) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">max_expr_size =</span> <span class="kw">max</span>(expr_expression_length, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(max_expr_size))</span></code></pre></div>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["caller_package"],"name":[1],"type":["chr"],"align":["left"]},{"label":["max_expr_size"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"VGAM","2":"8834"},{"1":"future","2":"2705"},{"1":"copula","2":"809"},{"1":"memoise","2":"768"},{"1":"doRNG","2":"718"},{"1":"estimatr","2":"509"},{"1":"effects","2":"505"},{"1":"np","2":"356"},{"1":"lfe","2":"339"},{"1":"utf8","2":"280"},{"1":"R.utils","2":"252"},{"1":"rprojroot","2":"223"},{"1":"robustbase","2":"206"},{"1":"withr","2":"203"},{"1":"RandomFields","2":"193"},{"1":"Rcpp","2":"185"},{"1":"lmerTest","2":"178"},{"1":"Hmisc","2":"175"},{"1":"lubridate","2":"173"},{"1":"ROCR","2":"159"},{"1":"PBSmapping","2":"157"},{"1":"rms","2":"150"},{"1":"plyr","2":"146"},{"1":"gamlss","2":"144"},{"1":"nlme","2":"140"},{"1":"R.oo","2":"140"},{"1":"shiny","2":"115"},{"1":"PerformanceAnalytics","2":"108"},{"1":"quantmod","2":"108"},{"1":"DiagrammeR","2":"104"},{"1":"gtools","2":"103"},{"1":"flextable","2":"96"},{"1":"spatstat","2":"94"},{"1":"R.methodsS3","2":"93"},{"1":"DescTools","2":"91"},{"1":"svUnit","2":"91"},{"1":"clue","2":"87"},{"1":"rrcov","2":"86"},{"1":"DBI","2":"83"},{"1":"speedglm","2":"83"},{"1":"survey","2":"80"},{"1":"statnet.common","2":"78"},{"1":"lme4","2":"77"},{"1":"data.table","2":"75"},{"1":"bit","2":"73"},{"1":"actuar","2":"70"},{"1":"car","2":"70"},{"1":"pscl","2":"69"},{"1":"vegan","2":"68"},{"1":"gamlss.dist","2":"65"},{"1":"GGally","2":"62"},{"1":"cplm","2":"61"},{"1":"ordinal","2":"61"},{"1":"promises","2":"60"},{"1":"rjson","2":"60"},{"1":"mnormt","2":"59"},{"1":"rstan","2":"59"},{"1":"raster","2":"58"},{"1":"sfsmisc","2":"58"},{"1":"plm","2":"56"},{"1":"sna","2":"56"},{"1":"magrittr","2":"55"},{"1":"distr","2":"54"},{"1":"ergm","2":"53"},{"1":"gam","2":"53"},{"1":"glmmTMB","2":"53"},{"1":"knitr","2":"53"},{"1":"nloptr","2":"53"},{"1":"stopwords","2":"53"},{"1":"dynlm","2":"51"},{"1":"mgcv","2":"51"},{"1":"party","2":"51"},{"1":"strucchange","2":"51"},{"1":"aod","2":"49"},{"1":"emmeans","2":"49"},{"1":"fBasics","2":"49"},{"1":"coin","2":"48"},{"1":"BBmisc","2":"47"},{"1":"gsubfn","2":"47"},{"1":"mlr","2":"47"},{"1":"penalized","2":"47"},{"1":"functional","2":"44"},{"1":"R_GlobalEnv","2":"44"},{"1":"rlang","2":"44"},{"1":"Rfast","2":"42"},{"1":"slam","2":"42"},{"1":"zoo","2":"42"},{"1":"glue","2":"41"},{"1":"changepoint","2":"40"},{"1":"globals","2":"40"},{"1":"igraph","2":"39"},{"1":"irlba","2":"39"},{"1":"modeltools","2":"39"},{"1":"deSolve","2":"38"},{"1":"quantreg","2":"38"},{"1":"roxygen2","2":"38"},{"1":"sets","2":"38"},{"1":"MASS","2":"37"},{"1":"mclust","2":"37"},{"1":"pkgload","2":"37"},{"1":"proto","2":"37"},{"1":"base","2":"36"},{"1":"vars","2":"36"},{"1":"btergm","2":"35"},{"1":"mockery","2":"35"},{"1":"rsm","2":"34"},{"1":"hexbin","2":"33"},{"1":"ade4","2":"32"},{"1":"future.apply","2":"31"},{"1":"pbapply","2":"30"},{"1":"vcr","2":"30"},{"1":"dismo","2":"29"},{"1":"xts","2":"29"},{"1":"lattice","2":"28"},{"1":"lazyeval","2":"28"},{"1":"magic","2":"28"},{"1":"pryr","2":"28"},{"1":"stars","2":"28"},{"1":"lambda.r","2":"27"},{"1":"latticeExtra","2":"27"},{"1":"mboost","2":"27"},{"1":"mc2d","2":"26"},{"1":"msm","2":"26"},{"1":"checkmate","2":"25"},{"1":"forecast","2":"25"},{"1":"formatR","2":"25"},{"1":"plotrix","2":"25"},{"1":"rJava","2":"25"},{"1":"timeSeries","2":"25"},{"1":"cvTools","2":"23"},{"1":"prodlim","2":"23"},{"1":"sm","2":"23"},{"1":"assertthat","2":"22"},{"1":"bbmle","2":"22"},{"1":"benchr","2":"22"},{"1":"earth","2":"22"},{"1":"flexclust","2":"22"},{"1":"insight","2":"22"},{"1":"multcomp","2":"22"},{"1":"processx","2":"22"},{"1":"reticulate","2":"22"},{"1":"rlist","2":"22"},{"1":"styler","2":"22"},{"1":"testthat","2":"22"},{"1":"tseries","2":"22"},{"1":"usethis","2":"22"},{"1":"cluster","2":"21"},{"1":"GA","2":"21"},{"1":"ltm","2":"21"},{"1":"metafor","2":"21"},{"1":"phangorn","2":"21"},{"1":"DoE.base","2":"20"},{"1":"maps","2":"20"},{"1":"TMB","2":"20"},{"1":"XML","2":"20"},{"1":"e1071","2":"19"},{"1":"factoextra","2":"19"},{"1":"htmltools","2":"19"},{"1":"purrr","2":"19"},{"1":"rgl","2":"19"},{"1":"systemfit","2":"19"},{"1":"arules","2":"18"},{"1":"caret","2":"18"},{"1":"coxme","2":"18"},{"1":"futile.logger","2":"18"},{"1":"gdata","2":"18"},{"1":"gplots","2":"18"},{"1":"pander","2":"18"},{"1":"reshape","2":"18"},{"1":"rmarkdown","2":"18"},{"1":"rootSolve","2":"18"},{"1":"sp","2":"18"},{"1":"survival","2":"18"},{"1":"arm","2":"17"},{"1":"fixest","2":"17"},{"1":"glmnet","2":"17"},{"1":"locfit","2":"17"},{"1":"network","2":"17"},{"1":"Rdpack","2":"17"},{"1":"rstanarm","2":"17"},{"1":"foreach","2":"16"},{"1":"mapview","2":"16"},{"1":"Matrix","2":"16"},{"1":"Rmpfr","2":"16"},{"1":"RWeka","2":"16"},{"1":"units","2":"16"},{"1":"ape","2":"15"},{"1":"bit64","2":"15"},{"1":"desc","2":"15"},{"1":"pROC","2":"15"},{"1":"ff","2":"14"},{"1":"minpack.lm","2":"13"},{"1":"cli","2":"12"},{"1":"ParamHelpers","2":"12"},{"1":"pcaPP","2":"12"},{"1":"pls","2":"12"},{"1":"stats","2":"12"},{"1":"imager","2":"11"},{"1":"maxLik","2":"11"},{"1":"lavaan","2":"10"},{"1":"officer","2":"10"},{"1":"rpart.plot","2":"10"},{"1":"splines","2":"10"},{"1":"utils","2":"10"},{"1":"bnlearn","2":"9"},{"1":"ggplot2","2":"9"},{"1":"ggthemes","2":"9"},{"1":"gnm","2":"9"},{"1":"listenv","2":"9"},{"1":"mitools","2":"9"},{"1":"partykit","2":"9"},{"1":"R.devices","2":"9"},{"1":"blme","2":"8"},{"1":"Deriv","2":"8"},{"1":"dfidx","2":"8"},{"1":"mlogit","2":"8"},{"1":"permute","2":"8"},{"1":"recipes","2":"8"},{"1":"testit","2":"8"},{"1":"_generator","2":"7"},{"1":"A_generator","2":"7"},{"1":"abind","2":"7"},{"1":"AC_generator","2":"7"},{"1":"AccumulateCallback_generator","2":"7"},{"1":"Adapter_generator","2":"7"},{"1":"AER","2":"7"},{"1":"Appender_generator","2":"7"},{"1":"AppenderConsole_generator","2":"7"},{"1":"AppWrapper_generator","2":"7"},{"1":"Async_generator","2":"7"},{"1":"AsyncVaried_generator","2":"7"},{"1":"B_generator","2":"7"},{"1":"Bar_generator","2":"7"},{"1":"BC_generator","2":"7"},{"1":"C_generator","2":"7"},{"1":"C1_generator","2":"7"},{"1":"C2_generator","2":"7"},{"1":"C2_inherit_generator","2":"7"},{"1":"C2_override_generator","2":"7"},{"1":"C3_generator","2":"7"},{"1":"C3_inherit_inherit_generator","2":"7"},{"1":"C3_inherit_override_generator","2":"7"},{"1":"C3_override_inherit_generator","2":"7"},{"1":"C3_override_override_generator","2":"7"},{"1":"C4_generator","2":"7"},{"1":"Callbacks_generator","2":"7"},{"1":"Cassette_generator","2":"7"},{"1":"CC_generator","2":"7"},{"1":"CheckReporter_generator","2":"7"},{"1":"ChunkCallback_generator","2":"7"},{"1":"ClassSelector_generator","2":"7"},{"1":"ClientValue_generator","2":"7"},{"1":"Cloner_generator","2":"7"},{"1":"CombinedSelector_generator","2":"7"},{"1":"content_type_generator","2":"7"},{"1":"Context_generator","2":"7"},{"1":"ContextBuilder_generator","2":"7"},{"1":"ContinuousRange_generator","2":"7"},{"1":"CountingQueue_generator","2":"7"},{"1":"CrulAdapter_generator","2":"7"},{"1":"CustomCloner_generator","2":"7"},{"1":"DataFrameCallback_generator","2":"7"},{"1":"DataMask_generator","2":"7"},{"1":"DC_generator","2":"7"},{"1":"DebugReporter_generator","2":"7"},{"1":"DefinedHooks_generator","2":"7"},{"1":"Dependents_generator","2":"7"},{"1":"description_generator","2":"7"},{"1":"dir_collection_generator","2":"7"},{"1":"dir_layout_generator","2":"7"},{"1":"dir_master_generator","2":"7"},{"1":"dir_sheet_generator","2":"7"},{"1":"dir_slide_generator","2":"7"},{"1":"DiscreteRange_generator","2":"7"},{"1":"DiskCache_generator","2":"7"},{"1":"docx_part_generator","2":"7"},{"1":"Element_generator","2":"7"},{"1":"EnvHash_generator","2":"7"},{"1":"EOFToken_generator","2":"7"},{"1":"fields","2":"7"},{"1":"FileSystem_generator","2":"7"},{"1":"Filterable_generator","2":"7"},{"1":"geepack","2":"7"},{"1":"GenericTranslator_generator","2":"7"},{"1":"Hash_generator","2":"7"},{"1":"HistoryQueue_generator","2":"7"},{"1":"HoardClient_generator","2":"7"},{"1":"HoardFile_generator","2":"7"},{"1":"Hooks_generator","2":"7"},{"1":"HTTPInteraction_generator","2":"7"},{"1":"HTTPInteractionList_generator","2":"7"},{"1":"HttpLibAdapaterRegistry_generator","2":"7"},{"1":"HttpRequest_generator","2":"7"},{"1":"HttpResponse_generator","2":"7"},{"1":"HttrAdapter_generator","2":"7"},{"1":"InputStream_generator","2":"7"},{"1":"Layout_generator","2":"7"},{"1":"LayoutFormat_generator","2":"7"},{"1":"ListCallback_generator","2":"7"},{"1":"ListReporter_generator","2":"7"},{"1":"LogEvent_generator","2":"7"},{"1":"Logger_generator","2":"7"},{"1":"LoggerRoot_generator","2":"7"},{"1":"Map_generator","2":"7"},{"1":"Matcher_generator","2":"7"},{"1":"MemoryCache_generator","2":"7"},{"1":"MethodPattern_generator","2":"7"},{"1":"MinimalReporter_generator","2":"7"},{"1":"MockableTimerCallbacks_generator","2":"7"},{"1":"MockSession_generator","2":"7"},{"1":"MockShinySession_generator","2":"7"},{"1":"MultiReporter_generator","2":"7"},{"1":"Mutable_generator","2":"7"},{"1":"Node_generator","2":"7"},{"1":"NP_generator","2":"7"},{"1":"NullList_generator","2":"7"},{"1":"Numbers_generator","2":"7"},{"1":"Observable_generator","2":"7"},{"1":"Observer_generator","2":"7"},{"1":"openxml_document_generator","2":"7"},{"1":"Persisters_generator","2":"7"},{"1":"presentation_generator","2":"7"},{"1":"PriorityQueue_generator","2":"7"},{"1":"process_generator","2":"7"},{"1":"progress_bar_generator","2":"7"},{"1":"Progress_generator","2":"7"},{"1":"progressor_generator","2":"7"},{"1":"ProgressReporter_generator","2":"7"},{"1":"Promise_generator","2":"7"},{"1":"Query_generator","2":"7"},{"1":"Queue_generator","2":"7"},{"1":"r_process_generator","2":"7"},{"1":"r_session_generator","2":"7"},{"1":"randomForestSRC","2":"7"},{"1":"Range_generator","2":"7"},{"1":"rcmd_process_generator","2":"7"},{"1":"ReactiveEnvironment_generator","2":"7"},{"1":"ReactiveVal_generator","2":"7"},{"1":"ReactiveValues_generator","2":"7"},{"1":"relationship_generator","2":"7"},{"1":"Reporter_generator","2":"7"},{"1":"Request_generator","2":"7"},{"1":"RequestHandler_generator","2":"7"},{"1":"RequestHandlerHttr_generator","2":"7"},{"1":"RequestIgnorer_generator","2":"7"},{"1":"RequestMatcherRegistry_generator","2":"7"},{"1":"RequestPattern_generator","2":"7"},{"1":"RequestSignature_generator","2":"7"},{"1":"Response_generator","2":"7"},{"1":"RestoreContext_generator","2":"7"},{"1":"RestoreInputSet_generator","2":"7"},{"1":"RoxyTopic_generator","2":"7"},{"1":"RoxyTopics_generator","2":"7"},{"1":"rscript_process_generator","2":"7"},{"1":"Selector_generator","2":"7"},{"1":"Serializers_generator","2":"7"},{"1":"Server_generator","2":"7"},{"1":"SharedData_generator","2":"7"},{"1":"sheet_generator","2":"7"},{"1":"SideEffectChunkCallback_generator","2":"7"},{"1":"SilentReporter_generator","2":"7"},{"1":"Simple_generator","2":"7"},{"1":"slide_generator","2":"7"},{"1":"slide_layout_generator","2":"7"},{"1":"slide_master_generator","2":"7"},{"1":"Stack_generator","2":"7"},{"1":"StopReporter_generator","2":"7"},{"1":"StubbedRequest_generator","2":"7"},{"1":"SummaryReporter_generator","2":"7"},{"1":"taxon_state_generator","2":"7"},{"1":"TeachingDemos","2":"7"},{"1":"TimerCallbacks_generator","2":"7"},{"1":"Token_generator","2":"7"},{"1":"Token2.0_generator","2":"7"},{"1":"TokenStream_generator","2":"7"},{"1":"TopoSort_generator","2":"7"},{"1":"unzip_process_generator","2":"7"},{"1":"UriPattern_generator","2":"7"},{"1":"VCRConfig_generator","2":"7"},{"1":"VcrResponse_generator","2":"7"},{"1":"Vertex_generator","2":"7"},{"1":"WebServer_generator","2":"7"},{"1":"worksheets_generator","2":"7"},{"1":"XPathExpr_generator","2":"7"},{"1":"YAML_generator","2":"7"},{"1":"zip_process_generator","2":"7"},{"1":"distrEx","2":"6"},{"1":"ellipse","2":"6"},{"1":"jsonlite","2":"6"},{"1":"kernlab","2":"6"},{"1":"leaflet","2":"6"},{"1":"nnet","2":"6"},{"1":"patchwork","2":"6"},{"1":"randomForest","2":"6"},{"1":"ranger","2":"6"},{"1":"vcd","2":"6"},{"1":"assertive.base","2":"5"},{"1":"doSNOW","2":"5"},{"1":"gmnl","2":"5"},{"1":"animation","2":"4"},{"1":"backports","2":"4"},{"1":"betareg","2":"4"},{"1":"boot","2":"4"},{"1":"brms","2":"4"},{"1":"circular","2":"4"},{"1":"cowplot","2":"4"},{"1":"emdbook","2":"4"},{"1":"evaluate","2":"4"},{"1":"R.cache","2":"4"},{"1":"R.rsp","2":"4"},{"1":"R2HTML","2":"4"},{"1":"rpart","2":"4"},{"1":"RUnit","2":"4"},{"1":"sampleSelection","2":"4"},{"1":"tables","2":"4"},{"1":"tidyselect","2":"4"},{"1":"tinytest","2":"4"},{"1":"directlabels","2":"3"},{"1":"gridExtra","2":"3"},{"1":"adehabitatLT","2":"2"},{"1":"afex","2":"2"},{"1":"censReg","2":"2"},{"1":"cgam","2":"2"},{"1":"crch","2":"2"},{"1":"feisr","2":"2"},{"1":"fGarch","2":"2"},{"1":"gbm","2":"2"},{"1":"gee","2":"2"},{"1":"gmm","2":"2"},{"1":"gss","2":"2"},{"1":"leaps","2":"2"},{"1":"lmodel2","2":"2"},{"1":"logistf","2":"2"},{"1":"MCMCpack","2":"2"},{"1":"sampling","2":"2"},{"1":"sn","2":"2"},{"1":"spatialreg","2":"2"},{"1":"statmod","2":"2"},{"1":"tram","2":"2"},{"1":"truncreg","2":"2"},{"1":"iterators","2":"1"},{"1":"mda","2":"1"},{"1":"multgee","2":"1"},{"1":"NLP","2":"1"},{"1":"optimx","2":"1"},{"1":"plot3D","2":"1"},{"1":"plotly","2":"1"},{"1":"quanteda","2":"1"},{"1":"SparseM","2":"1"},{"1":"tree","2":"1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="amount-of-computations-performed-in-eval" class="section level2">
<h2>Amount of computations performed in <code>eval</code></h2>
</div>
<div id="aliases-of-eval" class="section level2">
<h2>Aliases of <code>eval</code></h2>
</div>
</div>
<div id="a-taxonomy-of-eval" class="section level1">
<h1>A taxonomy of <code>eval</code></h1>
<div id="the-operation-mix" class="section level2">
<h2>The operation mix</h2>
</div>
<div id="scope-environments" class="section level2">
<h2>Scope (environments)</h2>
</div>
<div id="patterns" class="section level2">
<h2>Patterns</h2>
<p>We look at the first argument of <code>eval</code>, the <code>expr</code> argument, after it is resolved. It is the expression to be evaluated. It can be of different types, mainly usual numeric types, vectors, strings, and language types: calls, symbols, promise, bytecode and expressions.</p>
<p><code>bytecode</code> refers to bytecode objects, that are generated by the <code>compile</code>function:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">typeof</span>(compiler<span class="op">::</span><span class="kw">compile</span>(<span class="dv">1</span><span class="op">+</span><span class="dv">1</span>))</span></code></pre></div>
<pre><code>## [1] &quot;bytecode&quot;</code></pre>
<p>Type <code>expression</code> is a sequence of calls and symbols.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a>per_expr_resolved_type &lt;-<span class="st"> </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(expr_resolved_type, <span class="dt">wt =</span> nb_ev_calls)</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a> per_expr_resolved_type <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">per_cent =</span> n <span class="op">/</span><span class="st"> </span>nb_eval_calls <span class="op">*</span><span class="st"> </span><span class="dv">100</span> ) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(n)) <span class="op">%&gt;%</span><span class="st"> </span>knitr<span class="op">::</span><span class="kw">kable</span>()</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">expr_resolved_type</th>
<th align="right">n</th>
<th align="right">per_cent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">ENVSXP</td>
<td align="right">2028660</td>
<td align="right">39.9742813</td>
</tr>
<tr class="even">
<td align="left">LANGSXP</td>
<td align="right">1733742</td>
<td align="right">34.1629896</td>
</tr>
<tr class="odd">
<td align="left">EXPRSXP</td>
<td align="right">503998</td>
<td align="right">9.9311653</td>
</tr>
<tr class="even">
<td align="left">SYMSXP</td>
<td align="right">219542</td>
<td align="right">4.3260249</td>
</tr>
<tr class="odd">
<td align="left">INTSXP</td>
<td align="right">145228</td>
<td align="right">2.8616845</td>
</tr>
<tr class="even">
<td align="left">NILSXP</td>
<td align="right">143627</td>
<td align="right">2.8301372</td>
</tr>
<tr class="odd">
<td align="left">REALSXP</td>
<td align="right">111483</td>
<td align="right">2.1967470</td>
</tr>
<tr class="even">
<td align="left">LGLSXP</td>
<td align="right">71934</td>
<td align="right">1.4174430</td>
</tr>
<tr class="odd">
<td align="left">VECSXP</td>
<td align="right">68093</td>
<td align="right">1.3417570</td>
</tr>
<tr class="even">
<td align="left">STRSXP</td>
<td align="right">38243</td>
<td align="right">0.7535696</td>
</tr>
<tr class="odd">
<td align="left">CLOSXP</td>
<td align="right">4583</td>
<td align="right">0.0903070</td>
</tr>
<tr class="even">
<td align="left">BCODESXP</td>
<td align="right">2694</td>
<td align="right">0.0530847</td>
</tr>
<tr class="odd">
<td align="left">NA</td>
<td align="right">2671</td>
<td align="right">0.0526314</td>
</tr>
<tr class="even">
<td align="left">S4SXP</td>
<td align="right">337</td>
<td align="right">0.0066405</td>
</tr>
<tr class="odd">
<td align="left">BUILTINSXP</td>
<td align="right">51</td>
<td align="right">0.0010049</td>
</tr>
<tr class="even">
<td align="left">EXTPTRSXP</td>
<td align="right">19</td>
<td align="right">0.0003744</td>
</tr>
<tr class="odd">
<td align="left">SPECIALSXP</td>
<td align="right">6</td>
<td align="right">0.0001182</td>
</tr>
<tr class="even">
<td align="left">CPLXSXP</td>
<td align="right">2</td>
<td align="right">0.0000394</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a>per_expr_resolved_type <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="st">  </span><span class="kw">geom_col</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">fct_reorder</span>(expr_resolved_type, n), <span class="dt">y =</span> n)) <span class="op">+</span></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="st">  </span><span class="kw">scale_y_sqrt</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="st">  </span><span class="kw">coord_flip</span>() <span class="op">+</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Calls per type&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;type&quot;</span> ) </span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/unnamed-chunk-7-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>There is a much larger variety of types for the resolved expressions.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a>changed_resolved_evals &lt;-<span class="st"> </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">changed =</span>  <span class="kw">fct_collapse</span>(expr_resolved_type, <span class="dt">lang_types =</span> <span class="kw">c</span>(<span class="st">&quot;LANGSXP&quot;</span>, <span class="st">&quot;EXPRSXP&quot;</span>, <span class="st">&quot;SYMSXP&quot;</span>, <span class="st">&quot;PROMSXP&quot;</span>, <span class="st">&quot;BCODESXP&quot;</span>), <span class="dt">other_level =</span> <span class="st">&quot;other_types&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(changed, <span class="dt">wt =</span> nb_eval_calls) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">per_cent =</span> n <span class="op">/</span><span class="st"> </span>nb_eval_calls <span class="op">*</span><span class="st"> </span><span class="dv">100</span> ) </span></code></pre></div>
<p>We can remove <code>eval</code> and leave there the expression in 100% of the eval calls (i.e. 5074913).</p>
<p>We can do the same analysis as for the non-resolved expressions:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a>expr_resolved_call_arg &lt;-<span class="st"> </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(expr_resolved_type <span class="op">==</span><span class="st"> &quot;LANGSXP&quot;</span>)</span></code></pre></div>
<p>The following top level functions are used:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a>expr_resolved_call_arg <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(expr_resolved_function, <span class="dt">wt=</span>nb_ev_calls) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(n))</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["expr_resolved_function"],"name":[1],"type":["chr"],"align":["left"]},{"label":["n"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"function","2":"332721"},{"1":"c","2":"170140"},{"1":"missing","2":"146110"},{"1":"alist","2":"128552"},{"1":"_fseq","2":"112740"},{"1":"<<-","2":"103085"},{"1":"substitute","2":"86010"},{"1":"force","2":"61344"},{"1":"$","2":"52362"},{"1":"{","2":"45497"},{"1":"~","2":"32385"},{"1":"<-","2":"29357"},{"1":"reset_options","2":"24063"},{"1":"/","2":"22120"},{"1":"npudensbw","2":"17721"},{"1":"list","2":"16092"},{"1":"-","2":"15966"},{"1":"env_bind0","2":"14872"},{"1":"+","2":"13840"},{"1":"exp","2":"13362"},{"1":"[","2":"12355"},{"1":"dplyr::tibble","2":"11804"},{"1":"logLikFunc","2":"11308"},{"1":"model.frame","2":"10625"},{"1":"[[","2":"10110"},{"1":":::","2":"9670"},{"1":"as.integer","2":"9464"},{"1":"stats::model.frame","2":"9439"},{"1":"*","2":"9302"},{"1":"options","2":"9233"},{"1":"is.character","2":"8584"},{"1":"is_string","2":"6220"},{"1":"[.data.frame","2":"5517"},{"1":"emVVV","2":"5045"},{"1":"getOption","2":"4784"},{"1":"sapply","2":"4544"},{"1":"checkFlag","2":"4440"},{"1":"has_no_na","2":"4309"},{"1":"rbeta","2":"4000"},{"1":":","2":"3811"},{"1":"is_flag","2":"3194"},{"1":"plogis","2":"2758"},{"1":"is_integerish_scalar","2":"2716"},{"1":"expression","2":"2643"},{"1":"is_list_of_pollables","2":"2615"},{"1":"length","2":"2531"},{"1":"ltsReg","2":"2500"},{"1":"parse","2":"2492"},{"1":"fun","2":"2479"},{"1":"||","2":"2304"},{"1":"rlang::enquo","2":"2279"},{"1":"mgfexp","2":"2191"},{"1":"SSlogis","2":"2101"},{"1":"ceiling","2":"2038"},{"1":"simVVV","2":"2022"},{"1":"::","2":"2002"},{"1":"stopifnot","2":"1869"},{"1":"gamlss.pb","2":"1726"},{"1":"makeFac","2":"1712"},{"1":"ergm:::InitErgmTerm.edges","2":"1711"},{"1":"objectSize","2":"1680"},{"1":"data.class","2":"1678"},{"1":"dimension","2":"1678"},{"1":"lmrob","2":"1550"},{"1":"min","2":"1544"},{"1":"is_string_or_null","2":"1512"},{"1":"eval","2":"1507"},{"1":"meVVV","2":"1504"},{"1":"dtls","2":"1482"},{"1":"ptls","2":"1482"},{"1":"replicate","2":"1429"},{"1":"is_existing_file","2":"1415"},{"1":"dplyr::tribble","2":"1414"},{"1":"is_path","2":"1413"},{"1":"nrow","2":"1315"},{"1":"pexp","2":"1252"},{"1":"dexp","2":"1247"},{"1":"environment","2":"1236"},{"1":"meE","2":"1212"},{"1":"cbind","2":"1160"},{"1":"^","2":"1150"},{"1":"nlme::nfGroupedData","2":"1137"},{"1":"mle2","2":"1086"},{"1":"is_col","2":"1044"},{"1":"ergm:::InitErgmConstraint..attributes","2":"1022"},{"1":"emXXX","2":"1001"},{"1":"simEEE","2":"1001"},{"1":"ergm:::InitErgmReference.Bernoulli","2":"974"},{"1":".Mpsi","2":"944"},{"1":"ergm:::InitErgmProposal.TNT","2":"943"},{"1":"lme4::lFormula","2":"942"},{"1":"checkNumeric","2":"929"},{"1":"(","2":"892"},{"1":"&","2":"883"},{"1":"ergm:::InitWtErgmTerm.ininterval","2":"864"},{"1":"%%","2":"844"},{"1":"lm","2":"781"},{"1":"checkCount","2":"751"},{"1":"data.frame","2":"742"},{"1":"create_graph","2":"739"},{"1":"paste0","2":"692"},{"1":"ergm:::InitErgmTerm.kstar","2":"689"},{"1":"base::local","2":"683"},{"1":"set_envvar","2":"680"},{"1":"lme4::lmer","2":"663"},{"1":"mget","2":"633"},{"1":"names","2":"615"},{"1":"ergm:::InitWtErgmTerm.transitiveweights","2":"614"},{"1":"ergm:::InitWtErgmTerm.cyclicalweights","2":"612"},{"1":"==","2":"591"},{"1":"!","2":"553"},{"1":"is_count","2":"543"},{"1":"try","2":"531"},{"1":"meVEV","2":"512"},{"1":"meVVI","2":"506"},{"1":"meEEE","2":"504"},{"1":"find.inst","2":"500"},{"1":"meVII","2":"493"},{"1":"meEII","2":"488"},{"1":"asymptotic","2":"486"},{"1":"meEEI","2":"486"},{"1":"meEVI","2":"481"},{"1":"meEEV","2":"480"},{"1":"meVEI","2":"479"},{"1":"checkClass","2":"470"},{"1":"fitted","2":"463"},{"1":"is.list","2":"454"},{"1":"glue::glue","2":"449"},{"1":"mvnXXX","2":"448"},{"1":"meEVE","2":"442"},{"1":"meVVE","2":"422"},{"1":"ergm:::InitErgmTerm.dgwdsp","2":"417"},{"1":"ergm:::InitErgmTerm.dgwesp","2":"417"},{"1":"ergm:::InitErgmTerm.dgwnsp","2":"417"},{"1":"meVEE","2":"415"},{"1":"meEVV","2":"414"},{"1":"summaryMclustBIC","2":"410"},{"1":"slot<-","2":"396"},{"1":"expect_equal","2":"370"},{"1":"gamlss.cs","2":"368"},{"1":"is_connection_list","2":"342"},{"1":"is_named","2":"342"},{"1":"lmer","2":"338"},{"1":"ergm:::InitErgmTerm.degree","2":"337"},{"1":">","2":"320"},{"1":"s.vam","2":"313"},{"1":"seq_len","2":"304"},{"1":"ergm:::InitErgmTerm.absdiff","2":"284"},{"1":"availableCores","2":"277"},{"1":"ergm:::InitErgmTerm.triangle","2":"272"},{"1":"unlockBinding","2":"265"},{"1":"checkList","2":"255"},{"1":"ERRVL","2":"254"},{"1":"lapply","2":"246"},{"1":"VBlogist","2":"243"},{"1":"order","2":"242"},{"1":"character","2":"241"},{"1":"is.flag","2":"231"},{"1":"mvnXXI","2":"227"},{"1":"paste","2":"226"},{"1":"object.size","2":"223"},{"1":"pgamma","2":"219"},{"1":"body","2":"218"},{"1":"print","2":"218"},{"1":"ergm:::InitErgmTerm.esp","2":"213"},{"1":"<=","2":"211"},{"1":"is_deps_df","2":"210"},{"1":"meV","2":"210"},{"1":".Mchi","2":"208"},{"1":"dplyr::as_tibble","2":"208"},{"1":"ergm:::InitErgmTerm.nodecov","2":"208"},{"1":"str","2":"207"},{"1":"as.character","2":"202"},{"1":"glm","2":"192"},{"1":"ergm:::InitErgmTerm.nodematch","2":"191"},{"1":"checkChoice","2":"187"},{"1":"plm","2":"187"},{"1":"attr","2":"183"},{"1":"mean","2":"183"},{"1":"is_time_interval","2":"180"},{"1":"maxNRCompute","2":"172"},{"1":"getMlrOption","2":"168"},{"1":"RS","2":"168"},{"1":"%<-%","2":"167"},{"1":"channels","2":"167"},{"1":"intersect","2":"158"},{"1":"as.name","2":"155"},{"1":"tibble","2":"152"},{"1":"function (formula, data, subset, weights, na.action, method = \"MM\", model = TRUE, x = !control$compute.rd, y = FALSE, singular.ok = TRUE, \\n    contrasts = NULL, offset = NULL, control = NULL, init = NULL, ...) \\n{\\n    if (miss.ctrl <- missing(control)) \\n        control <- if (missing(method)) \\n            lmrob.control(...)\\n        else lmrob.control(method = method, ...)\\n    else if (length(list(...))) \\n        warning(\"arguments .. in \", sub(\")$\", \"\", sub(\"^list\\\\\\\\(\", \"\", deparse(list(...), control = c()))), \"  are disregarded.\\\\n\", \\n            \"  Maybe use  lmrob(*, control=lmrob.control(....) with all these.\")\\n    ret.x <- x\\n    ret.y <- y\\n    cl <- match.call()\\n    mf <- match.call(expand.dots = FALSE)\\n    m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\", \"offset\"), names(mf), 0)\\n    mf <- mf[c(1, m)]\\n    mf$drop.unused.levels <- TRUE\\n    mf[[1]] <- as.name(\"model.frame\")\\n    mf <- eval(mf, parent.frame())\\n    mt <- attr(mf, \"terms\")\\n    y <- model.response(mf, \"numeric\")\\n    w <- as.vector(model.weights(mf))\\n    if (!is.null(w) && !is.numeric(w)) \\n        stop(\"'weights' must be a numeric vector\")\\n    offset <- as.vector(model.offset(mf))\\n    if (!is.null(offset) && length(offset) != NROW(y)) \\n        stop(gettextf(\"number of offsets is %d, should equal %d (number of observations)\", length(offset), NROW(y)), domain = NA)\\n    if (!miss.ctrl && !missing(method) && method != control$method) {\\n        warning(\"The 'method' argument is different from 'control$method'\\\\n\", \"Using the former, method = \", method)\\n        control$method <- method\\n    }\\n    if (is.empty.model(mt)) {\\n        x <- NULL\\n        singular.fit <- FALSE\\n        z <- list(coefficients = if (is.matrix(y)) matrix(NA_real_, 0, ncol(y)) else numeric(), residuals = y, scale = NA, \\n            fitted.values = 0 * y, cov = matrix(NA_real_, 0, 0), weights = w, rank = 0, df.residual = if (!is.null(w)) sum(w != \\n                0) else NROW(y), converged = TRUE, iter = 0)\\n        if (!is.null(offset)) {\\n            z$fitted.values <- offset\\n            z$residuals <- y - offset\\n            z$offset <- offset\\n        }\\n    }\\n    else {\\n        x <- model.matrix(mt, mf, contrasts)\\n        contrasts <- attr(x, \"contrasts\")\\n        assign <- attr(x, \"assign\")\\n        p <- ncol(x)\\n        if (!is.null(offset)) \\n            y <- y - offset\\n        if (!is.null(w)) {\\n            ny <- NCOL(y)\\n            n <- nrow(x)\\n            if (NROW(y) != n | length(w) != n) \\n                stop(\"incompatible dimensions\")\\n            if (any(w < 0 | is.na(w))) \\n                stop(\"missing or negative weights not allowed\")\\n            zero.weights <- any(w == 0)\\n            if (zero.weights) {\\n                save.r <- y\\n                save.w <- w\\n                save.f <- y\\n                ok <- w != 0\\n                nok <- !ok\\n                w <- w[ok]\\n                x0 <- x[nok, , drop = FALSE]\\n                x <- x[ok, , drop = FALSE]\\n                n <- nrow(x)\\n                y0 <- if (ny > 1L) \\n                  y[nok, , drop = FALSE]\\n                else y[nok]\\n                y <- if (ny > 1L) \\n                  y[ok, , drop = FALSE]\\n                else y[ok]\\n                attr(mf, \"zero.weights\") <- which(nok)\\n            }\\n            wts <- sqrt(w)\\n            save.y <- y\\n            x <- wts * x\\n            y <- wts * y\\n        }\\n        if (getRversion() >= \"3.1.0\") {\\n            z0 <- .lm.fit(x, y, tol = control$solve.tol)\\n            piv <- z0$pivot\\n        }\\n        else {\\n            z0 <- lm.fit(x, y, tol = control$solve.tol)\\n            piv <- z0$qr$pivot\\n        }\\n        rankQR <- z0$rank\\n        singular.fit <- rankQR < p\\n        if (rankQR > 0) {\\n            if (singular.fit) {\\n                if (!singular.ok) \\n                  stop(\"singular fit encountered\")\\n                pivot <- piv\\n                p1 <- pivot[seq_len(rankQR)]\\n                p2 <- pivot[(rankQR + 1):p]\\n                dn <- dimnames(x)\\n                x <- x[, p1]\\n                attr(x, \"assign\") <- assign[p1]\\n            }\\n            if (is.function(control$eps.x)) \\n                control$eps.x <- control$eps.x(max(abs(x)))\\n            if (!is.null(ini <- init)) {\\n                if (is.character(init)) {\\n                  init <- switch(init, `M-S` = lmrob.M.S(x, y, control, mf = mf), S = lmrob.S(x, y, control), stop(\"init must be \\\\\"S\\\\\", \\\\\"M-S\\\\\", function or list\"))\\n                  if (ini == \"M-S\") {\\n                    ini <- init$control$method\\n                  }\\n                }\\n                else if (is.function(init)) {\\n                  init <- init(x = x, y = y, control = control, mf = mf)\\n                }\\n                else if (is.list(init)) {\\n                  if (singular.fit) {\\n                    init$coef <- na.omit(init$coef)\\n                    if (length(init$coef) != ncol(x)) \\n                      stop(\"Length of initial coefficients vector does not match rank of singular design matrix x\")\\n                  }\\n                }\\n                else stop(\"unknown init argument\")\\n                stopifnot(is.numeric(init$coef), is.numeric(init$scale))\\n                if (control$method == \"MM\" || substr(control$method, 1, 1) == \"S\") \\n                  control$method <- substring(control$method, 2)\\n                if (class(init)[1] != \"lmrob.S\" && control$cov == \".vcov.avar1\") \\n                  control$cov <- \".vcov.w\"\\n            }\\n            z <- lmrob.fit(x, y, control, init = init)\\n            if (is.character(ini) && !grepl(paste0(\"^\", ini), control$method)) \\n                control$method <- paste0(ini, control$method)\\n            if (singular.fit) {\\n                coef <- numeric(p)\\n                coef[p2] <- NA\\n                coef[p1] <- z$coefficients\\n                names(coef) <- dn[[2L]]\\n                z$coefficients <- coef\\n                d.p <- p - rankQR\\n                n <- NROW(y)\\n                z$qr[c(\"qr\", \"qraux\", \"pivot\")] <- list(matrix(c(z$qr$qr, rep.int(0, d.p * n)), n, p, dimnames = list(dn[[1L]], \\n                  dn[[2L]][piv])), c(z$qr$qraux, rep.int(0, d.p)), piv)\\n            }\\n        }\\n        else {\\n            z <- list(coefficients = if (is.matrix(y)) matrix(NA_real_, p, ncol(y)) else rep.int(NA_real_, p), residuals = y, \\n                scale = NA, fitted.values = 0 * y, cov = matrix(NA_real_, 0, 0), rweights = rep.int(NA_real_, NROW(y)), weights = w, \\n                rank = 0, df.residual = NROW(y), converged = TRUE, iter = 0, control = control)\\n            if (is.matrix(y)) \\n                colnames(z$coefficients) <- colnames(x)\\n            else names(z$coefficients) <- colnames(x)\\n            if (!is.null(offset)) \\n                z$residuals <- y - offset\\n        }\\n        if (!is.null(w)) {\\n            z$residuals <- z$residuals/wts\\n            z$fitted.values <- save.y - z$residuals\\n            z$weights <- w\\n            if (zero.weights) {\\n                coef <- z$coefficients\\n                coef[is.na(coef)] <- 0\\n                f0 <- x0 %*% coef\\n                if (ny > 1) {\\n                  save.r[ok, ] <- z$residuals\\n                  save.r[nok, ] <- y0 - f0\\n                  save.f[ok, ] <- z$fitted.values\\n                  save.f[nok, ] <- f0\\n                }\\n                else {\\n                  save.r[ok] <- z$residuals\\n                  save.r[nok] <- y0 - f0\\n                  save.f[ok] <- z$fitted.values\\n                  save.f[nok] <- f0\\n                }\\n                z$residuals <- save.r\\n                z$fitted.values <- save.f\\n                z$weights <- save.w\\n                rw <- z$rweights\\n                z$rweights <- rep.int(0, length(save.w))\\n                z$rweights[ok] <- rw\\n            }\\n        }\\n    }\\n    if (!is.null(offset)) \\n        z$fitted.values <- z$fitted.values + offset\\n    z$na.action <- attr(mf, \"na.action\")\\n    z$offset <- offset\\n    z$contrasts <- contrasts\\n    z$xlevels <- .getXlevels(mt, mf)\\n    z$call <- cl\\n    z$terms <- mt\\n    z$assign <- assign\\n    if (control$compute.rd && !is.null(x)) \\n        z$MD <- robMD(x, attr(mt, \"intercept\"), wqr = z$qr)\\n    if (model) \\n        z$model <- mf\\n    if (ret.x) \\n        z$x <- if (singular.fit || (!is.null(w) && zero.weights)) \\n            model.matrix(mt, mf, contrasts)\\n        else x\\n    if (ret.y) \\n        z$y <- if (!is.null(w)) \\n            model.response(mf, \"numeric\")\\n        else y\\n    class(z) <- \"lmrob\"\\n    z\\n}","2":"150"},{"1":"hcVVV","2":"145"},{"1":"lme4::glFormula","2":"140"},{"1":"dl.summarize","2":"136"},{"1":"expect_true","2":"133"},{"1":"qBCT","2":"133"},{"1":"ppm","2":"132"},{"1":"exact","2":"131"},{"1":"expect_error","2":"131"},{"1":">=","2":"128"},{"1":"ergm:::InitErgmTerm..edges_times","2":"128"},{"1":"dplyr::left_join","2":"122"},{"1":"lattice::bwplot","2":"122"},{"1":"%>%","2":"121"},{"1":"array","2":"121"},{"1":"glmer","2":"121"},{"1":"logLikGrad","2":"118"},{"1":"rep","2":"117"},{"1":"is_collate_field","2":"115"},{"1":"mvnXII","2":"115"},{"1":"visNetwork","2":"113"},{"1":"toPaletteFunc","2":"111"},{"1":".parse_font","2":"110"},{"1":"locfit","2":"109"},{"1":"expect_that","2":"104"},{"1":"is_padding_or_margin","2":"104"},{"1":"tools::Rd2HTML","2":"103"},{"1":"ergm:::InitErgmTerm.nodefactor","2":"101"},{"1":"factor","2":"101"},{"1":"%in%","2":"99"},{"1":"=","2":"99"},{"1":"dynformula","2":"99"},{"1":"object","2":"99"},{"1":"%lazy%","2":"98"},{"1":"%stdout%","2":"98"},{"1":"cli_end","2":"98"},{"1":"map","2":"98"},{"1":"dgamma","2":"97"},{"1":"sum","2":"96"},{"1":"is.logical","2":"92"},{"1":"<","2":"90"},{"1":"utils::methods","2":"89"},{"1":"is_connection","2":"86"},{"1":"rev","2":"86"},{"1":"ergm:::InitWtErgmTerm.equalto","2":"84"},{"1":"rowidv","2":"84"},{"1":"partykit::extree_data","2":"83"},{"1":"expect_equivalent","2":"82"},{"1":"xtabs","2":"82"},{"1":"as.cimg","2":"79"},{"1":"recipe","2":"79"},{"1":"do.call","2":"78"},{"1":"polr","2":"78"},{"1":"is_package_version","2":"77"},{"1":"cons$fun","2":"76"},{"1":"cdensEEE","2":"75"},{"1":"dplyr::inner_join","2":"74"},{"1":"lnl.slogit","2":"71"},{"1":"s.wam","2":"71"},{"1":"%E>%","2":"70"},{"1":"all","2":"68"},{"1":"gamlss","2":"68"},{"1":"checkIntegerish","2":"67"},{"1":"mclustBIC","2":"67"},{"1":"rbind","2":"65"},{"1":"function (roc, method = c(\"binormal\", \"density\", \"fitdistr\", \"logcondens\", \"logcondens.smooth\"), n = 512, bw = \"nrd0\", density = NULL, \\n    density.controls = density, density.cases = density, start = NULL, start.controls = start, start.cases = start, reuse.auc = TRUE, \\n    reuse.ci = FALSE, ...) \\n{\\n    method <- match.arg(method)\\n    if (is.ordered(roc$original.predictor) && (method == \"density\" || method == \"fitidstr\")) \\n        stop(\"ROC curves of ordered predictors can be smoothed only with binormal smoothing.\")\\n    if (mode(method) == \"function\") {\\n        sesp <- method(roc = roc, n = n, bw = bw, density = density, density.controls = density.controls, density.cases = density.cases, \\n            start.controls = start.controls, start.cases = start.cases, ...)\\n        if (mode(sesp) != \"list\" || !identical(sort(names(sesp)), c(\"sensitivities\", \"specificities\"))) \\n            stop(\"'method' function did not return a list with two elements named 'sensitivities' and 'specificities'.\")\\n        if (length(sesp$sensitivities) != length(sesp$specificities)) \\n            stop(\"'method' function did return a list with two elements of different length.\")\\n        if (!is.numeric(sesp$specificities) || !is.numeric(sesp$sensitivities)) \\n            stop(\"'method' function did not return a list of numeric vectors.\")\\n        if (any(c(sesp$specificities, sesp$sensitivities) < 0) || any(c(sesp$specificities, sesp$sensitivities) > ifelse(roc$percent, \\n            100, 1))) \\n            stop(\"'method' function returned vector with invalid values (< 0 or > 1 or 100).\")\\n    }\\n    else {\\n        if (method == \"binormal\") \\n            sesp <- smooth.roc.binormal(roc, n)\\n        if (method == \"fitdistr\") \\n            sesp <- smooth.roc.fitdistr(roc, n, density.controls, density.cases, start.controls, start.cases, ...)\\n        if (method == \"density\") \\n            sesp <- smooth.roc.density(roc, n, density.controls, density.cases, bw, ...)\\n        if (method == \"logcondens\") \\n            sesp <- smooth.roc.logcondens(roc, n)\\n        if (method == \"logcondens.smooth\") \\n            sesp <- smooth.roc.logcondens.smooth(roc, n)\\n    }\\n    class(sesp) <- \"smooth.roc\"\\n    sesp <- sort(sesp)\\n    sesp$specificities <- c(0, as.vector(sesp$specificities), ifelse(roc$percent, 100, 1))\\n    sesp$sensitivities <- c(ifelse(roc$percent, 100, 1), as.vector(sesp$sensitivities), 0)\\n    attr(sesp, \"roc\") <- roc\\n    sesp$percent <- roc$percent\\n    sesp$direction <- roc$direction\\n    sesp$call <- match.call()\\n    sesp$smoothing.args <- list(...)\\n    sesp$smoothing.args$method <- method\\n    sesp$smoothing.args$n <- n\\n    sesp$smoothing.args$start.controls <- start.controls\\n    sesp$smoothing.args$start.cases <- start.cases\\n    sesp$smoothing.args$density.controls <- density.controls\\n    sesp$smoothing.args$density.cases <- density.cases\\n    sesp$smoothing.args$bw <- bw\\n    if (method == \"fitdistr\") {\\n        if (is.null(sesp$fit.controls$densfun)) {\\n            if (missing(density.controls)) \\n                sesp$fit.controls$densfun <- deparse(substitute(density))\\n            else sesp$fit.controls$densfun <- deparse(substitute(density.controls))\\n        }\\n        if (is.null(sesp$fit.cases$densfun)) {\\n            if (missing(density.cases)) \\n                sesp$fit.cases$densfun <- deparse(substitute(density))\\n            else sesp$fit.cases$densfun <- deparse(substitute(density.cases))\\n        }\\n    }\\n    if (!is.null(roc$auc) && reuse.auc) {\\n        args <- attributes(roc$auc)\\n        args$roc <- NULL\\n        args$smooth.roc <- sesp\\n        sesp$auc <- do.call(\"auc.smooth.roc\", args)\\n    }\\n    if (!is.null(roc$ci) && reuse.ci) {\\n        args <- attributes(roc$ci)\\n        args$roc <- NULL\\n        args$smooth.roc <- sesp\\n        sesp$ci <- do.call(paste(class(roc$ci), \"smooth.roc\", sep = \".\"), args)\\n    }\\n    return(sesp)\\n}","2":"64"},{"1":"ifelse","2":"64"},{"1":"ergm:::InitErgmTerm.gwesp","2":"63"},{"1":"invokeMethod","2":"63"},{"1":"funique","2":"62"},{"1":"switch","2":"60"},{"1":"confint","2":"59"},{"1":"identical","2":"59"},{"1":"xyplot","2":"59"},{"1":"checkCharacter","2":"58"},{"1":"ergm:::InitErgmTerm.odegree","2":"58"},{"1":"optim","2":"57"},{"1":"any","2":"56"},{"1":"kable","2":"55"},{"1":"capture_output","2":"54"},{"1":"plot","2":"54"},{"1":"mstep","2":"53"},{"1":"mvnX","2":"53"},{"1":"pls::mvr","2":"53"},{"1":"xts","2":"53"},{"1":"checkString","2":"52"},{"1":"leaflet","2":"52"},{"1":"partykit::mob","2":"52"},{"1":".check_add.params","2":"51"},{"1":"create_notable","2":"51"},{"1":"function (x, centers, iter.max = 10L, nstart = 1L, algorithm = c(\"Hartigan-Wong\", \"Lloyd\", \"Forgy\", \"MacQueen\"), trace = FALSE) \\n{\\n    .Mimax <- .Machine$integer.max\\n    do_one <- function(nmeth) {\\n        switch(nmeth, {\\n            isteps.Qtran <- as.integer(min(.Mimax, 50 * m))\\n            iTran <- c(isteps.Qtran, integer(k))\\n            Z <- .Fortran(C_kmns, x, m, p, centers = centers, as.integer(k), c1 = integer(m), c2 = integer(m), nc = integer(k), \\n                double(k), double(k), ncp = integer(k), D = double(m), iTran = iTran, live = integer(k), iter = iter.max, \\n                wss = double(k), ifault = as.integer(trace))\\n            switch(Z$ifault, stop(\"empty cluster: try a better set of initial centers\", call. = FALSE), Z$iter <- max(Z$iter, \\n                iter.max + 1L), stop(\"number of cluster centres must lie between 1 and nrow(x)\", call. = FALSE), warning(gettextf(\"Quick-TRANSfer stage steps exceeded maximum (= %d)\", \\n                isteps.Qtran), call. = FALSE))\\n        }, {\\n            Z <- .C(C_kmeans_Lloyd, x, m, p, centers = centers, k, c1 = integer(m), iter = iter.max, nc = integer(k), wss = double(k))\\n        }, {\\n            Z <- .C(C_kmeans_MacQueen, x, m, p, centers = as.double(centers), k, c1 = integer(m), iter = iter.max, nc = integer(k), \\n                wss = double(k))\\n        })\\n        if (m23 <- any(nmeth == c(2L, 3L))) {\\n            if (any(Z$nc == 0)) \\n                warning(\"empty cluster: try a better set of initial centers\", call. = FALSE)\\n        }\\n        if (Z$iter > iter.max) {\\n            warning(sprintf(ngettext(iter.max, \"did not converge in %d iteration\", \"did not converge in %d iterations\"), \\n                iter.max), call. = FALSE, domain = NA)\\n            if (m23) \\n                Z$ifault <- 2L\\n        }\\n        if (nmeth %in% c(2L, 3L)) {\\n            if (any(Z$nc == 0)) \\n                warning(\"empty cluster: try a better set of initial centers\", call. = FALSE)\\n        }\\n        Z\\n    }\\n    x <- as.matrix(x)\\n    m <- as.integer(nrow(x))\\n    if (is.na(m)) \\n        stop(\"invalid nrow(x)\")\\n    p <- as.integer(ncol(x))\\n    if (is.na(p)) \\n        stop(\"invalid ncol(x)\")\\n    if (missing(centers)) \\n        stop(\"'centers' must be a number or a matrix\")\\n    nmeth <- switch(match.arg(algorithm), `Hartigan-Wong` = 1L, Lloyd = 2L, Forgy = 2L, MacQueen = 3L)\\n    storage.mode(x) <- \"double\"\\n    if (length(centers) == 1L) {\\n        k <- centers\\n        if (nstart == 1L) \\n            centers <- x[sample.int(m, k), , drop = FALSE]\\n        if (nstart >= 2L || any(duplicated(centers))) {\\n            cn <- unique(x)\\n            mm <- nrow(cn)\\n            if (mm < k) \\n                stop(\"more cluster centers than distinct data points.\")\\n            centers <- cn[sample.int(mm, k), , drop = FALSE]\\n        }\\n    }\\n    else {\\n        centers <- as.matrix(centers)\\n        if (any(duplicated(centers))) \\n            stop(\"initial centers are not distinct\")\\n        cn <- NULL\\n        k <- nrow(centers)\\n        if (m < k) \\n            stop(\"more cluster centers than data points\")\\n    }\\n    k <- as.integer(k)\\n    if (is.na(k)) \\n        stop(gettextf(\"invalid value of %s\", \"'k'\"), domain = NA)\\n    if (k == 1L) \\n        nmeth <- 3L\\n    iter.max <- as.integer(iter.max)\\n    if (is.na(iter.max) || iter.max < 1L) \\n        stop(\"'iter.max' must be positive\")\\n    if (ncol(x) != ncol(centers)) \\n        stop(\"must have same number of columns in 'x' and 'centers'\")\\n    storage.mode(centers) <- \"double\"\\n    Z <- do_one(nmeth)\\n    best <- sum(Z$wss)\\n    if (nstart >= 2L && !is.null(cn)) \\n        for (i in 2:nstart) {\\n            centers <- cn[sample.int(mm, k), , drop = FALSE]\\n            ZZ <- do_one(nmeth)\\n            if ((z <- sum(ZZ$wss)) < best) {\\n                Z <- ZZ\\n                best <- z\\n            }\\n        }\\n    centers <- matrix(Z$centers, k)\\n    dimnames(centers) <- list(1L:k, dimnames(x)[[2L]])\\n    cluster <- Z$c1\\n    if (!is.null(rn <- rownames(x))) \\n        names(cluster) <- rn\\n    totss <- sum(scale(x, scale = FALSE)^2)\\n    structure(list(cluster = cluster, centers = centers, totss = totss, withinss = Z$wss, tot.withinss = best, betweenss = totss - \\n        best, size = Z$nc, iter = Z$iter, ifault = Z$ifault), class = \"kmeans\")\\n}","2":"51"},{"1":"gcv","2":"51"},{"1":"pmax","2":"50"},{"1":"pmin","2":"50"},{"1":"%seed%","2":"48"},{"1":"cdensVEV","2":"48"},{"1":"is_version_component","2":"48"},{"1":"kppm","2":"47"},{"1":"!=","2":"45"},{"1":"expand.grid","2":"45"},{"1":"survival::coxsurv.fit","2":"45"},{"1":"is_border_style","2":"44"},{"1":"list.files","2":"43"},{"1":"rnorm","2":"43"},{"1":"which_","2":"43"},{"1":"as.list","2":"42"},{"1":"lme4::.simulateFun","2":"42"},{"1":"log","2":"42"},{"1":"read_docx","2":"41"},{"1":"SJ","2":"41"},{"1":"vlm","2":"41"},{"1":"strsplit","2":"40"},{"1":"dplyr::bind_rows","2":"39"},{"1":"_f","2":"38"},{"1":".select_vec","2":"38"},{"1":"dygraph","2":"38"},{"1":"lattice::cloud","2":"38"},{"1":"imsplit","2":"37"},{"1":"mstepVVI","2":"37"},{"1":"nlme::lme","2":"37"},{"1":"sqrt","2":"37"},{"1":"with_reporter","2":"37"},{"1":"xml_find_all","2":"37"},{"1":"lavaan::lavaan","2":"36"},{"1":"lme.formula","2":"36"},{"1":"lazy_frame","2":"35"},{"1":"max","2":"35"},{"1":"rhandsontable","2":"35"},{"1":"isoblur","2":"33"},{"1":"range","2":"33"},{"1":"ergm:::InitWtErgmTerm.diff","2":"32"},{"1":"match","2":"32"},{"1":"mstepVEV","2":"32"},{"1":"trans","2":"32"},{"1":"unlist","2":"32"},{"1":"split","2":"31"},{"1":"sub","2":"31"},{"1":"subset","2":"31"},{"1":"approximate","2":"30"},{"1":"Cbind","2":"30"},{"1":"cimg","2":"30"},{"1":"ergm:::InitWtErgmTerm.nodefactor","2":"30"},{"1":"oC","2":"30"},{"1":"as.numeric","2":"29"},{"1":"cdensEVE","2":"29"},{"1":"is.na","2":"29"},{"1":"memdb_frame","2":"29"},{"1":"mstepVVV","2":"29"},{"1":"sort","2":"29"},{"1":"gl","2":"28"},{"1":"map_lgl","2":"28"},{"1":"mstepEEE","2":"28"},{"1":"tokens","2":"28"},{"1":"vec_as_location","2":"28"},{"1":"expect_identical","2":"27"},{"1":"gls","2":"26"},{"1":"gsub","2":"26"},{"1":"pnorm","2":"26"},{"1":"as.matrix","2":"25"},{"1":"formals","2":"25"},{"1":"is_authors","2":"25"},{"1":"plot_ly","2":"25"},{"1":"svymean","2":"25"},{"1":"vapply","2":"25"},{"1":"vec_as_location2","2":"25"},{"1":"checkLogical","2":"24"},{"1":"eval.fv","2":"24"},{"1":"function (formula, data = NULL, subset = NULL, na.action = na.fail, drop.unused.levels = FALSE, xlev = NULL, ...) \\n{\\n    possible_newdata <- !missing(data) && is.data.frame(data) && identical(substitute(data), quote(newdata)) && (nr <- nrow(data)) > \\n        0\\n    if (!missing(formula) && nargs() == 1 && is.list(formula) && !is.null(m <- formula$model)) \\n        return(m)\\n    if (!missing(formula) && nargs() == 1 && is.list(formula) && all(c(\"terms\", \"call\") %in% names(formula))) {\\n        fcall <- formula$call\\n        m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\"), names(fcall), 0)\\n        fcall <- fcall[c(1, m)]\\n        fcall[[1L]] <- quote(stats::model.frame)\\n        env <- environment(formula$terms)\\n        if (is.null(env)) \\n            env <- parent.frame()\\n        return(eval(fcall, env))\\n    }\\n    if (missing(formula)) {\\n        if (!missing(data) && inherits(data, \"data.frame\") && length(attr(data, \"terms\"))) \\n            return(data)\\n        formula <- as.formula(data)\\n    }\\n    else if (missing(data) && inherits(formula, \"data.frame\")) {\\n        if (length(attr(formula, \"terms\"))) \\n            return(formula)\\n        data <- formula\\n        formula <- as.formula(data)\\n    }\\n    else formula <- as.formula(formula)\\n    if (missing(na.action)) {\\n        if (!is.null(naa <- attr(data, \"na.action\")) & mode(naa) != \"numeric\") \\n            na.action <- naa\\n        else if (!is.null(naa <- getOption(\"na.action\"))) \\n            na.action <- naa\\n    }\\n    if (missing(data)) \\n        data <- environment(formula)\\n    else if (!is.data.frame(data) && !is.environment(data) && !is.null(attr(data, \"class\"))) \\n        data <- as.data.frame(data)\\n    else if (is.array(data)) \\n        stop(\"'data' must be a data.frame, not a matrix or an array\")\\n    if (!inherits(formula, \"terms\")) \\n        formula <- terms(formula, data = data)\\n    env <- environment(formula)\\n    rownames <- .row_names_info(data, 0L)\\n    vars <- attr(formula, \"variables\")\\n    predvars <- attr(formula, \"predvars\")\\n    if (is.null(predvars)) \\n        predvars <- vars\\n    varnames <- vapply(vars, deparse2, \" \")[-1L]\\n    variables <- eval(predvars, data, env)\\n    resp <- attr(formula, \"response\")\\n    if (is.null(rownames) && resp > 0L) {\\n        lhs <- variables[[resp]]\\n        rownames <- if (is.matrix(lhs)) \\n            rownames(lhs)\\n        else names(lhs)\\n    }\\n    if (possible_newdata && length(variables)) {\\n        nr2 <- max(sapply(variables, NROW))\\n        if (nr2 != nr) \\n            warning(sprintf(paste0(ngettext(nr, \"'newdata' had %d row\", \"'newdata' had %d rows\"), \" \", ngettext(nr2, \"but variable found had %d row\", \\n                \"but variables found have %d rows\")), nr, nr2), call. = FALSE, domain = NA)\\n    }\\n    if (is.null(attr(formula, \"predvars\"))) {\\n        for (i in seq_along(varnames)) predvars[[i + 1L]] <- makepredictcall(variables[[i]], vars[[i + 1L]])\\n        attr(formula, \"predvars\") <- predvars\\n    }\\n    extras <- substitute(list(...))\\n    extranames <- names(extras[-1L])\\n    extras <- eval(extras, data, env)\\n    subset <- eval(substitute(subset), data, env)\\n    data <- .External2(C_modelframe, formula, rownames, variables, varnames, extras, extranames, subset, na.action)\\n    if (length(xlev)) {\\n        for (nm in names(xlev)) if (!is.null(xl <- xlev[[nm]])) {\\n            xi <- data[[nm]]\\n            if (is.character(xi)) \\n                xi <- as.factor(xi)\\n            if (!is.factor(xi) || is.null(nxl <- levels(xi))) \\n                warning(gettextf(\"variable '%s' is not a factor\", nm), domain = NA)\\n            else {\\n                ctr <- attr(xi, \"contrasts\")\\n                xi <- xi[, drop = TRUE]\\n                nxl <- levels(xi)\\n                if (any(m <- is.na(match(nxl, xl)))) \\n                  stop(sprintf(ngettext(length(m), \"factor %s has new level %s\", \"factor %s has new levels %s\"), nm, paste(nxl[m], \\n                    collapse = \", \")), domain = NA)\\n                data[[nm]] <- factor(xi, levels = xl, exclude = NULL)\\n                if (!identical(attr(data[[nm]], \"contrasts\"), ctr)) \\n                  warning(gettext(sprintf(\"contrasts dropped from factor %s\", nm), domain = NA), call. = FALSE)\\n            }\\n        }\\n    }\\n    else if (drop.unused.levels) {\\n        for (nm in names(data)) {\\n            x <- data[[nm]]\\n            if (is.factor(x) && length(unique(x[!is.na(x)])) < length(levels(x))) {\\n                ctr <- attr(x, \"contrasts\")\\n                data[[nm]] <- x[, drop = TRUE]\\n                if (!identical(attr(data[[nm]], \"contrasts\"), ctr)) \\n                  warning(gettext(sprintf(\"contrasts dropped from factor %s due to missing levels\", nm), domain = NA), call. = FALSE)\\n            }\\n        }\\n    }\\n    attr(formula, \"dataClasses\") <- vapply(data, .MFclass, \"\")\\n    attr(data, \"terms\") <- formula\\n    data\\n}","2":"24"},{"1":"setdiff","2":"24"},{"1":"unique","2":"24"},{"1":"assign","2":"23"},{"1":"function (y, x, strata, weights, ymin = NULL, ymax = NULL, timewt = c(\"n\", \"S\", \"S/G\", \"n/G\", \"n/G2\", \"I\"), cluster, influence = 0, \\n    ranks = FALSE, reverse = FALSE, timefix = TRUE, keepstrata = 10) \\n{\\n    if (any(is.na(x)) || any(is.na(y))) \\n        return(NULL)\\n    timewt <- match.arg(timewt)\\n    if (!is.Surv(y)) {\\n        if (is.factor(y) && (is.ordered(y) || length(levels(y)) == 2)) \\n            y <- Surv(as.numeric(y))\\n        else if (is.numeric(y) && is.vector(y)) \\n            y <- Surv(y)\\n        else stop(\"left hand side of the formula must be a numeric vector,\\\\n survival object, or an orderable factor\")\\n        if (timefix) \\n            y <- aeqSurv(y)\\n    }\\n    n <- length(y)\\n    if (length(x) != n) \\n        stop(\"x and y are not the same length\")\\n    if (missing(strata) || length(strata) == 0) \\n        strata <- rep(1L, n)\\n    if (length(strata) != n) \\n        stop(\"y and strata are not the same length\")\\n    if (missing(weights) || length(weights) == 0) \\n        weights <- rep(1, n)\\n    else if (length(weights) != n) \\n        stop(\"y and weights are not the same length\")\\n    type <- attr(y, \"type\")\\n    if (type %in% c(\"left\", \"interval\")) \\n        stop(\"left or interval censored data is not supported\")\\n    if (type %in% c(\"mright\", \"mcounting\")) \\n        stop(\"multiple state survival is not supported\")\\n    nstrat <- length(unique(strata))\\n    if (!is.logical(keepstrata)) {\\n        if (!is.numeric(keepstrata)) \\n            stop(\"keepstrat argument must be logical or numeric\")\\n        else keepstrata <- (nstrat <= keepstrata)\\n    }\\n    if (timewt %in% c(\"n\", \"I\") && nstrat > 10 && !keepstrata) {\\n        stemp <- as.numeric(as.factor(strata)) - 1\\n        if (ncol(y) == 3) {\\n            delta <- 2 + max(y[, 2]) - min(y[, 1])\\n            y[, 1] <- y[, 1] + stemp * delta\\n            y[, 2] <- y[, 2] + stemp * delta\\n        }\\n        else {\\n            delta <- max(y[, 1]) + 2\\n            m1 <- rep(-1L, nrow(y))\\n            y <- Surv(m1 + stemp * delta, y[, 1] + stemp * delta, y[, 2])\\n        }\\n        strata <- rep(1L, n)\\n        nstrat <- 1\\n    }\\n    docount <- function(y, risk, wts, timeopt = \"n\", timefix) {\\n        n <- length(risk)\\n        if (sum(y[, ncol(y)]) < 2) \\n            timeopt <- \"n\"\\n        sfit <- survfit(y ~ 1, weights = wts, se.fit = FALSE, timefix = timefix)\\n        etime <- sfit$time[sfit$n.event > 0]\\n        esurv <- sfit$surv[sfit$n.event > 0]\\n        if (length(etime) == 0) {\\n            return(list(count = rep(0, 6), influence = matrix(0, n, 5), resid = NULL))\\n        }\\n        if (timeopt %in% c(\"S/G\", \"n/G\", \"n/G2\")) {\\n            temp <- y\\n            temp[, ncol(temp)] <- 1 - temp[, ncol(temp)]\\n            gfit <- survfit(temp ~ 1, weights = wts, se.fit = FALSE, timefix = timefix)\\n            gsurv <- c(1, gfit$surv)\\n            gsurv <- gsurv[which(sfit$n.event > 0)]\\n        }\\n        npair <- (sfit$n.risk - sfit$n.event)[sfit$n.event > 0]\\n        temp <- ifelse(esurv == 0, 0, esurv/npair)\\n        timewt <- switch(timeopt, S = sum(wts) * temp, `S/G` = sum(wts) * temp/gsurv, n = rep(1, length(npair)), `n/G` = 1/gsurv, \\n            `n/G2` = 1/gsurv^2, I = rep(1, length(esurv)))\\n        if (!is.null(ymin)) \\n            timewt[etime < ymin] <- 0\\n        if (!is.null(ymax)) \\n            timewt[etime > ymax] <- 0\\n        timewt <- ifelse(is.finite(timewt), timewt, 0)\\n        if (ncol(y) == 2) {\\n            sort.stop <- order(-y[, 1], y[, 2], risk) - 1L\\n        }\\n        else {\\n            sort.stop <- order(-y[, 2], y[, 3], risk) - 1L\\n            sort.start <- order(-y[, 1]) - 1L\\n        }\\n        utemp <- match(risk, sort(unique(risk)))\\n        bindex <- btree(max(utemp))[utemp]\\n        storage.mode(y) <- \"double\"\\n        storage.mode(wts) <- \"double\"\\n        if (ncol(y) == 2) \\n            fit <- .Call(Cconcordance3, y, bindex, wts, rev(timewt), sort.stop, ranks)\\n        else fit <- .Call(Cconcordance4, y, bindex, wts, rev(timewt), sort.start, sort.stop, ranks)\\n        dimnames(fit$influence) <- list(NULL, c(\"concordant\", \"discordant\", \"tied.x\", \"tied.y\", \"tied.xy\"))\\n        if (ranks) {\\n            if (ncol(y) == 2) \\n                dtime <- y[y[, 2] == 1, 1]\\n            else dtime <- y[y[, 3] == 1, 2]\\n            temp <- data.frame(time = sort(dtime), fit$resid)\\n            names(temp) <- c(\"time\", \"rank\", \"timewt\", \"casewt\", \"variance\")\\n            fit$resid <- temp[temp[, 3] > 0, ]\\n        }\\n        fit\\n    }\\n    if (nstrat < 2) {\\n        fit <- docount(y, x, weights, timewt, timefix = timefix)\\n        count2 <- fit$count[1:5]\\n        vcox <- fit$count[6]\\n        fit$count <- fit$count[1:5]\\n        imat <- fit$influence\\n        if (ranks) \\n            resid <- fit$resid\\n    }\\n    else {\\n        strata <- as.factor(strata)\\n        ustrat <- levels(strata)[table(strata) > 0]\\n        tfit <- lapply(ustrat, function(i) {\\n            keep <- which(strata == i)\\n            docount(y[keep, , drop = F], x[keep], weights[keep], timewt, timefix = timefix)\\n        })\\n        temp <- t(sapply(tfit, function(x) x$count))\\n        fit <- list(count = temp[, 1:5])\\n        count2 <- colSums(fit$count)\\n        if (!keepstrata) \\n            fit$count <- count2\\n        vcox <- sum(temp[, 6])\\n        imat <- do.call(\"rbind\", lapply(tfit, function(x) x$influence))\\n        index <- match(1:n, (1:n)[order(strata)])\\n        imat <- imat[index, ]\\n        if (ranks) {\\n            nr <- lapply(tfit, function(x) nrow(x$resid))\\n            resid <- do.call(\"rbind\", lapply(tfit, function(x) x$resid))\\n            resid$strata <- rep(ustrat, nr)\\n        }\\n    }\\n    npair <- sum(count2[1:3])\\n    somer <- (count2[1] - count2[2])/npair\\n    dfbeta <- weights * ((imat[, 1] - imat[, 2])/npair - (somer/npair) * rowSums(imat[, 1:3]))\\n    if (!missing(cluster) && length(cluster) > 0) {\\n        dfbeta <- tapply(dfbeta, cluster, sum)\\n        dfbeta <- ifelse(is.na(dfbeta), 0, dfbeta)\\n    }\\n    var.somer <- sum(dfbeta^2)\\n    if (!keepstrata && is.matrix(fit$count)) \\n        fit$count <- colSums(fit$count)\\n    rval <- list(concordance = (somer + 1)/2, count = fit$count, n = n, var = var.somer/4, cvar = vcox/(4 * npair^2))\\n    if (is.matrix(rval$count)) \\n        colnames(rval$count) <- c(\"concordant\", \"discordant\", \"tied.x\", \"tied.y\", \"tied.xy\")\\n    else names(rval$count) <- c(\"concordant\", \"discordant\", \"tied.x\", \"tied.y\", \"tied.xy\")\\n    if (influence == 1 || influence == 3) \\n        rval$dfbeta <- dfbeta/2\\n    if (influence >= 2) \\n        rval$influence <- imat\\n    if (ranks) \\n        rval$ranks <- resid\\n    if (reverse) {\\n        rval$concordance <- 1 - rval$concordance\\n        if (!is.null(rval$dfbeta)) \\n            rval$dfbeta <- -rval$dfbeta\\n        if (!is.null(rval$influence)) {\\n            rval$influence <- rval$influence[, c(2, 1, 3, 4, 5)]\\n            colnames(rval$influence) <- colnames(rval$influence)[c(2, 1, 3, 4, 5)]\\n        }\\n        if (is.matrix(rval$count)) {\\n            rval$count <- rval$count[, c(2, 1, 3, 4, 5)]\\n            colnames(rval$count) <- colnames(rval$count)[c(2, 1, 3, 4, 5)]\\n        }\\n        else {\\n            rval$count <- rval$count[c(2, 1, 3, 4, 5)]\\n            names(rval$count) <- names(rval$count)[c(2, 1, 3, 4, 5)]\\n        }\\n        if (ranks) \\n            rval$ranks$rank <- -rval$ranks$rank\\n    }\\n    rval\\n}","2":"23"},{"1":"lowess","2":"23"},{"1":"mstepVII","2":"23"},{"1":"panel.overplot","2":"23"},{"1":"Surv","2":"23"},{"1":".garchModelSeries","2":"22"},{"1":"cdensVEE","2":"22"},{"1":"cdensVEI","2":"22"},{"1":"ergm:::InitErgmTerm.mutual","2":"22"},{"1":"mstepEVE","2":"22"},{"1":"x11_hex","2":"22"},{"1":"add.tree.id","2":"21"},{"1":"cat","2":"21"},{"1":"check.reduce","2":"21"},{"1":"function (x, centers, iter.max = 100, verbose = FALSE, dist = \"euclidean\", method = \"cmeans\", m = 2, rate.par = NULL, weights = 1, \\n    control = list()) \\n{\\n    x <- as.matrix(x)\\n    xrows <- nrow(x)\\n    xcols <- ncol(x)\\n    if (missing(centers)) \\n        stop(\"Argument 'centers' must be a number or a matrix.\")\\n    dist <- pmatch(dist, c(\"euclidean\", \"manhattan\"))\\n    if (is.na(dist)) \\n        stop(\"invalid distance\")\\n    if (dist == -1) \\n        stop(\"ambiguous distance\")\\n    method <- pmatch(method, c(\"cmeans\", \"ufcl\"))\\n    if (is.na(method)) \\n        stop(\"invalid clustering method\")\\n    if (method == -1) \\n        stop(\"ambiguous clustering method\")\\n    if (length(centers) == 1) {\\n        ncenters <- centers\\n        centers <- x[sample(1:xrows, ncenters), , drop = FALSE]\\n        if (any(duplicated(centers))) {\\n            cn <- unique(x)\\n            mm <- nrow(cn)\\n            if (mm < ncenters) \\n                stop(\"More cluster centers than distinct data points.\")\\n            centers <- cn[sample(1:mm, ncenters), , drop = FALSE]\\n        }\\n    }\\n    else {\\n        centers <- as.matrix(centers)\\n        if (any(duplicated(centers))) \\n            stop(\"Initial centers are not distinct.\")\\n        cn <- NULL\\n        ncenters <- nrow(centers)\\n        if (xrows < ncenters) \\n            stop(\"More cluster centers than data points.\")\\n    }\\n    if (xcols != ncol(centers)) \\n        stop(\"Must have same number of columns in 'x' and 'centers'.\")\\n    if (iter.max < 1) \\n        stop(\"Argument 'iter.max' must be positive.\")\\n    if (method == 2) {\\n        if (missing(rate.par)) {\\n            rate.par <- 0.3\\n        }\\n    }\\n    reltol <- control$reltol\\n    if (is.null(reltol)) \\n        reltol <- sqrt(.Machine$double.eps)\\n    if (reltol <= 0) \\n        stop(\"Control parameter 'reltol' must be positive.\")\\n    if (any(weights < 0)) \\n        stop(\"Argument 'weights' has negative elements.\")\\n    if (!any(weights > 0)) \\n        stop(\"Argument 'weights' has no positive elements.\")\\n    weights <- rep(weights, length = xrows)\\n    weights <- weights/sum(weights)\\n    perm <- sample(xrows)\\n    x <- x[perm, ]\\n    weights <- weights[perm]\\n    initcenters <- centers\\n    pos <- as.factor(1:ncenters)\\n    rownames(centers) <- pos\\n    if (method == 1) {\\n        retval <- .C(R_cmeans, as.double(x), as.integer(xrows), as.integer(xcols), centers = as.double(centers), as.integer(ncenters), \\n            as.double(weights), as.double(m), as.integer(dist - 1), as.integer(iter.max), as.double(reltol), as.integer(verbose), \\n            u = double(xrows * ncenters), ermin = double(1), iter = integer(1))\\n    }\\n    else if (method == 2) {\\n        retval <- .C(R_ufcl, x = as.double(x), as.integer(xrows), as.integer(xcols), centers = as.double(centers), as.integer(ncenters), \\n            as.double(weights), as.double(m), as.integer(dist - 1), as.integer(iter.max), as.double(reltol), as.integer(verbose), \\n            as.double(rate.par), u = double(xrows * ncenters), ermin = double(1), iter = integer(1))\\n    }\\n    centers <- matrix(retval$centers, ncol = xcols, dimnames = list(1:ncenters, colnames(initcenters)))\\n    u <- matrix(retval$u, ncol = ncenters, dimnames = list(rownames(x), 1:ncenters))\\n    u <- u[order(perm), ]\\n    iter <- retval$iter - 1\\n    withinerror <- retval$ermin\\n    cluster <- apply(u, 1, which.max)\\n    clustersize <- as.integer(table(cluster))\\n    retval <- list(centers = centers, size = clustersize, cluster = cluster, membership = u, iter = iter, withinerror = withinerror, \\n        call = match.call())\\n    class(retval) <- c(\"fclust\")\\n    return(retval)\\n}","2":"21"},{"1":"lattice::levelplot","2":"21"},{"1":"make_ring","2":"21"},{"1":"sample","2":"21"},{"1":"stats::optim","2":"21"},{"1":"yates_setup","2":"21"},{"1":"as.integer64","2":"20"},{"1":"asin","2":"20"},{"1":"expect_warning","2":"20"},{"1":"function(path = \".\", force = FALSE) utils::capture.output(usethis::proj_set(path = path, force = force))","2":"20"},{"1":"if","2":"20"},{"1":"is.string","2":"20"},{"1":"logLikHess","2":"20"},{"1":"MclustDA","2":"20"},{"1":"mstepEEV","2":"20"},{"1":"resid","2":"20"},{"1":"rlegend","2":"20"},{"1":"dnorm","2":"19"},{"1":"for","2":"19"},{"1":"interaction","2":"19"},{"1":"model.matrix","2":"19"},{"1":"mstepEII","2":"19"},{"1":"mstepEVI","2":"19"},{"1":"mstepVVE","2":"19"},{"1":"as.factor","2":"18"},{"1":"colnames","2":"18"},{"1":"ergm:::InitWtErgmTerm.absdiffcat","2":"18"},{"1":"function (data, timewt, ymin, ymax, influence = 0, ranks = FALSE, reverse, fname, keepstrata) \\n{\\n    Call <- match.call()\\n    fargs <- c(\"timewt\", \"ymin\", \"ymax\", \"influence\", \"ranks\", \"reverse\", \"keepstrata\")\\n    fcall <- Call[c(1, match(fargs, names(Call), nomatch = 0))]\\n    fcall[[1L]] <- concordancefit\\n    nfit <- length(data)\\n    if (nfit == 1) {\\n        dd <- data[[1]]\\n        fcall$y <- dd$y\\n        fcall$x <- dd$x\\n        fcall$strata <- dd$strata\\n        fcall$weights <- dd$weights\\n        fcall$cluster <- dd$cluster\\n        rval <- eval(fcall, parent.frame())\\n    }\\n    else {\\n        n <- length(data[[1]]$x)\\n        for (i in 2:nfit) {\\n            if (length(data[[i]]$x) != n) \\n                stop(\"all models must have the same sample size\")\\n            if (!identical(data[[1]]$y, data[[i]]$y)) \\n                stop(\"all models must have the exact same response vector\")\\n            if (!identical(data[[1]]$weights, data[[i]]$weights)) \\n                stop(\"all models must have the same weight vector\")\\n        }\\n        if (influence == 2) \\n            fcall$influence <- 3\\n        else fcall$influence <- 1\\n        flist <- lapply(data, function(d) {\\n            temp <- fcall\\n            temp$y <- d$y\\n            temp$x <- d$x\\n            temp$strata <- d$strata\\n            temp$weights <- d$weights\\n            temp$cluster <- d$cluster\\n            eval(temp, parent.frame())\\n        })\\n        for (i in 2:nfit) {\\n            if (length(flist[[1]]$dfbeta) != length(flist[[i]]$dfbeta)) \\n                stop(\"models must have identical clustering\")\\n        }\\n        count = do.call(rbind, lapply(flist, function(x) {\\n            if (is.matrix(x$count)) \\n                colSums(x$count)\\n            else x$count\\n        }))\\n        concordance <- sapply(flist, function(x) x$concordance)\\n        dfbeta <- sapply(flist, function(x) x$dfbeta)\\n        names(concordance) <- fname\\n        rownames(count) <- fname\\n        wt <- data[[1]]$weights\\n        if (is.null(wt)) \\n            vmat <- crossprod(dfbeta)\\n        else vmat <- t(wt * dfbeta) %*% dfbeta\\n        rval <- list(concordance = concordance, count = count, n = flist[[1]]$n, var = vmat, cvar = sapply(flist, function(x) x$cvar))\\n        if (influence == 1) \\n            rval$dfbeta <- dfbeta\\n        else if (influence == 2) {\\n            temp <- unlist(lapply(flist, function(x) x$influence))\\n            rval$influence <- array(temp, dim = c(dim(flist[[1]]$influence), nfit))\\n        }\\n        if (ranks) {\\n            temp <- lapply(flist, function(x) x$ranks)\\n            rdat <- data.frame(fit = rep(fname, sapply(temp, nrow)), do.call(rbind, temp))\\n            row.names(rdat) <- NULL\\n            rval$ranks <- rdat\\n        }\\n    }\\n    class(rval) <- \"concordance\"\\n    rval\\n}","2":"18"},{"1":"function (x, ...) \\nUseMethod(\"boxplot\")","2":"18"},{"1":"grDevices::col2rgb","2":"18"},{"1":"grepl","2":"18"},{"1":"melt_mcmc","2":"18"},{"1":"mstepEEI","2":"18"},{"1":"mstepEVV","2":"18"},{"1":"mstepVEE","2":"18"},{"1":"mstepVEI","2":"18"},{"1":"poly","2":"18"},{"1":"pretty_format","2":"18"},{"1":"purrr::map","2":"18"},{"1":"rgamma","2":"18"},{"1":"survreg","2":"18"},{"1":"tibble::tibble","2":"18"},{"1":"update","2":"18"},{"1":"vec_ptype2","2":"18"},{"1":"vplot","2":"18"},{"1":"aic","2":"17"},{"1":"as.data.frame","2":"17"},{"1":"contours","2":"17"},{"1":"cp","2":"17"},{"1":"dplyr::bind_cols","2":"17"},{"1":"dplyr::coalesce","2":"17"},{"1":"ergm:::InitErgmTerm.sociality","2":"17"},{"1":"file.exists","2":"17"},{"1":"gamlss.ri","2":"17"},{"1":"get_node_info","2":"17"},{"1":"igraph::membership","2":"17"},{"1":"layout_with_fr","2":"17"},{"1":"lcv","2":"17"},{"1":"maxBFGSRCompute","2":"17"},{"1":"svyglm","2":"17"},{"1":"xml_child","2":"17"},{"1":"xml_find_first","2":"17"},{"1":".Call","2":"16"},{"1":"%n%","2":"16"},{"1":"base::order","2":"16"},{"1":"ergm:::InitErgmConstraint.blockdiag","2":"16"},{"1":"ergm:::InitErgmTerm.istar","2":"16"},{"1":"ergm:::InitErgmTerm.mm","2":"16"},{"1":"ergm:::InitErgmTerm.nodemix","2":"16"},{"1":"help","2":"16"},{"1":"is_pid","2":"16"},{"1":"nlme::anova.lme","2":"16"},{"1":"read_pptx","2":"16"},{"1":"sumt","2":"16"},{"1":"utils::help","2":"16"},{"1":"vec_cast","2":"16"},{"1":"colSums","2":"15"},{"1":"complete.cases","2":"15"},{"1":"ergm:::InitErgmTerm.asymmetric","2":"15"},{"1":"is_flag_or_string","2":"15"},{"1":"is.function","2":"15"},{"1":"labelSubset","2":"15"},{"1":"layout$fun","2":"15"},{"1":"mvrValstats","2":"15"},{"1":"select_loc","2":"15"},{"1":"seq","2":"15"},{"1":"summary","2":"15"},{"1":"with_tibble_cols","2":"15"},{"1":"create_tree","2":"14"},{"1":"is_constructor_cmd","2":"14"},{"1":"lattice::splom","2":"14"},{"1":"lengths","2":"14"},{"1":"Predict","2":"14"},{"1":"rpois","2":"14"},{"1":"tbl","2":"14"},{"1":"append.xmlNode","2":"13"},{"1":"deparse","2":"13"},{"1":"ergm:::InitErgmTerm.hamming","2":"13"},{"1":"ergm:::InitErgmTerm.nodeicov","2":"13"},{"1":"ergm:::InitErgmTerm.nodeocov","2":"13"},{"1":"ergm:::InitErgmTerm.receiver","2":"13"},{"1":"ergm:::InitErgmTerm.sender","2":"13"},{"1":"ergm:::InitWtErgmTerm.sum","2":"13"},{"1":"estepVEV","2":"13"},{"1":"evalq","2":"13"},{"1":"fix_data_frame","2":"13"},{"1":"function (x, ...) \\nUseMethod(\"hist\")","2":"13"},{"1":"I","2":"13"},{"1":"layer","2":"13"},{"1":"lppm","2":"13"},{"1":"map_dbl","2":"13"},{"1":"mapply","2":"13"},{"1":"plot_lines","2":"13"},{"1":"suppressWarnings","2":"13"},{"1":"system.file","2":"13"},{"1":"t","2":"13"},{"1":"vec_slice","2":"13"},{"1":"with","2":"13"},{"1":"xlsx:::.onLoad","2":"13"},{"1":"..stacktraceon..","2":"12"},{"1":"%==%","2":"12"},{"1":"complex_tabpart","2":"12"},{"1":"dudi.pca","2":"12"},{"1":"ergm:::InitErgmConstraint.observed","2":"12"},{"1":"ergm:::InitErgmTerm.b1starmix","2":"12"},{"1":"ergm:::InitErgmTerm.b1twostar","2":"12"},{"1":"ergm:::InitErgmTerm.b2starmix","2":"12"},{"1":"ergm:::InitErgmTerm.b2twostar","2":"12"},{"1":"ergm:::InitErgmTerm.gwb1degree","2":"12"},{"1":"ergm:::InitErgmTerm.gwb2degree","2":"12"},{"1":"ergm:::InitWtErgmTerm.absdiff","2":"12"},{"1":"ergm:::InitWtErgmTerm.atleast","2":"12"},{"1":"ergm:::InitWtErgmTerm.atmost","2":"12"},{"1":"ergm:::InitWtErgmTerm.greaterthan","2":"12"},{"1":"ergm:::InitWtErgmTerm.nodecov","2":"12"},{"1":"ergm:::InitWtErgmTerm.smallerthan","2":"12"},{"1":"gamlss.fp","2":"12"},{"1":"gamlss.ps","2":"12"},{"1":"grayscale","2":"12"},{"1":"mgfx","2":"12"},{"1":"MSEP","2":"12"},{"1":"num_as_location","2":"12"},{"1":"number_auto","2":"12"},{"1":"read_base_mapping","2":"12"},{"1":"reorder","2":"12"},{"1":"round","2":"12"},{"1":"TF","2":"12"},{"1":"unmorph","2":"12"},{"1":"vars_pull","2":"12"},{"1":"vec_rbind","2":"12"},{"1":"Acf","2":"11"},{"1":"bbmle::mle2","2":"11"},{"1":"ergm:::InitErgmTerm.idegree","2":"11"},{"1":"function (x, y, ...) \\nUseMethod(\"plot\")","2":"11"},{"1":"is.data.frame","2":"11"},{"1":"key","2":"11"},{"1":"mlogit.optim","2":"11"},{"1":"quote","2":"11"},{"1":"rexp","2":"11"},{"1":"rm","2":"11"},{"1":"stop","2":"11"},{"1":"vars_rename","2":"11"},{"1":"betareg","2":"10"},{"1":"bind_rows","2":"10"},{"1":"ergm:::InitErgmTerm.edgecov","2":"10"},{"1":"ergm:::InitErgmTerm.gwodegree","2":"10"},{"1":"ergm:::InitErgmTerm.hammingmix","2":"10"},{"1":"ergm:::InitErgmTerm.triangles","2":"10"},{"1":"ergm:::InitWtErgmTerm.b1factor","2":"10"},{"1":"ergm:::InitWtErgmTerm.b1sociality","2":"10"},{"1":"ergm:::InitWtErgmTerm.b2factor","2":"10"},{"1":"ergm:::InitWtErgmTerm.b2sociality","2":"10"},{"1":"ergm:::InitWtErgmTerm.nodeifactor","2":"10"},{"1":"ergm:::InitWtErgmTerm.nodeofactor","2":"10"},{"1":"ergm:::InitWtErgmTerm.receiver","2":"10"},{"1":"ergm:::InitWtErgmTerm.sender","2":"10"},{"1":"ergm:::InitWtErgmTerm.sociality","2":"10"},{"1":"filter","2":"10"},{"1":"function (smooth.roc, ...) \\n{\\n    auc.roc(smooth.roc, ...)\\n}","2":"10"},{"1":"function (x, ...) \\nUseMethod(\"density\")","2":"10"},{"1":"gamlss.lo","2":"10"},{"1":"get_node_attrs","2":"10"},{"1":"glm.nb","2":"10"},{"1":"group_by","2":"10"},{"1":"how","2":"10"},{"1":"igraph::make_lattice","2":"10"},{"1":"initialize_newlines","2":"10"},{"1":"is_cond_expr","2":"10"},{"1":"is_for_expr","2":"10"},{"1":"is_function_dec","2":"10"},{"1":"is_while_expr","2":"10"},{"1":"join_cols","2":"10"},{"1":"lhs","2":"10"},{"1":"nparam","2":"10"},{"1":"qLO","2":"10"},{"1":"validate_grouped_df","2":"10"},{"1":"vars_select","2":"10"},{"1":"vec_assign","2":"10"},{"1":"%--%","2":"9"},{"1":"%/%","2":"9"},{"1":"cdensE","2":"9"},{"1":"corpus","2":"9"},{"1":"create_graph_series","2":"9"},{"1":"ergm:::InitErgmTerm.b1factor","2":"9"},{"1":"ergm:::InitErgmTerm.b2factor","2":"9"},{"1":"ergm:::InitErgmTerm.gwdegree","2":"9"},{"1":"ergm:::InitErgmTerm.gwidegree","2":"9"},{"1":"function (x, breaks = NULL, col = Pal()[1], ylab = \"\", lwd = 2, xlab = NULL, ...) \\n{\\n    if (is.null(breaks)) {\\n        tab <- table(x)\\n        xp <- as.numeric(names(tab))\\n        xp <- c(head(xp, 1), xp)\\n        yp <- c(0, cumsum(tab))\\n    }\\n    else {\\n        xh <- hist(x, breaks = breaks, plot = FALSE)\\n        xp <- xh$mids\\n        xp <- c(head(xp, 1), xp)\\n        yp <- c(0, cumsum(xh$density))\\n    }\\n    yp <- yp * 1/tail(yp, 1)\\n    if (is.null(xlab)) \\n        xlab <- deparse(substitute(x))\\n    plot(yp ~ xp, lwd = lwd, type = \"s\", col = col, xlab = xlab, yaxt = \"n\", ylab = \"\", panel.first = quote(grid(ny = NA)), \\n        ...)\\n    validargs <- subset(validargs <- c(names(as.list(args(axis))), c(\"cex\", \"cex.axis\", \"col.axis\", \"family\", \"fg\", \"font\", \\n        \"font.axis\", \"las\", \"mgp\", \"srt\", \"tck\", \"tcl\", \"yaxp\", \"yaxs\", \"yaxt\")), subset = validargs %nin% c(\"...\", \"\", \"col\"))\\n    axargs1 <- list(side = 2, at = seq(0, 1, 0.25), labels = Format(seq(0, 1, 0.25), leading = \"\", digits = 2), las = 1, \\n        xaxs = \"e\", lwd.axis = 1)\\n    axargs1 <- ClearArgs(provided = c(as.list(environment()), list(...)), valid = validargs, default = axargs1)\\n    axargs1[[\"lwd\"]] <- axargs1[[\"lwd.axis\"]]\\n    axargs1[[\"lwd.axis\"]] <- NULL\\n    do.call(axis, axargs1)\\n    abline(h = c(0, 0.25, 0.5, 0.75, 1), col = \"grey\", lty = c(\"dashed\", \"dotted\", \"dotted\", \"dotted\", \"dashed\"))\\n    points(x = range(x), y = c(0, 1), col = col, pch = 3, cex = 2)\\n    if (!is.null(DescToolsOptions(\"stamp\"))) \\n        Stamp()\\n}","2":"9"},{"1":"grDevices::dev.off","2":"9"},{"1":"lattice::histogram","2":"9"},{"1":"list.map","2":"9"},{"1":"make_graph","2":"9"},{"1":"rlnorm","2":"9"},{"1":"st_sfc","2":"9"},{"1":"stan_glm","2":"9"},{"1":"suppressMessages","2":"9"},{"1":"surfacePlot","2":"9"},{"1":"survfit","2":"9"},{"1":"sys.calls","2":"9"},{"1":"tabyl","2":"9"},{"1":"threshold","2":"9"},{"1":"traceback.Initializers","2":"9"},{"1":"traceback.search","2":"9"},{"1":"unlink","2":"9"},{"1":"vec_unchop","2":"9"},{"1":"zoo::index","2":"9"},{"1":"%->%","2":"8"},{"1":"abs","2":"8"},{"1":"autolayer","2":"8"},{"1":"constrOptim2","2":"8"},{"1":"ergm:::InitErgmTerm.altkstar","2":"8"},{"1":"ergm:::InitErgmTerm.nodeifactor","2":"8"},{"1":"ergm:::InitErgmTerm.nodeofactor","2":"8"},{"1":"ergm:::InitErgmTerm.odegrange","2":"8"},{"1":"ergm:::InitWtErgmTerm.nodematch","2":"8"},{"1":"eval.im","2":"8"},{"1":"f","2":"8"},{"1":"gamlss.re","2":"8"},{"1":"get","2":"8"},{"1":"getTaskData","2":"8"},{"1":"imeval","2":"8"},{"1":"library","2":"8"},{"1":"load.example","2":"8"},{"1":"locfit.raw","2":"8"},{"1":"nlme.formula","2":"8"},{"1":"offset","2":"8"},{"1":"partykit::ctree","2":"8"},{"1":"R.cache::generateCache","2":"8"},{"1":"RcppRoll::roll_mean","2":"8"},{"1":"rhs","2":"8"},{"1":"shrink","2":"8"},{"1":"value_per_node_functions","2":"8"},{"1":"vec_as_subscript","2":"8"},{"1":"%|%","2":"7"},{"1":"apply","2":"7"},{"1":"as_tbl_graph","2":"7"},{"1":"barplot","2":"7"},{"1":"datatable","2":"7"},{"1":"dendlist","2":"7"},{"1":"dformat","2":"7"},{"1":"duplicated","2":"7"},{"1":"equal.count","2":"7"},{"1":"ergm:::InitErgmTerm.degrange","2":"7"},{"1":"ergm:::InitErgmTerm.idegrange","2":"7"},{"1":"get_all_vars","2":"7"},{"1":"grow","2":"7"},{"1":"icount","2":"7"},{"1":"is_collate_field_or_all","2":"7"},{"1":"juice","2":"7"},{"1":"knit_expand","2":"7"},{"1":"loglm","2":"7"},{"1":"map_il","2":"7"},{"1":"map2","2":"7"},{"1":"pixel.grid","2":"7"},{"1":"plot_legend","2":"7"},{"1":"pvcm","2":"7"},{"1":"qexp","2":"7"},{"1":"qnorm","2":"7"},{"1":"vglm","2":"7"},{"1":"with_fallback_quiet","2":"7"},{"1":"with_fallback_warning","2":"7"},{"1":".makeCC","2":"6"},{"1":".nei","2":"6"},{"1":"%chin%","2":"6"},{"1":"arg_match","2":"6"},{"1":"boxplot","2":"6"},{"1":"checkNull","2":"6"},{"1":"ddalpha::depth.zonoid","2":"6"},{"1":"doc$doc_obj$get_at_cursor","2":"6"},{"1":"ergm:::InitErgmProposal.blockdiagTNT","2":"6"},{"1":"ergm:::InitErgmReference.DiscUnif","2":"6"},{"1":"ergm:::InitErgmTerm.b1concurrent","2":"6"},{"1":"ergm:::InitErgmTerm.b1degrange","2":"6"},{"1":"ergm:::InitErgmTerm.b1degree","2":"6"},{"1":"ergm:::InitErgmTerm.b1nodematch","2":"6"},{"1":"ergm:::InitErgmTerm.b1star","2":"6"},{"1":"ergm:::InitErgmTerm.b2concurrent","2":"6"},{"1":"ergm:::InitErgmTerm.b2degrange","2":"6"},{"1":"ergm:::InitErgmTerm.b2degree","2":"6"},{"1":"ergm:::InitErgmTerm.b2nodematch","2":"6"},{"1":"ergm:::InitErgmTerm.b2star","2":"6"},{"1":"ergm:::InitErgmTerm.concurrent","2":"6"},{"1":"ergm:::InitErgmTerm.concurrentties","2":"6"},{"1":"ergm:::InitErgmTerm.ctriple","2":"6"},{"1":"ergm:::InitErgmTerm.cyclicalties","2":"6"},{"1":"ergm:::InitErgmTerm.ostar","2":"6"},{"1":"ergm:::InitErgmTerm.tripercent","2":"6"},{"1":"ergm:::InitErgmTerm.ttriple","2":"6"},{"1":"ergm:::InitWtErgmTerm.edgecov","2":"6"},{"1":"expect_is","2":"6"},{"1":"function (x, y = NULL, legend, fill = NULL, col = par(\"col\"), border = \"black\", lty, lwd, pch, angle = 45, density = NULL, \\n    bty = \"o\", bg = par(\"bg\"), box.lwd = par(\"lwd\"), box.lty = par(\"lty\"), box.col = par(\"fg\"), pt.bg = NA, cex = 1, pt.cex = cex, \\n    pt.lwd = lwd, xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1, adj = c(0, 0.5), text.width = NULL, text.col = par(\"col\"), \\n    text.font = NULL, merge = do.lines && has.pch, trace = FALSE, plot = TRUE, ncol = 1, horiz = FALSE, title = NULL, inset = 0, \\n    xpd, title.col = text.col, title.adj = 0.5, seg.len = 2) \\n{\\n    if (missing(legend) && !missing(y) && (is.character(y) || is.expression(y))) {\\n        legend <- y\\n        y <- NULL\\n    }\\n    mfill <- !missing(fill) || !missing(density)\\n    if (!missing(xpd)) {\\n        op <- par(\"xpd\")\\n        on.exit(par(xpd = op))\\n        par(xpd = xpd)\\n    }\\n    title <- as.graphicsAnnot(title)\\n    if (length(title) > 1) \\n        stop(\"invalid 'title'\")\\n    legend <- as.graphicsAnnot(legend)\\n    n.leg <- if (is.call(legend)) \\n        1\\n    else length(legend)\\n    if (n.leg == 0) \\n        stop(\"'legend' is of length 0\")\\n    auto <- if (is.character(x)) \\n        match.arg(x, c(\"bottomright\", \"bottom\", \"bottomleft\", \"left\", \"topleft\", \"top\", \"topright\", \"right\", \"center\"))\\n    else NA\\n    if (is.na(auto)) {\\n        xy <- xy.coords(x, y, setLab = FALSE)\\n        x <- xy$x\\n        y <- xy$y\\n        nx <- length(x)\\n        if (nx < 1 || nx > 2) \\n            stop(\"invalid coordinate lengths\")\\n    }\\n    else nx <- 0\\n    xlog <- par(\"xlog\")\\n    ylog <- par(\"ylog\")\\n    rect2 <- function(left, top, dx, dy, density = NULL, angle, ...) {\\n        r <- left + dx\\n        if (xlog) {\\n            left <- 10^left\\n            r <- 10^r\\n        }\\n        b <- top - dy\\n        if (ylog) {\\n            top <- 10^top\\n            b <- 10^b\\n        }\\n        rect(left, top, r, b, angle = angle, density = density, ...)\\n    }\\n    segments2 <- function(x1, y1, dx, dy, ...) {\\n        x2 <- x1 + dx\\n        if (xlog) {\\n            x1 <- 10^x1\\n            x2 <- 10^x2\\n        }\\n        y2 <- y1 + dy\\n        if (ylog) {\\n            y1 <- 10^y1\\n            y2 <- 10^y2\\n        }\\n        segments(x1, y1, x2, y2, ...)\\n    }\\n    points2 <- function(x, y, ...) {\\n        if (xlog) \\n            x <- 10^x\\n        if (ylog) \\n            y <- 10^y\\n        points(x, y, ...)\\n    }\\n    text2 <- function(x, y, ...) {\\n        if (xlog) \\n            x <- 10^x\\n        if (ylog) \\n            y <- 10^y\\n        text(x, y, ...)\\n    }\\n    if (trace) {\\n        catn <- function(...) do.call(cat, c(lapply(list(...), formatC), \"\\\\n\"))\\n        fv <- function(...) paste(vapply(lapply(list(...), formatC), paste, collapse = \",\", \"\"), collapse = \", \")\\n    }\\n    Cex <- cex * par(\"cex\")\\n    if (is.null(text.width)) \\n        text.width <- max(abs(strwidth(legend, units = \"user\", cex = cex, font = text.font)))\\n    else if (!is.numeric(text.width) || text.width < 0) \\n        stop(\"'text.width' must be numeric, >= 0\")\\n    xyc <- xyinch(par(\"cin\"), warn.log = FALSE)\\n    xc <- Cex * xyc[1L]\\n    yc <- Cex * xyc[2L]\\n    if (any(n_ <- xc < 0)) \\n        text.width[n_] <- -text.width[n_]\\n    xchar <- xc\\n    xextra <- 0\\n    yextra <- yc * (y.intersp - 1)\\n    ymax <- yc * max(1, strheight(legend, units = \"user\", cex = cex)/yc)\\n    ychar <- yextra + ymax\\n    if (trace) \\n        catn(\"  xchar=\", fv(xchar), \"; (yextra, ychar)=\", fv(yextra, ychar))\\n    if (mfill) {\\n        xbox <- xc * 0.8\\n        ybox <- yc * 0.5\\n        dx.fill <- max(xbox)\\n    }\\n    do.lines <- (!missing(lty) && (is.character(lty) || any(lty > 0))) || !missing(lwd)\\n    n.legpercol <- if (horiz) {\\n        if (ncol != 1) \\n            warning(gettextf(\"horizontal specification overrides: Number of columns := %d\", n.leg), domain = NA)\\n        ncol <- n.leg\\n        1\\n    }\\n    else ceiling(n.leg/ncol)\\n    has.pch <- !missing(pch) && length(pch) > 0\\n    if (do.lines) {\\n        x.off <- if (merge) \\n            -0.7\\n        else 0\\n    }\\n    else if (merge) \\n        warning(\"'merge = TRUE' has no effect when no line segments are drawn\")\\n    if (has.pch) {\\n        if (is.character(pch) && !is.na(pch[1L]) && nchar(pch[1L], type = \"c\") > 1) {\\n            if (length(pch) > 1) \\n                warning(\"not using pch[2..] since pch[1L] has multiple chars\")\\n            np <- nchar(pch[1L], type = \"c\")\\n            pch <- substr(rep.int(pch[1L], np), 1L:np, 1L:np)\\n        }\\n        if (!is.character(pch)) \\n            pch <- as.integer(pch)\\n    }\\n    if (is.na(auto)) {\\n        if (xlog) \\n            x <- log10(x)\\n        if (ylog) \\n            y <- log10(y)\\n    }\\n    if (nx == 2) {\\n        x <- sort(x)\\n        y <- sort(y)\\n        left <- x[1L]\\n        top <- y[2L]\\n        w <- diff(x)\\n        h <- diff(y)\\n        w0 <- w/ncol\\n        x <- mean(x)\\n        y <- mean(y)\\n        if (missing(xjust)) \\n            xjust <- 0.5\\n        if (missing(yjust)) \\n            yjust <- 0.5\\n    }\\n    else {\\n        h <- (n.legpercol + !is.null(title)) * ychar + yc\\n        xch1 <- max(xchar)\\n        w0 <- text.width + (x.intersp + 1) * xch1\\n        if (mfill) \\n            w0 <- w0 + dx.fill\\n        if (do.lines) \\n            w0 <- w0 + (seg.len + x.off) * xch1\\n        w <- ncol * w0 + 0.5 * xch1\\n        if (!is.null(title) && (abs(tw <- strwidth(title, units = \"user\", cex = cex) + 0.5 * xchar)) > abs(w)) {\\n            xextra <- (tw - w)/2\\n            w <- tw\\n        }\\n        if (is.na(auto)) {\\n            left <- x - xjust * w\\n            top <- y + (1 - yjust) * h\\n        }\\n        else {\\n            usr <- par(\"usr\")\\n            inset <- rep_len(inset, 2)\\n            insetx <- inset[1L] * (usr[2L] - usr[1L])\\n            left <- switch(auto, bottomright = , topright = , right = usr[2L] - w - insetx, bottomleft = , left = , topleft = usr[1L] + \\n                insetx, bottom = , top = , center = (usr[1L] + usr[2L] - w)/2)\\n            insety <- inset[2L] * (usr[4L] - usr[3L])\\n            top <- switch(auto, bottomright = , bottom = , bottomleft = usr[3L] + h + insety, topleft = , top = , topright = usr[4L] - \\n                insety, left = , right = , center = (usr[3L] + usr[4L] + h)/2)\\n        }\\n    }\\n    if (plot && bty != \"n\") {\\n        if (trace) \\n            catn(\"  rect2(\", left, \",\", top, \", w=\", w, \", h=\", h, \", ...)\", sep = \"\")\\n        rect2(left, top, dx = w, dy = h, col = bg, density = NULL, lwd = box.lwd, lty = box.lty, border = box.col)\\n    }\\n    xt <- left + xchar + xextra + (w0 * rep.int(0:(ncol - 1), rep.int(n.legpercol, ncol)))[1L:n.leg]\\n    yt <- top - 0.5 * yextra - ymax - (rep.int(1L:n.legpercol, ncol)[1L:n.leg] - 1 + !is.null(title)) * ychar\\n    if (mfill) {\\n        if (plot) {\\n            if (!is.null(fill)) \\n                fill <- rep_len(fill, n.leg)\\n            rect2(left = xt, top = yt + ybox/2, dx = xbox, dy = ybox, col = fill, density = density, angle = angle, border = border)\\n        }\\n        xt <- xt + dx.fill\\n    }\\n    if (plot && (has.pch || do.lines)) \\n        col <- rep_len(col, n.leg)\\n    if (missing(lwd) || is.null(lwd)) \\n        lwd <- par(\"lwd\")\\n    if (do.lines) {\\n        if (missing(lty) || is.null(lty)) \\n            lty <- 1\\n        lty <- rep_len(lty, n.leg)\\n        lwd <- rep_len(lwd, n.leg)\\n        ok.l <- !is.na(lty) & (is.character(lty) | lty > 0) & !is.na(lwd)\\n        if (trace) \\n            catn(\"  segments2(\", xt[ok.l] + x.off * xchar, \",\", yt[ok.l], \", dx=\", seg.len * xchar, \", dy=0, ...)\")\\n        if (plot) \\n            segments2(xt[ok.l] + x.off * xchar, yt[ok.l], dx = seg.len * xchar, dy = 0, lty = lty[ok.l], lwd = lwd[ok.l], \\n                col = col[ok.l])\\n        xt <- xt + (seg.len + x.off) * xchar\\n    }\\n    if (has.pch) {\\n        pch <- rep_len(pch, n.leg)\\n        pt.bg <- rep_len(pt.bg, n.leg)\\n        pt.cex <- rep_len(pt.cex, n.leg)\\n        pt.lwd <- rep_len(pt.lwd, n.leg)\\n        ok <- !is.na(pch)\\n        if (!is.character(pch)) {\\n            ok <- ok & (pch >= 0 | pch <= -32)\\n        }\\n        else {\\n            ok <- ok & nzchar(pch)\\n        }\\n        x1 <- (if (merge && do.lines) \\n            xt - (seg.len/2) * xchar\\n        else xt)[ok]\\n        y1 <- yt[ok]\\n        if (trace) \\n            catn(\"  points2(\", x1, \",\", y1, \", pch=\", pch[ok], \", ...)\")\\n        if (plot) \\n            points2(x1, y1, pch = pch[ok], col = col[ok], cex = pt.cex[ok], bg = pt.bg[ok], lwd = pt.lwd[ok])\\n    }\\n    xt <- xt + x.intersp * xchar\\n    if (plot) {\\n        if (!is.null(title)) \\n            text2(left + w * title.adj, top - ymax, labels = title, adj = c(title.adj, 0), cex = cex, col = title.col)\\n        text2(xt, yt, labels = legend, adj = adj, cex = cex, col = text.col, font = text.font)\\n    }\\n    invisible(list(rect = list(w = w, h = h, left = left, top = top), text = list(x = xt, y = yt)))\\n}","2":"6"},{"1":"grep","2":"6"},{"1":"head","2":"6"},{"1":"igraph::V","2":"6"},{"1":"imwarp","2":"6"},{"1":"invisible","2":"6"},{"1":"is_collate_field_or_all_or_default","2":"6"},{"1":"is.dir","2":"6"},{"1":"lattice::dotplot","2":"6"},{"1":"lattice::xyplot","2":"6"},{"1":"lme","2":"6"},{"1":"matrix","2":"6"},{"1":"read_csv","2":"6"},{"1":"recode","2":"6"},{"1":"rglwidget","2":"6"},{"1":"set_locale","2":"6"},{"1":"simulate","2":"6"},{"1":"vec_rep_each","2":"6"},{"1":"warning","2":"6"},{"1":"with_tibble_rows","2":"6"},{"1":"with$fun","2":"6"},{"1":"xml_attr","2":"6"},{"1":".levels","2":"5"},{"1":".libPaths","2":"5"},{"1":"%inr%","2":"5"},{"1":"|","2":"5"},{"1":"as.vector","2":"5"},{"1":"bit64::as.integer64","2":"5"},{"1":"call_to_format","2":"5"},{"1":"case_when","2":"5"},{"1":"cdf.lmscreg","2":"5"},{"1":"check_slice_size","2":"5"},{"1":"CJ","2":"5"},{"1":"colorise","2":"5"},{"1":"data","2":"5"},{"1":"deprecate_stop","2":"5"},{"1":"dfm","2":"5"},{"1":"download_url","2":"5"},{"1":"ergm:::InitErgmProposal.CondDegree","2":"5"},{"1":"ergm:::InitErgmTerm.b1cov","2":"5"},{"1":"ergm:::InitErgmTerm.b2cov","2":"5"},{"1":"ergm:::InitErgmTerm.density","2":"5"},{"1":"ergm:::InitWtErgmTerm.nonzero","2":"5"},{"1":"faux_download","2":"5"},{"1":"feature_spec","2":"5"},{"1":"format","2":"5"},{"1":"format_name","2":"5"},{"1":"function (x, ...) \\nUseMethod(\"SiegelTukeyTest\")","2":"5"},{"1":"Heading","2":"5"},{"1":"if_else","2":"5"},{"1":"imfill","2":"5"},{"1":"imhessian","2":"5"},{"1":"imrep","2":"5"},{"1":"is.count","2":"5"},{"1":"lattice::qqmath","2":"5"},{"1":"lmerTest::lmer","2":"5"},{"1":"mstepE","2":"5"},{"1":"out$get_section","2":"5"},{"1":"pad","2":"5"},{"1":"person_desc","2":"5"},{"1":"sample_frac","2":"5"},{"1":"set.seed","2":"5"},{"1":"shift","2":"5"},{"1":"SSasymp","2":"5"},{"1":"st_point","2":"5"},{"1":"stats::nls","2":"5"},{"1":"summaryMclustBICn","2":"5"},{"1":"textstat_dist","2":"5"},{"1":"union","2":"5"},{"1":"unname","2":"5"},{"1":"wgt","2":"5"},{"1":"%inrange%","2":"4"},{"1":"$<-","2":"4"},{"1":"aov","2":"4"},{"1":"as_tibble","2":"4"},{"1":"as.network","2":"4"},{"1":"as.tokens","2":"4"},{"1":"assert_engine","2":"4"},{"1":"assert_is_identical_to_true","2":"4"},{"1":"autocrop","2":"4"},{"1":"bbs","2":"4"},{"1":"bind_cols","2":"4"},{"1":"body_add_par","2":"4"},{"1":"boundary","2":"4"},{"1":"create_ring","2":"4"},{"1":"cut","2":"4"},{"1":"deriche","2":"4"},{"1":"dNBI","2":"4"},{"1":"dplyr::select","2":"4"},{"1":"dPO","2":"4"},{"1":"ergm:::InitErgmConstraint.edges","2":"4"},{"1":"ergm:::InitErgmProposal.blockdiagNonObservedTNT","2":"4"},{"1":"ergm:::InitErgmProposal.ConstantEdges","2":"4"},{"1":"ergm:::InitErgmProposal.NonObservedTNT","2":"4"},{"1":"ergm:::InitErgmProposal.RLETNT","2":"4"},{"1":"ergm:::InitErgmTerm.b1sociality","2":"4"},{"1":"ergm:::InitErgmTerm.b2sociality","2":"4"},{"1":"ergm:::InitErgmTerm.ddsp","2":"4"},{"1":"ergm:::InitErgmTerm.desp","2":"4"},{"1":"ergm:::InitErgmTerm.dnsp","2":"4"},{"1":"ergm:::InitWtErgmProposal.DiscUnif","2":"4"},{"1":"ergm:::InitWtErgmProposal.DistRLE","2":"4"},{"1":"ergm:::InitWtErgmTerm.b1cov","2":"4"},{"1":"ergm:::InitWtErgmTerm.b2cov","2":"4"},{"1":"ergm:::InitWtErgmTerm.nodeicov","2":"4"},{"1":"ergm:::InitWtErgmTerm.nodeocov","2":"4"},{"1":"estepEEE","2":"4"},{"1":"expect_false","2":"4"},{"1":"fcm_select","2":"4"},{"1":"from_igraph","2":"4"},{"1":"function (x, ticksize = 0.03, side = 1, lwd = 0.5, col = par(\"fg\"), quiet = getOption(\"warn\") < 0, ...) \\n{\\n    x <- as.vector(x)\\n    ok <- is.finite(x)\\n    x <- x[ok]\\n    if (!quiet) {\\n        u <- par(\"usr\")\\n        u <- if (side%%2 == 1) {\\n            if (par(\"xlog\")) \\n                10^u[1L:2]\\n            else u[1L:2]\\n        }\\n        else {\\n            if (par(\"ylog\")) \\n                10^u[3:4]\\n            else u[3:4]\\n        }\\n        if (any(x < u[1L] | x > u[2L])) \\n            warning(\"some values will be clipped\")\\n    }\\n    Axis(side = side, at = x, labels = FALSE, lwd = 0, lwd.ticks = lwd, col.ticks = col, tck = ticksize, ...)\\n}","2":"4"},{"1":"gamlss.pcat","2":"4"},{"1":"gamlss.pp","2":"4"},{"1":"gamlss.random","2":"4"},{"1":"get_degree_distribution","2":"4"},{"1":"get_node_ids","2":"4"},{"1":"gplot","2":"4"},{"1":"gregexpr","2":"4"},{"1":"hist","2":"4"},{"1":"imgradient","2":"4"},{"1":"inrange","2":"4"},{"1":"lag","2":"4"},{"1":"lattice::densityplot","2":"4"},{"1":"lmList","2":"4"},{"1":"lo.wam","2":"4"},{"1":"message","2":"4"},{"1":"mixed","2":"4"},{"1":"new_tibble","2":"4"},{"1":"nscrabble","2":"4"},{"1":"numeric","2":"4"},{"1":"pht","2":"4"},{"1":"plnorm","2":"4"},{"1":"purrr::map2","2":"4"},{"1":"RcppRoll::roll_median","2":"4"},{"1":"sample_n","2":"4"},{"1":"summarise","2":"4"},{"1":"textstat_simil","2":"4"},{"1":"tokens_remove","2":"4"},{"1":"transform","2":"4"},{"1":"tryEval","2":"4"},{"1":"utils::combn","2":"4"},{"1":"vanvliet","2":"4"},{"1":"vec_cbind","2":"4"},{"1":"vec_rep","2":"4"},{"1":"which","2":"4"},{"1":"which.min","2":"4"},{"1":"with_c_foobar","2":"4"},{"1":"write_utf8","2":"4"},{"1":"xgb.gblinear.history","2":"4"},{"1":".","2":"3"},{"1":".POSIXct","2":"3"},{"1":"%between%","2":"3"},{"1":"%like%","2":"3"},{"1":"addSeries","2":"3"},{"1":"are_equal","2":"3"},{"1":"array_branch","2":"3"},{"1":"as.ITime","2":"3"},{"1":"as.raster","2":"3"},{"1":"as.splits","2":"3"},{"1":"between","2":"3"},{"1":"bols","2":"3"},{"1":"cannyEdges","2":"3"},{"1":"Ccf","2":"3"},{"1":"check_weight","2":"3"},{"1":"clean","2":"3"},{"1":"cli_status_clear","2":"3"},{"1":"cnd_signal","2":"3"},{"1":"coef","2":"3"},{"1":"collect","2":"3"},{"1":"coxph","2":"3"},{"1":"d","2":"3"},{"1":"dbplyr::memdb_frame","2":"3"},{"1":"decostand","2":"3"},{"1":"DiagrammeR::create_graph","2":"3"},{"1":"dir.create","2":"3"},{"1":"div","2":"3"},{"1":"dNO","2":"3"},{"1":"doMultiStraussHard","2":"3"},{"1":"dplyr_col_select","2":"3"},{"1":"dplyr::setdiff","2":"3"},{"1":"dt","2":"3"},{"1":"ergm:::InitErgmConstraint.degrees","2":"3"},{"1":"ergm:::InitErgmTerm.b1mindegree","2":"3"},{"1":"ergm:::InitErgmTerm.b2mindegree","2":"3"},{"1":"ergm:::InitErgmTerm.ctriad","2":"3"},{"1":"ergm:::InitErgmTerm.degcor","2":"3"},{"1":"ergm:::InitErgmTerm.degcrossprod","2":"3"},{"1":"ergm:::InitErgmTerm.degree1.5","2":"3"},{"1":"ergm:::InitErgmTerm.idegree1.5","2":"3"},{"1":"ergm:::InitErgmTerm.intransitive","2":"3"},{"1":"ergm:::InitErgmTerm.m2star","2":"3"},{"1":"ergm:::InitErgmTerm.nearsimmelian","2":"3"},{"1":"ergm:::InitErgmTerm.odegree1.5","2":"3"},{"1":"ergm:::InitErgmTerm.opentriad","2":"3"},{"1":"ergm:::InitErgmTerm.simmelian","2":"3"},{"1":"ergm:::InitErgmTerm.simmelianties","2":"3"},{"1":"ergm:::InitErgmTerm.transitive","2":"3"},{"1":"ergm:::InitErgmTerm.transitiveties","2":"3"},{"1":"ergm:::InitErgmTerm.ttriad","2":"3"},{"1":"ergm:::InitWtErgmTerm.edges","2":"3"},{"1":"estepEEI","2":"3"},{"1":"estepEEV","2":"3"},{"1":"estepEII","2":"3"},{"1":"estepEVE","2":"3"},{"1":"estepEVI","2":"3"},{"1":"estepEVV","2":"3"},{"1":"estepVEE","2":"3"},{"1":"estepVEI","2":"3"},{"1":"estepVII","2":"3"},{"1":"estepVVE","2":"3"},{"1":"estepVVI","2":"3"},{"1":"estepVVV","2":"3"},{"1":"format1","2":"3"},{"1":"function (line, y, width, labels, lty, lwd, col, cex, main = NULL) \\n{\\n    line <- rep(line, length.out = 2)\\n    txtline <- line[1] + ZeroIfNA(width + (!is.na(width)) * line[2])\\n    mtext(side = 4, las = 1, cex = cex, text = labels, line = txtline, at = y)\\n    if (!is.na(width)) {\\n        x0 <- LineToUser(line[1], 4)\\n        segments(x0 = x0, x1 = LineToUser(line[1] + width, 4), y0 = y, lwd = lwd, lty = lty, lend = 1, col = col)\\n    }\\n    if (!is.null(main)) \\n        mtext(side = 4, text = main, las = 1, line = line[1], at = par(\"usr\")[4], padj = c(0))\\n}","2":"3"},{"1":"function (model, data = sys.frame(sys.parent()), fixed, random, groups, start, correlation = NULL, weights = NULL, subset, \\n    method = c(\"ML\", \"REML\"), na.action = na.fail, naPattern, control = list(), verbose = FALSE) \\n{\\n    finiteDiffGrad <- function(model, data, pars) {\\n        dframe <- data.frame(data, pars)\\n        base <- eval(model, dframe)\\n        nm <- colnames(pars)\\n        grad <- array(base, c(length(base), length(nm)), list(NULL, nm))\\n        ssize <- sqrt(.Machine$double.eps)\\n        for (i in nm) {\\n            diff <- pp <- pars[, i]\\n            diff[pp == 0] <- ssize\\n            diff[pp != 0] <- pp[pp != 0] * ssize\\n            dframe[[i]] <- pp + diff\\n            grad[, i] <- (base - eval(model, dframe))/diff\\n            dframe[[i]] <- pp\\n        }\\n        grad\\n    }\\n    Call <- match.call()\\n    controlvals <- nlmeControl()\\n    if (!missing(control)) {\\n        controlvals[names(control)] <- control\\n    }\\n    if (!inherits(model, \"formula\")) \\n        stop(\"'model' must be a formula\")\\n    if (length(model) != 3) \\n        stop(\"model formula must be of the form \\\\\"resp ~ pred\\\\\"\")\\n    method <- match.arg(method)\\n    REML <- method == \"REML\"\\n    if (missing(random)) {\\n        random <- fixed\\n    }\\n    reSt <- reStruct(random, REML = REML, data = NULL)\\n    if (missing(groups)) {\\n        groups <- getGroupsFormula(reSt)\\n    }\\n    if (is.null(groups)) {\\n        if (inherits(data, \"groupedData\")) {\\n            groups <- getGroupsFormula(data)\\n            namGrp <- rev(names(getGroupsFormula(data, asList = TRUE)))\\n            Q <- length(namGrp)\\n            if (length(reSt) != Q) {\\n                if (length(reSt) != 1) \\n                  stop(\"incompatible lengths for 'random' and grouping factors\")\\n                randL <- vector(\"list\", Q)\\n                names(randL) <- rev(namGrp)\\n                for (i in 1:Q) randL[[i]] <- random\\n                reSt <- reStruct(randL, REML = REML, data = NULL)\\n            }\\n        }\\n        else {\\n            groups <- ~1\\n            names(reSt) <- namGrp <- \"1\"\\n        }\\n    }\\n    else {\\n        g.exp <- eval(parse(text = paste0(\"~1 |\", deparse(groups[[2]]))))\\n        namGrp <- rev(names(getGroupsFormula(g.exp, asList = TRUE)))\\n    }\\n    names(reSt) <- namGrp\\n    if (missing(start) && !is.null(attr(eval(model[[3]][[1]]), \"initial\"))) {\\n        nlmeCall <- Call\\n        nlsLCall <- nlmeCall[c(\"\", \"model\", \"data\", \"groups\")]\\n        nlsLCall[[1]] <- quote(nlme::nlsList)\\n        names(nlsLCall)[2] <- \"model\"\\n        nm <- names(nlmeCall)\\n        for (i in c(\"fixed\", \"data\", \"groups\", \"start\")) if (i %in% nm) \\n            nlmeCall[[i]] <- NULL\\n        nlmeCall[[1]] <- quote(nlme::nlme.nlsList)\\n        if (is.null(dim(data))) {\\n            stop(\"'data' must be given explicitly to use 'nlsList'\")\\n        }\\n        nlsLObj <- eval(nlsLCall)\\n        nlsLObj\\n        nlmeCall[[\"model\"]] <- quote(nlsLObj)\\n        nlmeCall <- as.call(nlmeCall)\\n        val <- eval(nlmeCall)\\n        val$origCall <- NULL\\n        return(val)\\n    }\\n    if (is.numeric(start)) {\\n        start <- list(fixed = start)\\n    }\\n    nlmeModel <- call(\"-\", model[[2]], model[[3]])\\n    if (!is.list(fixed)) \\n        fixed <- list(fixed)\\n    fixed <- do.call(c, lapply(fixed, function(fix.i) {\\n        if (is.name(fix.i[[2]])) \\n            list(fix.i)\\n        else eval(parse(text = paste0(\"list(\", paste(paste(all.vars(fix.i[[2]]), deparse(fix.i[[3]]), sep = \"~\"), collapse = \",\"), \\n            \")\")))\\n    }))\\n    fnames <- lapply(fixed, function(fix.i) {\\n        this <- eval(fix.i)\\n        if (!inherits(this, \"formula\")) \\n            stop(\"'fixed' must be a formula or list of formulae\")\\n        if (length(this) != 3) \\n            stop(\"formulae in 'fixed' must be of the form \\\\\"parameter ~ expr\\\\\"\")\\n        if (!is.name(this[[2]])) \\n            stop(\"formulae in 'fixed' must be of the form \\\\\"parameter ~ expr\\\\\"\")\\n        as.character(this[[2]])\\n    })\\n    names(fixed) <- fnames\\n    ranForm <- formula(reSt)\\n    Q <- length(ranForm)\\n    names(ranForm) <- namGrp\\n    rnames <- vector(\"list\", Q)\\n    names(rnames) <- namGrp\\n    for (i in 1:Q) {\\n        rnames[[i]] <- character(length(ranForm[[i]]))\\n        for (j in seq_along(ranForm[[i]])) {\\n            this <- eval(ranForm[[i]][[j]])\\n            if (!inherits(this, \"formula\")) \\n                stop(\"'random' must be a formula or list of formulae\")\\n            if (length(this) != 3) \\n                stop(\"formulae in 'random' must be of the form \\\\\"parameter ~ expr\\\\\"\")\\n            if (!is.name(this[[2]])) \\n                stop(\"formulae in 'random' must be of the form \\\\\"parameter ~ expr\\\\\"\")\\n            rnames[[i]][j] <- deparse(this[[2]])\\n        }\\n        names(ranForm[[i]]) <- rnames[[i]]\\n    }\\n    pnames <- unique(c(fnames, unlist(rnames)))\\n    if (!is.null(correlation)) {\\n        if (!is.null(corGrpsForm <- getGroupsFormula(correlation, asList = TRUE))) {\\n            corGrpsForm <- unlist(lapply(corGrpsForm, function(el) deparse(el[[2]])))\\n            corQ <- length(corGrpsForm)\\n            lmeGrpsForm <- unlist(lapply(splitFormula(groups), function(el) deparse(el[[2]])))\\n            lmeQ <- length(lmeGrpsForm)\\n            if (corQ <= lmeQ) {\\n                if (any(corGrpsForm != lmeGrpsForm[1:corQ])) {\\n                  stop(\"incompatible formulas for groups in \\\\\"random\\\\\" and \\\\\"correlation\\\\\"\")\\n                }\\n                if (corQ < lmeQ) {\\n                  warning(\"cannot use smaller level of grouping for \\\\\"correlation\\\\\" than for \\\\\"random\\\\\". Replacing the former with the latter.\")\\n                  frm <- paste(\"~\", c_deparse(getCovariateFormula(formula(correlation))[[2]]), \"|\", deparse(groups[[2]]))\\n                  attr(correlation, \"formula\") <- eval(parse(text = frm))\\n                }\\n            }\\n            else {\\n                if (any(lmeGrpsForm != corGrpsForm[1:lmeQ])) {\\n                  stop(\"incompatible formulas for groups in \\\\\"random\\\\\" and \\\\\"correlation\\\\\"\")\\n                }\\n            }\\n        }\\n        else {\\n            frm <- paste(\"~\", c_deparse(getCovariateFormula(formula(correlation))[[2]]), \"|\", deparse(groups[[2]]))\\n            attr(correlation, \"formula\") <- eval(parse(text = frm))\\n            corQ <- lmeQ <- 1\\n        }\\n    }\\n    else {\\n        corQ <- lmeQ <- 1\\n    }\\n    nlmeSt <- nlmeStruct(reStruct = reSt, corStruct = correlation, varStruct = varFunc(weights))\\n    mfArgs <- list(formula = asOneFormula(formula(nlmeSt), model, fixed, groups, omit = c(pnames, \"pi\")), data = data, na.action = na.action)\\n    if (!missing(subset)) {\\n        mfArgs[[\"subset\"]] <- asOneSidedFormula(Call[[\"subset\"]])[[2]]\\n    }\\n    mfArgs$drop.unused.levels <- TRUE\\n    dataMix <- do.call(model.frame, mfArgs)\\n    origOrder <- row.names(dataMix)\\n    grps <- getGroups(dataMix, eval(parse(text = paste(\"~1\", deparse(groups[[2]]), sep = \"|\"))))\\n    N <- dim(dataMix)[1]\\n    if (missing(naPattern)) \\n        naPat <- rep(TRUE, N)\\n    else naPat <- as.logical(eval(asOneSidedFormula(naPattern)[[2]], dataMix))\\n    origOrderShrunk <- origOrder[naPat]\\n    if (inherits(grps, \"factor\")) {\\n        ord <- order(grps)\\n        grps <- data.frame(grps)\\n        row.names(grps) <- origOrder\\n        names(grps) <- as.character(deparse((groups[[2]])))\\n    }\\n    else {\\n        ord <- do.call(order, grps)\\n        for (i in 2:ncol(grps)) {\\n            grps[, i] <- as.factor(paste(as.character(grps[, i - 1]), as.character(grps[, i]), sep = \"/\"))\\n        }\\n    }\\n    if (corQ > lmeQ) {\\n        ord <- do.call(order, getGroups(dataMix, getGroupsFormula(correlation)))\\n    }\\n    grps <- grps[ord, , drop = FALSE]\\n    dataMix <- dataMix[ord, , drop = FALSE]\\n    naPat <- naPat[ord]\\n    dataMixShrunk <- dataMix[naPat, , drop = FALSE]\\n    grpShrunk <- grps[naPat, , drop = FALSE]\\n    revOrderShrunk <- match(origOrderShrunk, row.names(dataMixShrunk))\\n    yShrunk <- eval(model[[2]], dataMixShrunk)\\n    contr <- list()\\n    plist <- vector(\"list\", length(pnames))\\n    names(plist) <- pnames\\n    for (nm in pnames) {\\n        this <- list(fixed = !is.null(fixed[[nm]]), random = as.list(lapply(ranForm, function(el, nm) !is.null(el[[nm]]), \\n            nm = nm)))\\n        if (this[[\"fixed\"]]) {\\n            if (fixed[[nm]][[3]] != \"1\") {\\n                as1F <- asOneSidedFormula(fixed[[nm]][[3]])\\n                this[[\"fixed\"]] <- model.matrix(as1F, model.frame(as1F, dataMix))\\n                auxContr <- attr(this[[\"fixed\"]], \"contrasts\")\\n                contr <- c(contr, auxContr[is.na(match(names(auxContr), names(contr)))])\\n            }\\n        }\\n        if (any(unlist(this[[\"random\"]]))) {\\n            for (i in 1:Q) {\\n                wch <- which(!is.na(match(rnames[[i]], nm)))\\n                if (length(wch) == 1) {\\n                  if ((rF.i <- ranForm[[i]][[nm]][[3]]) != \"1\") {\\n                    this[[\"random\"]][[i]] <- model.matrix(asOneSidedFormula(rF.i), model.frame(asOneSidedFormula(rF.i), dataMix))\\n                    auxContr <- attr(this[[\"random\"]][[i]], \"contrasts\")\\n                    contr <- c(contr, auxContr[is.na(match(names(auxContr), names(contr)))])\\n                  }\\n                }\\n                else if (length(wch) > 0) {\\n                  this[[\"random\"]][[i]] <- th.ran.i <- as.list(lapply(ranForm[[i]][wch], function(el, data) {\\n                    if (el[[3]] == \"1\") \\n                      TRUE\\n                    else model.matrix(asOneSidedFormula(el[[3]]), model.frame(asOneSidedFormula(el[[3]]), data))\\n                  }, data = dataMix))\\n                  for (j in seq_along(th.ran.i)) {\\n                    if (is.matrix(th.ran.i[[j]])) {\\n                      auxContr <- attr(th.ran.i[[j]], \"contrasts\")\\n                      contr <- c(contr, auxContr[is.na(match(names(auxContr), names(contr)))])\\n                    }\\n                  }\\n                }\\n            }\\n        }\\n        plist[[nm]] <- this\\n    }\\n    contrMat <- function(nm, contr, data) {\\n        x <- eval(parse(text = nm), data)\\n        levs <- levels(x)\\n        val <- do.call(contr[[nm]], list(n = length(levs)))\\n        rownames(val) <- levs\\n        val\\n    }\\n    nms <- names(contr)[sapply(contr, is.character)]\\n    contr[nms] <- lapply(nms, contrMat, contr = contr, data = dataMix)\\n    if (is.null(sfix <- start$fixed)) \\n        stop(\"'start' must have a component called 'fixed'\")\\n    fn <- character(0)\\n    currPos <- 0\\n    fixAssign <- list()\\n    for (nm in fnames) {\\n        if (is.logical(f <- plist[[nm]]$fixed)) {\\n            currPos <- currPos + 1\\n            currVal <- list(currPos)\\n            if (all(unlist(lapply(plist[[nm]]$random, is.logical)))) {\\n                fn <- c(fn, nm)\\n                names(currVal) <- nm\\n            }\\n            else {\\n                aux <- paste(nm, \"(Intercept)\", sep = \".\")\\n                fn <- c(fn, aux)\\n                names(currVal) <- aux\\n            }\\n            fixAssign <- c(fixAssign, currVal)\\n        }\\n        else {\\n            currVal <- attr(f, \"assign\")\\n            fTerms <- terms(asOneSidedFormula(fixed[[nm]][[3]]), data = data)\\n            namTerms <- attr(fTerms, \"term.labels\")\\n            if (attr(fTerms, \"intercept\") > 0) {\\n                namTerms <- c(\"(Intercept)\", namTerms)\\n            }\\n            namTerms <- factor(currVal, labels = namTerms)\\n            currVal <- split(order(currVal), namTerms)\\n            names(currVal) <- paste(nm, names(currVal), sep = \".\")\\n            fixAssign <- c(fixAssign, lapply(currVal, function(el) el + currPos))\\n            currPos <- currPos + length(unlist(currVal))\\n            fn <- c(fn, paste(nm, colnames(f), sep = \".\"))\\n        }\\n    }\\n    fLen <- length(fn)\\n    if (fLen == 0L || length(sfix) != fLen) \\n        stop(\"starting values for the 'fixed' component are not the correct length\")\\n    names(sfix) <- fn\\n    rn <- wchRnames <- vector(\"list\", Q)\\n    names(rn) <- names(wchRnames) <- namGrp\\n    for (i in 1:Q) {\\n        rn[[i]] <- character(0)\\n        uRnames <- unique(rnames[[i]])\\n        wchRnames[[i]] <- integer(length(uRnames))\\n        names(wchRnames[[i]]) <- uRnames\\n        for (j in seq_along(rnames[[i]])) {\\n            nm <- rnames[[i]][j]\\n            wchRnames[[i]][nm] <- wchRnames[[i]][nm] + 1\\n            r <- plist[[nm]]$random[[i]]\\n            if (data.class(r) == \"list\") \\n                r <- r[[wchRnames[[i]][nm]]]\\n            if (is.logical(r)) {\\n                if (r) {\\n                  rn[[i]] <- c(rn[[i]], if (is.logical(plist[[nm]]$fixed)) nm else paste(nm, \"(Intercept)\", sep = \".\"))\\n                }\\n            }\\n            else {\\n                rn[[i]] <- c(rn[[i]], paste(nm, colnames(r), sep = \".\"))\\n            }\\n        }\\n    }\\n    Names(nlmeSt$reStruct) <- rn\\n    rNam <- unlist(rn)\\n    rlength <- lengths(rn)\\n    rLen <- sum(rlength)\\n    pLen <- rLen + fLen\\n    ncols <- c(rlength, fLen, 1)\\n    Dims <- MEdims(grpShrunk, ncols)\\n    if (max(Dims$ZXlen[[1]]) < Dims$qvec[1]) {\\n        warning(gettextf(\"fewer observations than random effects in all level %s groups\", Q), domain = NA)\\n    }\\n    sran <- vector(\"list\", Q)\\n    names(sran) <- namGrp\\n    if (!is.null(sran0 <- start$random)) {\\n        if (inherits(sran0, \"data.frame\")) {\\n            sran0 <- list(as.matrix(sran0))\\n        }\\n        else {\\n            if (!is.list(sran0)) {\\n                if (!is.matrix(sran0)) {\\n                  stop(\"starting values for random effects should be a list, or a matrix\")\\n                }\\n                sran0 <- list(as.matrix(sran0))\\n            }\\n        }\\n        if (is.null(namSran <- names(sran0))) {\\n            if (length(sran) != Q) {\\n                stop(gettextf(\"list with starting values for random effects must have names or be of length %d\", Q), domain = NA)\\n            }\\n            names(sran0) <- rev(namGrp)\\n        }\\n        else {\\n            if (any(noMatch <- is.na(match(namSran, namGrp)))) {\\n                stop(sprintf(ngettext(sum(noMatch), \"group name not matched in starting values for random effects: %s\", \"group names not matched in starting values for random effects: %s\"), \\n                  paste(namSran[noMatch], collapse = \", \")), domain = NA)\\n            }\\n        }\\n    }\\n    for (i in 1:Q) {\\n        if (is.null(sran[[i]] <- sran0[[namGrp[i]]])) {\\n            sran[[i]] <- array(0, c(rlength[i], Dims$ngrps[i]), list(rn[[i]], unique(as.character(grps[, Q - i + 1]))))\\n        }\\n        else {\\n            if (!is.matrix(sran[[i]])) \\n                stop(\"starting values for the random components should be a list of matrices\")\\n            dimsran <- dim(sran[[i]])\\n            if (dimsran[1] != Dims$ngrps[i]) {\\n                stop(gettextf(\"number of rows in starting values for random component at level %s should be %d\", namGrp[i], \\n                  Dims$ngrps[i]), domain = NA)\\n            }\\n            if (dimsran[2] != rlength[i]) {\\n                stop(gettextf(\"number of columns in starting values for random component at level %s should be %d\", namGrp[i], \\n                  rlength[i]), domain = NA)\\n            }\\n            dnamesran <- dimnames(sran[[i]])\\n            if (is.null(dnamesran[[1]])) {\\n                stop(\"starting values for random effects must include group levels\")\\n            }\\n            else {\\n                levGrps <- unique(as.character(grps[, Q - i + 1]))\\n                if (!all(sort(dnamesran[[1]]) == sort(levGrps))) {\\n                  stop(gettextf(\"groups levels mismatch in 'random' and starting values for 'random' at level %s\", namGrp[i]), \\n                    domain = NA)\\n                }\\n                sran[[i]] <- sran[[i]][levGrps, , drop = FALSE]\\n            }\\n            if (!is.null(dnamesran[[2]])) {\\n                if (!all(sort(dnamesran[[2]]) == sort(rn[[i]]))) {\\n                  for (j in seq_len(rlength[i])) {\\n                    if (is.na(match(dnamesran[[2]][j], rn[[i]]))) {\\n                      if (!is.na(mDn <- match(paste(dnamesran[[2]][j], \"(Intercept)\", sep = \".\"), rn[[i]]))) {\\n                        dnamesran[[2]][j] <- rn[[i]][mDn]\\n                      }\\n                      else {\\n                        if (!is.na(mDn <- match(dnamesran[[2]][j], paste(rn[[i]], \"(Intercept)\", sep = \".\")))) {\\n                          dnamesran[[2]][j] <- rn[[i]][mDn]\\n                        }\\n                        else {\\n                          stop(gettextf(\"names mismatch in 'random' and starting values  for 'random' at level %s\", namGrp[i]), \\n                            domain = NA)\\n                        }\\n                      }\\n                    }\\n                  }\\n                  dimnames(sran[[i]]) <- dnamesran\\n                }\\n                sran[[i]] <- sran[[i]][, rn[[i]], drop = FALSE]\\n            }\\n            else {\\n                dimnames(sran[[i]])[[2]] <- rn[[i]]\\n            }\\n            sran[[i]] <- t(sran[[i]])\\n        }\\n    }\\n    names(sran) <- namGrp\\n    nPars <- length(unlist(sran)) + fLen\\n    NReal <- sum(naPat)\\n    fmap <- list()\\n    n1 <- 1\\n    for (nm in fnames) {\\n        if (is.logical(f <- plist[[nm]]$fixed)) {\\n            fmap[[nm]] <- n1\\n            n1 <- n1 + 1\\n        }\\n        else {\\n            fmap[[nm]] <- n1:(n1 + ncol(f) - 1)\\n            n1 <- n1 + ncol(f)\\n        }\\n    }\\n    rmap <- rmapRel <- vector(\"list\", Q)\\n    names(rmap) <- names(rmapRel) <- namGrp\\n    n1 <- 1\\n    startRan <- 0\\n    for (i in 1:Q) {\\n        wchRnames[[i]][] <- 0\\n        rmap[[i]] <- rmapRel[[i]] <- list()\\n        for (nm in rnames[[i]]) {\\n            wchRnames[[i]][nm] <- wchRnames[[i]][nm] + 1\\n            r <- plist[[nm]]$random[[i]]\\n            if (data.class(r) == \"list\") {\\n                r <- r[[wchRnames[[i]][nm]]]\\n            }\\n            if (is.logical(r)) {\\n                val <- n1\\n                n1 <- n1 + 1\\n            }\\n            else {\\n                val <- n1:(n1 + ncol(r) - 1)\\n                n1 <- n1 + ncol(r)\\n            }\\n            if (is.null(rmap[[i]][[nm]])) {\\n                rmap[[i]][[nm]] <- val\\n                rmapRel[[i]][[nm]] <- val - startRan\\n            }\\n            else {\\n                rmap[[i]][[nm]] <- c(rmap[[i]][[nm]], list(val))\\n                rmapRel[[i]][[nm]] <- c(rmapRel[[i]][[nm]], list(val - startRan))\\n            }\\n        }\\n        startRan <- startRan + ncols[i]\\n    }\\n    grpsRev <- rev(lapply(grps, as.character))\\n    bmap <- c(0, cumsum(unlist(lapply(sran, function(el) length(as.vector(el))))))\\n    nlEnv <- list2env(list(model = nlmeModel, data = dataMix, groups = grpsRev, plist = plist, beta = as.vector(sfix), bvec = unlist(sran), \\n        b = sran, X = array(0, c(N, fLen), list(NULL, fn)), Z = array(0, c(N, rLen), list(NULL, rNam)), fmap = fmap, rmap = rmap, \\n        rmapRel = rmapRel, bmap = bmap, level = Q, N = N, Q = Q, naPat = naPat, .parameters = c(\"bvec\", \"beta\"), finiteDiffGrad = finiteDiffGrad))\\n    modelExpression <- ~{\\n        pars <- getParsNlme(plist, fmap, rmapRel, bmap, groups, beta, bvec, b, level, N)\\n        res <- eval(model, data.frame(data, pars))\\n        if (!length(grad <- attr(res, \"gradient\"))) {\\n            grad <- finiteDiffGrad(model, data, pars)\\n        }\\n        for (nm in names(plist)) {\\n            gradnm <- grad[, nm]\\n            if (is.logical(f <- plist[[nm]]$fixed)) {\\n                if (f) \\n                  X[, fmap[[nm]]] <- gradnm\\n            }\\n            else X[, fmap[[nm]]] <- gradnm * f\\n            for (i in 1:Q) {\\n                if (is.logical(r <- plist[[nm]]$random[[i]])) {\\n                  if (r) \\n                    Z[, rmap[[i]][[nm]]] <- gradnm\\n                }\\n                else {\\n                  rm.i <- rmap[[i]][[nm]]\\n                  if (data.class(rm.i) != \"list\") {\\n                    Z[, rm.i] <- gradnm * r\\n                  }\\n                  else {\\n                    for (j in seq_along(rm.i)) {\\n                      Z[, rm.i[[j]]] <- if (is.logical(rr <- r[[j]])) \\n                        gradnm\\n                      else gradnm * rr\\n                    }\\n                  }\\n                }\\n            }\\n        }\\n        result <- c(Z[naPat, ], X[naPat, ], res[naPat])\\n        result[is.na(result)] <- 0\\n        result\\n    }\\n    modelResid <- ~eval(model, data.frame(data, getParsNlme(plist, fmap, rmapRel, bmap, groups, beta, bvec, b, level, N)))[naPat]\\n    ww <- eval(modelExpression[[2]], envir = nlEnv)\\n    w <- ww[NReal * pLen + (1:NReal)]\\n    ZX <- array(ww[1:(NReal * pLen)], c(NReal, pLen), list(row.names(dataMixShrunk), c(rNam, fn)))\\n    w <- w + as.vector(ZX[, rLen + (1:fLen), drop = FALSE] %*% sfix)\\n    if (!is.null(start$random)) {\\n        startRan <- 0\\n        for (i in 1:Q) {\\n            w <- w + as.vector((ZX[, startRan + 1:ncols[i], drop = FALSE] * t(sran[[i]])[as.character(grpShrunk[, Q - i + \\n                1]), , drop = FALSE]) %*% rep(1, ncols[i]))\\n            startRan <- startRan + ncols[i]\\n        }\\n    }\\n    attr(nlmeSt, \"conLin\") <- list(Xy = array(c(ZX, w), dim = c(NReal, sum(ncols)), dimnames = list(row.names(dataMixShrunk), \\n        c(colnames(ZX), deparse(model[[2]])))), dims = Dims, logLik = 0, sigma = controlvals$sigma, auxSigma = 0)\\n    attr(nlmeSt, \"resp\") <- yShrunk\\n    attr(nlmeSt, \"model\") <- modelResid\\n    attr(nlmeSt, \"local\") <- nlEnv\\n    attr(nlmeSt, \"NReal\") <- NReal\\n    nlmeSt <- Initialize(nlmeSt, dataMixShrunk, grpShrunk, control = controlvals)\\n    parMap <- attr(nlmeSt, \"pmap\")\\n    decomp <- length(coef(nlmeSt)) == length(coef(nlmeSt$reStruct)) && !needUpdate(nlmeSt)\\n    if (decomp) {\\n        oldConLin <- attr(nlmeSt, \"conLin\")\\n    }\\n    numIter <- 0\\n    pnlsSettings <- c(controlvals$pnlsMaxIter, controlvals$minScale, controlvals$pnlsTol, 0, 0, 0)\\n    nlModel <- nonlinModel(modelExpression, nlEnv)\\n    repeat {\\n        numIter <- numIter + 1\\n        if (needUpdate(nlmeSt)) {\\n            nlmeSt <- update(nlmeSt, dataMixShrunk)\\n        }\\n        if (decomp) {\\n            attr(nlmeSt, \"conLin\") <- MEdecomp(oldConLin)\\n        }\\n        oldPars <- coef(nlmeSt)\\n        if (controlvals$opt == \"nlminb\") {\\n            control <- list(trace = controlvals$msVerbose, iter.max = controlvals$msMaxIter)\\n            keep <- c(\"eval.max\", \"abs.tol\", \"rel.tol\", \"x.tol\", \"xf.tol\", \"step.min\", \"step.max\", \"sing.tol\", \"scale.init\", \\n                \"diff.g\")\\n            control <- c(control, controlvals[names(controlvals) %in% keep])\\n            optRes <- nlminb(c(coef(nlmeSt)), function(nlmePars) -logLik(nlmeSt, nlmePars), control = control)\\n            aConv <- coef(nlmeSt) <- optRes$par\\n            convIter <- optRes$iterations\\n            if (optRes$convergence && controlvals$msWarnNoConv) \\n                warning(paste(sprintf(\"Iteration %d, LME step: nlminb() did not converge (code = %d).\", numIter, optRes$convergence), \\n                  if (convIter >= control$iter.max) \\n                    \"Do increase 'msMaxIter'!\"\\n                  else if (!is.null(msg <- optRes$message)) \\n                    paste(\"PORT message:\", msg)))\\n        }\\n        else {\\n            aNlm <- nlm(f = function(nlmePars) -logLik(nlmeSt, nlmePars), p = c(coef(nlmeSt)), hessian = TRUE, print.level = controlvals$msVerbose, \\n                gradtol = if (numIter == 1) \\n                  controlvals$msTol\\n                else 100 * .Machine$double.eps, iterlim = if (numIter < 10) \\n                  10\\n                else controlvals$msMaxIter, check.analyticals = FALSE)\\n            aConv <- coef(nlmeSt) <- aNlm$estimate\\n            convIter <- aNlm$iterations\\n            if (aNlm$code > 2 && controlvals$msWarnNoConv) \\n                warning(paste(sprintf(\"Iteration %d, LME step: nlm() did not converge (code = %d).\", numIter, aNlm$code), \\n                  if (aNlm$code == 4) \\n                    \"Do increase 'msMaxIter'!\"))\\n        }\\n        nlmeFit <- attr(nlmeSt, \"lmeFit\") <- MEestimate(nlmeSt, grpShrunk)\\n        if (verbose) {\\n            cat(\"\\\\n**Iteration\", numIter)\\n            cat(sprintf(\"\\\\nLME step: Loglik: %s, %s iterations: %d\\\\n\", format(nlmeFit$logLik), controlvals$opt, convIter))\\n            print(nlmeSt)\\n        }\\n        if (is.null(correlation)) {\\n            cF <- 1\\n            cD <- 1\\n        }\\n        else {\\n            cF <- corFactor(nlmeSt$corStruct)\\n            cD <- Dim(nlmeSt$corStruct)\\n        }\\n        vW <- if (is.null(weights)) \\n            1\\n        else varWeights(nlmeSt$varStruct)\\n        if (verbose) \\n            cat(\" Beginning PNLS step: .. \")\\n        work <- .C(fit_nlme, thetaPNLS = as.double(c(as.vector(unlist(sran)), sfix)), pdFactor = as.double(pdFactor(nlmeSt$reStruct)), \\n            as.integer(unlist(rev(grpShrunk))), as.integer(unlist(Dims)), as.integer(attr(nlmeSt$reStruct, \"settings\"))[-(1:3)], \\n            as.double(cF), as.double(vW), as.integer(unlist(cD)), settings = as.double(pnlsSettings), additional = double(NReal * \\n                (pLen + 1)), as.integer(!is.null(correlation)), as.integer(!is.null(weights)), as.double(controlvals$sigma), \\n            nlModel, NAOK = TRUE)\\n        if (verbose) \\n            cat(\" completed fit_nlme() step.\\\\n\")\\n        if (work$settings[4] == 1) {\\n            msg <- \"step halving factor reduced below minimum in PNLS step\"\\n            if (controlvals$returnObject) \\n                warning(msg)\\n            else stop(msg)\\n        }\\n        i.pdF <- 1\\n        for (i in seq_along(nlmeSt$reStruct)) {\\n            d.i <- dim(pdMatrix(nlmeSt$reStruct[[i]]))\\n            ni.pdF <- i.pdF + prod(d.i)\\n            pdF <- array(work$pdFactor[i.pdF:(ni.pdF - 1)], dim = d.i)\\n            matrix(nlmeSt$reStruct[[i]]) <- crossprod(pdF)\\n            i.pdF <- ni.pdF\\n        }\\n        oldPars <- c(sfix, oldPars)\\n        for (i in 1:Q) sran[[i]][] <- work$thetaPNLS[(bmap[i] + 1):bmap[i + 1]]\\n        sfix[] <- work$thetaPNLS[nPars + 1 - (fLen:1)]\\n        if (verbose) {\\n            cat(\"PNLS step: RSS = \", format(work$settings[6]), \"\\\\n fixed effects: \")\\n            for (i in 1:fLen) cat(format(sfix[i]), \" \")\\n            cat(\"\\\\n iterations:\", work$settings[5], \"\\\\n\")\\n        }\\n        aConv <- c(sfix, coef(nlmeSt))\\n        w[] <- work$additional[(NReal * pLen) + 1:NReal]\\n        ZX[] <- work$additional[1:(NReal * pLen)]\\n        w <- w + as.vector(ZX[, rLen + (1:fLen), drop = FALSE] %*% sfix)\\n        startRan <- 0\\n        for (i in 1:Q) {\\n            gr.i <- as.character(grpShrunk[, Q - i + 1])\\n            w <- w + as.vector((ZX[, startRan + 1:ncols[i], drop = FALSE] * t(sran[[i]])[gr.i, , drop = FALSE]) %*% rep(1, \\n                ncols[i]))\\n            startRan <- startRan + ncols[i]\\n        }\\n        if (decomp) {\\n            oldConLin$Xy[] <- c(ZX, w)\\n            oldConLin$logLik <- 0\\n        }\\n        else {\\n            attr(nlmeSt, \"conLin\")$Xy[] <- c(ZX, w)\\n            attr(nlmeSt, \"conLin\")$logLik <- 0\\n        }\\n        conv <- abs((oldPars - aConv)/ifelse(abs(aConv) < controlvals$tolerance, 1, aConv))\\n        aConv <- c(fixed = max(conv[1:fLen]))\\n        conv <- conv[-(1:fLen)]\\n        for (i in names(nlmeSt)) {\\n            if (any(parMap[, i])) {\\n                aConv <- c(aConv, max(conv[parMap[, i]]))\\n                names(aConv)[length(aConv)] <- i\\n            }\\n        }\\n        if (verbose) {\\n            cat(sprintf(\"Convergence crit. (must all become <= tolerance = %g):\\\\n\", controlvals$tolerance))\\n            print(aConv)\\n        }\\n        if ((max(aConv) <= controlvals$tolerance) || (aConv[\"fixed\"] <= controlvals$tolerance && convIter == 1)) {\\n            break\\n        }\\n        if (numIter >= controlvals$maxIter) {\\n            msg <- gettextf(\"maximum number of iterations (maxIter = %d) reached without convergence\", controlvals$maxIter)\\n            if (controlvals$returnObject) {\\n                warning(msg, domain = NA)\\n                break\\n            }\\n            else stop(msg, domain = NA)\\n        }\\n    }\\n    nlmeFit <- if (decomp) \\n        MEestimate(nlmeSt, grpShrunk, oldConLin)\\n    else MEestimate(nlmeSt, grpShrunk)\\n    fixDF <- getFixDF(ZX[, rLen + (1:fLen), drop = FALSE], grpShrunk, attr(nlmeSt, \"conLin\")$dims$ngrps, fixAssign)\\n    attr(fixDF, \"varFixFact\") <- varFix <- nlmeFit$sigma * nlmeFit$varFix\\n    varFix <- crossprod(varFix)\\n    dimnames(varFix) <- list(fn, fn)\\n    Resid <- if (decomp) \\n        resid(nlmeSt, level = 0:Q, oldConLin)[revOrderShrunk, ]\\n    else resid(nlmeSt, level = 0:Q)[revOrderShrunk, ]\\n    Fitted <- yShrunk[revOrderShrunk] - Resid\\n    rownames(Resid) <- rownames(Fitted) <- origOrderShrunk\\n    grpShrunk <- grpShrunk[revOrderShrunk, , drop = FALSE]\\n    attr(Resid, \"std\") <- nlmeFit$sigma/(varWeights(nlmeSt)[revOrderShrunk])\\n    nlmeSt$reStruct <- solve(nlmeSt$reStruct)\\n    attr(nlmeSt, \"fixedSigma\") <- (controlvals$sigma > 0)\\n    dims <- attr(nlmeSt, \"conLin\")$dims[c(\"N\", \"Q\", \"qvec\", \"ngrps\", \"ncol\")]\\n    apVar <- if (controlvals$apVar) \\n        lmeApVar(nlmeSt, nlmeFit$sigma, .relStep = controlvals[[\".relStep\"]], minAbsPar = controlvals[[\"minAbsParApVar\"]], \\n            natural = controlvals[[\"natural\"]])\\n    else \"Approximate variance-covariance matrix not available\"\\n    sran <- lapply(sran, t)\\n    attributes(nlmeSt) <- attributes(nlmeSt)[c(\"names\", \"class\", \"pmap\", \"fixedSigma\")]\\n    isGrpd <- inherits(data, \"groupedData\")\\n    structure(class = c(\"nlme\", \"lme\"), list(modelStruct = nlmeSt, dims = dims, contrasts = contr, coefficients = list(fixed = sfix, \\n        random = rev(sran)), varFix = varFix, sigma = nlmeFit$sigma, apVar = apVar, logLik = nlmeFit$logLik, numIter = numIter, \\n        groups = grpShrunk, call = Call, method = method, fitted = Fitted, residuals = Resid, plist = plist, map = list(fmap = fmap, \\n            rmap = rmap, rmapRel = rmapRel, bmap = bmap), fixDF = fixDF), units = if (isGrpd) \\n        attr(data, \"units\"), labels = if (isGrpd) \\n        attr(data, \"labels\"))\\n}","2":"3"},{"1":"gam.s","2":"3"},{"1":"get.centers","2":"3"},{"1":"ggplotly","2":"3"},{"1":"gnls","2":"3"},{"1":"hessdet","2":"3"},{"1":"igraph::distances","2":"3"},{"1":"imappend","2":"3"},{"1":"imchange","2":"3"},{"1":"imrotate","2":"3"},{"1":"imsub","2":"3"},{"1":"integer","2":"3"},{"1":"irnorm","2":"3"},{"1":"is.numeric","2":"3"},{"1":"iter","2":"3"},{"1":"lines","2":"3"},{"1":"list.filter","2":"3"},{"1":"list.group","2":"3"},{"1":"load.image","2":"3"},{"1":"m","2":"3"},{"1":"make_empty_graph","2":"3"},{"1":"medianblur","2":"3"},{"1":"model.frame.default","2":"3"},{"1":"nlmer","2":"3"},{"1":"noNA","2":"3"},{"1":"order_by","2":"3"},{"1":"ordinal","2":"3"},{"1":"output","2":"3"},{"1":"prcomp","2":"3"},{"1":"purrr::map_df","2":"3"},{"1":"px.circle","2":"3"},{"1":"px.square","2":"3"},{"1":"quantile","2":"3"},{"1":"R","2":"3"},{"1":"ranef","2":"3"},{"1":"rbinom","2":"3"},{"1":"read_extension_mappings","2":"3"},{"1":"read_sf","2":"3"},{"1":"rename_loc","2":"3"},{"1":"rgb","2":"3"},{"1":"rma","2":"3"},{"1":"rowid","2":"3"},{"1":"rqres","2":"3"},{"1":"Sys.time","2":"3"},{"1":"tidy","2":"3"},{"1":"time","2":"3"},{"1":"toupper","2":"3"},{"1":"tstrsplit","2":"3"},{"1":"var","2":"3"},{"1":"vec_as_names","2":"3"},{"1":"vec_as_subscript2","2":"3"},{"1":"vec_c","2":"3"},{"1":"vec_ptype_show","2":"3"},{"1":"vec_recycle","2":"3"},{"1":"vec_shape2","2":"3"},{"1":"where","2":"3"},{"1":"wishart","2":"3"},{"1":"with_options","2":"3"},{"1":"write.table","2":"3"},{"1":".paste_colnames","2":"2"},{"1":".PlotMass","2":"2"},{"1":".S.","2":"2"},{"1":"[[<-","2":"2"},{"1":"[<-","2":"2"},{"1":"%has_args%","2":"2"},{"1":"%pin%","2":"2"},{"1":"add.colour","2":"2"},{"1":"adorn_totals","2":"2"},{"1":"array_tree","2":"2"},{"1":"as.array","2":"2"},{"1":"as.bigz","2":"2"},{"1":"as.double","2":"2"},{"1":"as.IDate","2":"2"},{"1":"as.igraph","2":"2"},{"1":"as.logical","2":"2"},{"1":"as.POSIXct","2":"2"},{"1":"as.symbol","2":"2"},{"1":"assert_is_identical_to_na","2":"2"},{"1":"average","2":"2"},{"1":"bake","2":"2"},{"1":"boxblur","2":"2"},{"1":"caller","2":"2"},{"1":"cdensV","2":"2"},{"1":"center.stencil","2":"2"},{"1":"channel","2":"2"},{"1":"checkMatrix","2":"2"},{"1":"close","2":"2"},{"1":"coalesce","2":"2"},{"1":"combine","2":"2"},{"1":"contr.treatment","2":"2"},{"1":"convert","2":"2"},{"1":"corpus_subset","2":"2"},{"1":"correlate","2":"2"},{"1":"cross","2":"2"},{"1":"data.table","2":"2"},{"1":"DBI::dbDisconnect","2":"2"},{"1":"dfm_select","2":"2"},{"1":"diag","2":"2"},{"1":"do_call","2":"2"},{"1":"dplyr:::check_pkg","2":"2"},{"1":"dplyr::group_by","2":"2"},{"1":"draw_circle","2":"2"},{"1":"E","2":"2"},{"1":"ergm:::InitErgmConstraint.b1degrees","2":"2"},{"1":"ergm:::InitErgmConstraint.b2degrees","2":"2"},{"1":"ergm:::InitErgmConstraint.bd","2":"2"},{"1":"ergm:::InitErgmConstraint.idegrees","2":"2"},{"1":"ergm:::InitErgmConstraint.odegrees","2":"2"},{"1":"ergm:::InitErgmReference.StdNormal","2":"2"},{"1":"ergm:::InitErgmTerm.cycle","2":"2"},{"1":"ergm:::InitErgmTerm.gwdsp","2":"2"},{"1":"ergm:::InitErgmTerm.isolates","2":"2"},{"1":"ergm:::InitWtErgmTerm.mm","2":"2"},{"1":"ergm:::InitWtErgmTerm.mutual","2":"2"},{"1":"expect_usethis_error","2":"2"},{"1":"expr","2":"2"},{"1":"fct_relevel","2":"2"},{"1":"fivenum","2":"2"},{"1":"flatten.alpha","2":"2"},{"1":"forecast.ts","2":"2"},{"1":"function (x, ...) \\nUseMethod(\"DunnettTest\")","2":"2"},{"1":"function (x, ...) \\nUseMethod(\"NemenyiTest\")","2":"2"},{"1":"funs","2":"2"},{"1":"g","2":"2"},{"1":"gam.control","2":"2"},{"1":"get_parse_data","2":"2"},{"1":"get_selection","2":"2"},{"1":"greens","2":"2"},{"1":"grouped_df","2":"2"},{"1":"haar","2":"2"},{"1":"has_error","2":"2"},{"1":"icons","2":"2"},{"1":"imdirac","2":"2"},{"1":"imlist","2":"2"},{"1":"imnoise","2":"2"},{"1":"INT","2":"2"},{"1":"is_odd","2":"2"},{"1":"is.nan","2":"2"},{"1":"is.number","2":"2"},{"1":"is.readable","2":"2"},{"1":"is.scalar","2":"2"},{"1":"jitter","2":"2"},{"1":"kdist","2":"2"},{"1":"knitr::opts_chunk$set","2":"2"},{"1":"lavaan::lavaanList","2":"2"},{"1":"lead","2":"2"},{"1":"levgamma","2":"2"},{"1":"list.search","2":"2"},{"1":"log10","2":"2"},{"1":"ls","2":"2"},{"1":"lst","2":"2"},{"1":"make_","2":"2"},{"1":"mapview","2":"2"},{"1":"maxLik","2":"2"},{"1":"mirror","2":"2"},{"1":"mlogit","2":"2"},{"1":"mstl","2":"2"},{"1":"mult","2":"2"},{"1":"mutate_all","2":"2"},{"1":"na_if","2":"2"},{"1":"network","2":"2"},{"1":"new_grouped_df","2":"2"},{"1":"nlme::nmGroupedData","2":"2"},{"1":"npregbw","2":"2"},{"1":"NROW","2":"2"},{"1":"ordered","2":"2"},{"1":"p","2":"2"},{"1":"pal","2":"2"},{"1":"par","2":"2"},{"1":"parmin","2":"2"},{"1":"parse_transform_serialize_roxygen","2":"2"},{"1":"parseDouble","2":"2"},{"1":"pillar_shaft","2":"2"},{"1":"post_visit","2":"2"},{"1":"ppareto","2":"2"},{"1":"ppc_group_data","2":"2"},{"1":"prod","2":"2"},{"1":"profile.rma.mv","2":"2"},{"1":"px.borders","2":"2"},{"1":"px.flood","2":"2"},{"1":"px.left","2":"2"},{"1":"RdYlBu","2":"2"},{"1":"read_html","2":"2"},{"1":"read_xml","2":"2"},{"1":"read.csv","2":"2"},{"1":"resid1plot","2":"2"},{"1":"RGBtoHSV","2":"2"},{"1":"rma.glmm","2":"2"},{"1":"rotate","2":"2"},{"1":"rotate_xy","2":"2"},{"1":"rownames","2":"2"},{"1":"rstan::stanc_builder","2":"2"},{"1":"sample_gnp","2":"2"},{"1":"sd","2":"2"},{"1":"sessionInfo","2":"2"},{"1":"setwd","2":"2"},{"1":"shear","2":"2"},{"1":"signature","2":"2"},{"1":"simVEV","2":"2"},{"1":"slice","2":"2"},{"1":"SomeFunction","2":"2"},{"1":"spread","2":"2"},{"1":"sprintf","2":"2"},{"1":"src_df","2":"2"},{"1":"src_memdb","2":"2"},{"1":"sRGBtoRGB","2":"2"},{"1":"st_as_sfc","2":"2"},{"1":"st_join","2":"2"},{"1":"st_multipoint","2":"2"},{"1":"st_overlaps","2":"2"},{"1":"Str","2":"2"},{"1":"stringr::str_split","2":"2"},{"1":"svychisq","2":"2"},{"1":"table","2":"2"},{"1":"tbl_graph","2":"2"},{"1":"tbl_if_vars","2":"2"},{"1":"tidyr::complete","2":"2"},{"1":"timeout","2":"2"},{"1":"tokenize","2":"2"},{"1":"translate","2":"2"},{"1":"tryGet","2":"2"},{"1":"uniqueN","2":"2"},{"1":"V","2":"2"},{"1":"vec_ptype_common_df_fallback","2":"2"},{"1":"vec_ptype2_fallback","2":"2"},{"1":"wb","2":"2"},{"1":".amardillo_multithreaded","2":"1"},{"1":".collapse","2":"1"},{"1":".eta_progress_bar","2":"1"},{"1":".inc","2":"1"},{"1":".test_multithreaded","2":"1"},{"1":".test_sequential","2":"1"},{"1":"(function() {\\n    b\\n})","2":"1"},{"1":"&&","2":"1"},{"1":"%ain%","2":"1"},{"1":"%flike%","2":"1"},{"1":"%has_name%","2":"1"},{"1":"%ilike%","2":"1"},{"1":"%is%","2":"1"},{"1":"across","2":"1"},{"1":"add","2":"1"},{"1":"addConfidences","2":"1"},{"1":"addVo","2":"1"},{"1":"adorn_title","2":"1"},{"1":"all_exprs","2":"1"},{"1":"any_exprs","2":"1"},{"1":"as.bigq","2":"1"},{"1":"as.data.table","2":"1"},{"1":"as.Date","2":"1"},{"1":"as.pairlist","2":"1"},{"1":"as.pixset","2":"1"},{"1":"as.raw","2":"1"},{"1":"assert_all_are_false","2":"1"},{"1":"assert_all_are_na","2":"1"},{"1":"assert_all_are_true","2":"1"},{"1":"assert_are_identical","2":"1"},{"1":"assert_is_identical_to_false","2":"1"},{"1":"base_order","2":"1"},{"1":"bbox","2":"1"},{"1":"bigsample.default","2":"1"},{"1":"bind_edges","2":"1"},{"1":"blur_anisotropic","2":"1"},{"1":"boxblur_xy","2":"1"},{"1":"bquote","2":"1"},{"1":"bucketfill","2":"1"},{"1":"c_across","2":"1"},{"1":"call_and_name","2":"1"},{"1":"cdensEVI","2":"1"},{"1":"cdf.lms.bcn","2":"1"},{"1":"checkDataFrame","2":"1"},{"1":"checkInteger","2":"1"},{"1":"clean_empty_dir","2":"1"},{"1":"coerce_to","2":"1"},{"1":"column_to_rownames","2":"1"},{"1":"convert.im.toPNG","2":"1"},{"1":"convolve","2":"1"},{"1":"copy_to","2":"1"},{"1":"create_complete","2":"1"},{"1":"create_lattice","2":"1"},{"1":"create_star","2":"1"},{"1":"crop.bbox","2":"1"},{"1":"cross2","2":"1"},{"1":"cumsum","2":"1"},{"1":"cur_column","2":"1"},{"1":"cur_data","2":"1"},{"1":"cur_group","2":"1"},{"1":"cur_group_id","2":"1"},{"1":"cur_group_rows","2":"1"},{"1":"D1$add_me","2":"1"},{"1":"data_frame","2":"1"},{"1":"dbReadTable","2":"1"},{"1":"delayedAssign","2":"1"},{"1":"delete_vertices","2":"1"},{"1":"desc$add_me","2":"1"},{"1":"dfm_tfidf","2":"1"},{"1":"dfm_trim","2":"1"},{"1":"disjoint_union","2":"1"},{"1":"dist","2":"1"},{"1":"distance_transform","2":"1"},{"1":"dLO","2":"1"},{"1":"double","2":"1"},{"1":"doubleValue","2":"1"},{"1":"dPE","2":"1"},{"1":"draw_rect","2":"1"},{"1":"draw_text","2":"1"},{"1":"dTF","2":"1"},{"1":"ergm:::InitErgmProposal.CondB1Degree","2":"1"},{"1":"ergm:::InitErgmProposal.CondB2Degree","2":"1"},{"1":"ergm:::InitErgmProposal.CondInDegree","2":"1"},{"1":"ergm:::InitErgmProposal.CondOutDegree","2":"1"},{"1":"ergm:::InitErgmTerm.coincidence","2":"1"},{"1":"ergm:::InitErgmTerm.gwnsp","2":"1"},{"1":"ergm:::InitErgmTerm.indices","2":"1"},{"1":"expand_grid","2":"1"},{"1":"expect_message","2":"1"},{"1":"file.create","2":"1"},{"1":"fill","2":"1"},{"1":"filter_all","2":"1"},{"1":"filter_if","2":"1"},{"1":"fix_border_issues","2":"1"},{"1":"fn$sapply","2":"1"},{"1":"foo","2":"1"},{"1":"formula","2":"1"},{"1":"fpar","2":"1"},{"1":"function (dat, g = 1, gmode = \"digraph\", diag = FALSE, label = NULL, coord = NULL, jitter = TRUE, thresh = 0, thresh.absval = TRUE, \\n    usearrows = TRUE, mode = \"fruchtermanreingold\", displayisolates = TRUE, interactive = FALSE, interact.bycomp = FALSE, \\n    xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, pad = 0.2, label.pad = 0.5, displaylabels = !is.null(label), boxed.labels = FALSE, \\n    label.pos = 0, label.bg = \"white\", vertex.enclose = FALSE, vertex.sides = NULL, vertex.rot = 0, arrowhead.cex = 1, label.cex = 1, \\n    loop.cex = 1, vertex.cex = 1, edge.col = 1, label.col = 1, vertex.col = NULL, label.border = 1, vertex.border = 1, edge.lty = NULL, \\n    edge.lty.neg = 2, label.lty = NULL, vertex.lty = 1, edge.lwd = 0, label.lwd = par(\"lwd\"), edge.len = 0.5, edge.curve = 0.1, \\n    edge.steps = 50, loop.steps = 20, object.scale = 0.01, uselen = FALSE, usecurve = FALSE, suppress.axes = TRUE, vertices.last = TRUE, \\n    new = TRUE, layout.par = NULL, ...) \\n{\\n    bellstate <- options()$locatorBell\\n    expstate <- options()$expression\\n    on.exit(options(locatorBell = bellstate, expression = expstate))\\n    options(locatorBell = FALSE, expression = Inf)\\n    \"%iin%\" <- function(x, int) (x >= int[1]) & (x <= int[2])\\n    d <- as.edgelist.sna(dat, force.bipartite = (gmode == \"twomode\"))\\n    if (is.list(d)) \\n        d <- d[[g]]\\n    n <- attr(d, \"n\")\\n    if (is.null(label)) {\\n        if (displaylabels != TRUE) \\n            displaylabels <- FALSE\\n        if (!is.null(attr(d, \"vnames\"))) \\n            label <- attr(d, \"vnames\")\\n        else if ((gmode == \"twomode\") && (!is.null(attr(d, \"bipartite\")))) \\n            label <- c(paste(\"R\", 1:attr(d, \"bipartite\"), sep = \"\"), paste(\"C\", (attr(d, \"bipartite\") + 1):n, sep = \"\"))\\n        else {\\n            label <- 1:n\\n        }\\n    }\\n    if (gmode == \"graph\") {\\n        usearrows <- FALSE\\n    }\\n    else if ((gmode == \"twomode\") && (!is.null(attr(d, \"bipartite\")))) {\\n        Rn <- attr(d, \"bipartite\")\\n        if (is.null(vertex.col)) \\n            vertex.col <- c(rep(2, Rn), rep(4, n - Rn))\\n        if (is.null(vertex.sides)) \\n            vertex.sides <- c(rep(50, Rn), rep(4, n - Rn))\\n    }\\n    if (is.null(vertex.col)) \\n        vertex.col <- 2\\n    if (is.null(vertex.sides)) \\n        vertex.sides <- 50\\n    d <- d[!is.na(d[, 3]), , drop = FALSE]\\n    if (is.null(edge.lty)) {\\n        edge.lty <- rep(1, NROW(d))\\n        if (!is.null(edge.lty.neg)) \\n            edge.lty[d[, 3] < 0] <- edge.lty.neg\\n    }\\n    else {\\n        if (length(edge.lty) != NROW(d)) {\\n            edge.lty <- rep(edge.lty, NROW(d))\\n            if (!is.null(edge.lty.neg)) \\n                edge.lty[d[, 3] < 0] <- edge.lty.neg\\n        }\\n        else {\\n            if (!is.null(edge.lty.neg)) \\n                edge.lty[d[, 3] < 0] <- edge.lty.neg\\n        }\\n    }\\n    d.raw <- d\\n    if (thresh.absval) \\n        d <- d[abs(d[, 3]) > thresh, , drop = FALSE]\\n    else d <- d[d[, 3] > thresh, , drop = FALSE]\\n    attr(d, \"n\") <- n\\n    if (!is.null(coord)) {\\n        x <- coord[, 1]\\n        y <- coord[, 2]\\n    }\\n    else {\\n        layout.fun <- try(match.fun(paste(\"gplot.layout.\", mode, sep = \"\")), silent = TRUE)\\n        if (inherits(layout.fun, \"try-error\")) \\n            stop(\"Error in gplot: no layout function for mode \", mode)\\n        temp <- layout.fun(d, layout.par)\\n        x <- temp[, 1]\\n        y <- temp[, 2]\\n    }\\n    if (jitter) {\\n        x <- jitter(x)\\n        y <- jitter(y)\\n    }\\n    use <- displayisolates | (!is.isolate(d, ego = 1:n))\\n    if (is.null(xlab)) \\n        xlab = \"\"\\n    if (is.null(ylab)) \\n        ylab = \"\"\\n    if (is.null(xlim)) \\n        xlim <- c(min(x[use]) - pad, max(x[use]) + pad)\\n    if (is.null(ylim)) \\n        ylim <- c(min(y[use]) - pad, max(y[use]) + pad)\\n    xrng <- diff(xlim)\\n    yrng <- diff(ylim)\\n    xctr <- (xlim[2] + xlim[1])/2\\n    yctr <- (ylim[2] + ylim[1])/2\\n    if (xrng < yrng) \\n        xlim <- c(xctr - yrng/2, xctr + yrng/2)\\n    else ylim <- c(yctr - xrng/2, yctr + xrng/2)\\n    baserad <- min(diff(xlim), diff(ylim)) * object.scale * 16/(4 + n^(1/2))\\n    if (new) {\\n        plot(0, 0, xlim = xlim, ylim = ylim, type = \"n\", xlab = xlab, ylab = ylab, asp = 1, axes = !suppress.axes, ...)\\n    }\\n    vertex.cex <- rep(vertex.cex, length = n)\\n    vertex.radius <- rep(baserad * vertex.cex, length = n)\\n    vertex.sides <- rep(vertex.sides, length = n)\\n    vertex.border <- rep(vertex.border, length = n)\\n    vertex.col <- rep(vertex.col, length = n)\\n    vertex.lty <- rep(vertex.lty, length = n)\\n    vertex.rot <- rep(vertex.rot, length = n)\\n    loop.cex <- rep(loop.cex, length = n)\\n    label.bg <- rep(label.bg, length = n)\\n    label.border <- rep(label.border, length = n)\\n    if (!is.null(label.lty)) {\\n        label.lty <- rep(label.lty, length = n)\\n    }\\n    label.lwd <- rep(label.lwd, length = n)\\n    label.col <- rep(label.col, length = n)\\n    label.cex <- rep(label.cex, length = n)\\n    if (!vertices.last) {\\n        if (vertex.enclose) \\n            gplot.vertex(x[use], y[use], radius = vertex.radius[use], sides = 50, col = \"#FFFFFFFF\", border = vertex.border[use], \\n                lty = vertex.lty[use])\\n        gplot.vertex(x[use], y[use], radius = vertex.radius[use], sides = vertex.sides[use], col = vertex.col[use], border = vertex.border[use], \\n            lty = vertex.lty[use], rot = vertex.rot[use])\\n    }\\n    px0 <- vector()\\n    py0 <- vector()\\n    px1 <- vector()\\n    py1 <- vector()\\n    e.lwd <- vector()\\n    e.curv <- vector()\\n    e.type <- vector()\\n    e.col <- vector()\\n    e.hoff <- vector()\\n    e.toff <- vector()\\n    e.diag <- vector()\\n    e.rad <- vector()\\n    if (NROW(d) > 0) {\\n        if (length(dim(edge.col)) == 2) \\n            edge.col <- edge.col[d[, 1:2]]\\n        else edge.col <- rep(edge.col, length = NROW(d))\\n        if (length(dim(edge.lty)) == 2) \\n            edge.lty <- edge.lty[d[, 1:2]]\\n        else edge.lty <- rep(edge.lty, length = NROW(d))\\n        if (length(dim(edge.lwd)) == 2) {\\n            edge.lwd <- edge.lwd[d[, 1:2]]\\n            e.lwd.as.mult <- FALSE\\n        }\\n        else {\\n            if (length(edge.lwd) == 1) \\n                e.lwd.as.mult <- TRUE\\n            else e.lwd.as.mult <- FALSE\\n            edge.lwd <- rep(edge.lwd, length = NROW(d))\\n        }\\n        if (!is.null(edge.curve)) {\\n            if (length(dim(edge.curve)) == 2) {\\n                edge.curve <- edge.curve[d[, 1:2]]\\n                e.curv.as.mult <- FALSE\\n            }\\n            else {\\n                if (length(edge.curve) == 1) \\n                  e.curv.as.mult <- TRUE\\n                else e.curv.as.mult <- FALSE\\n                edge.curve <- rep(edge.curve, length = NROW(d))\\n            }\\n        }\\n        else edge.curve <- rep(0, length = NROW(d))\\n        dist <- ((x[d[, 1]] - x[d[, 2]])^2 + (y[d[, 1]] - y[d[, 2]])^2)^0.5\\n        tl <- d * dist\\n        tl.max <- max(tl)\\n        for (i in 1:NROW(d)) if (use[d[i, 1]] && use[d[i, 2]]) {\\n            px0 <- c(px0, as.double(x[d[i, 1]]))\\n            py0 <- c(py0, as.double(y[d[i, 1]]))\\n            px1 <- c(px1, as.double(x[d[i, 2]]))\\n            py1 <- c(py1, as.double(y[d[i, 2]]))\\n            e.toff <- c(e.toff, vertex.radius[d[i, 1]])\\n            e.hoff <- c(e.hoff, vertex.radius[d[i, 2]])\\n            e.col <- c(e.col, edge.col[i])\\n            e.type <- c(e.type, edge.lty[i])\\n            if (edge.lwd[i] > 0) {\\n                if (e.lwd.as.mult) \\n                  e.lwd <- c(e.lwd, edge.lwd[i] * d.raw[i, 3])\\n                else e.lwd <- c(e.lwd, edge.lwd[i])\\n            }\\n            else e.lwd <- c(e.lwd, 1)\\n            e.diag <- c(e.diag, d[i, 1] == d[i, 2])\\n            e.rad <- c(e.rad, vertex.radius[d[i, 1]] * loop.cex[d[i, 1]])\\n            if (uselen) {\\n                if (tl[i] > 0) {\\n                  e.len <- dist[i] * tl.max/tl[i]\\n                  e.curv <- c(e.curv, edge.len * sqrt((e.len/2)^2 - (dist[i]/2)^2))\\n                }\\n                else {\\n                  e.curv <- c(e.curv, 0)\\n                }\\n            }\\n            else {\\n                if (e.curv.as.mult) \\n                  e.curv <- c(e.curv, edge.curve[i] * dist[i])\\n                else e.curv <- c(e.curv, edge.curve[i])\\n            }\\n        }\\n    }\\n    if (diag && (length(px0) > 0) && sum(e.diag > 0)) {\\n        gplot.loop(as.vector(px0)[e.diag], as.vector(py0)[e.diag], length = 1.5 * baserad * arrowhead.cex, angle = 25, width = e.lwd[e.diag] * \\n            baserad/10, col = e.col[e.diag], border = e.col[e.diag], lty = e.type[e.diag], offset = e.hoff[e.diag], edge.steps = loop.steps, \\n            radius = e.rad[e.diag], arrowhead = usearrows, xctr = mean(x[use]), yctr = mean(y[use]))\\n    }\\n    if (length(px0) > 0) {\\n        px0 <- px0[!e.diag]\\n        py0 <- py0[!e.diag]\\n        px1 <- px1[!e.diag]\\n        py1 <- py1[!e.diag]\\n        e.curv <- e.curv[!e.diag]\\n        e.lwd <- e.lwd[!e.diag]\\n        e.type <- e.type[!e.diag]\\n        e.col <- e.col[!e.diag]\\n        e.hoff <- e.hoff[!e.diag]\\n        e.toff <- e.toff[!e.diag]\\n        e.rad <- e.rad[!e.diag]\\n    }\\n    if (!usecurve & !uselen) {\\n        if (length(px0) > 0) \\n            gplot.arrow(as.vector(px0), as.vector(py0), as.vector(px1), as.vector(py1), length = 2 * baserad * arrowhead.cex, \\n                angle = 20, col = e.col, border = e.col, lty = e.type, width = e.lwd * baserad/10, offset.head = e.hoff, \\n                offset.tail = e.toff, arrowhead = usearrows, edge.steps = edge.steps)\\n    }\\n    else {\\n        if (length(px0) > 0) {\\n            gplot.arrow(as.vector(px0), as.vector(py0), as.vector(px1), as.vector(py1), length = 2 * baserad * arrowhead.cex, \\n                angle = 20, col = e.col, border = e.col, lty = e.type, width = e.lwd * baserad/10, offset.head = e.hoff, \\n                offset.tail = e.toff, arrowhead = usearrows, curve = e.curv, edge.steps = edge.steps)\\n        }\\n    }\\n    if (vertices.last) {\\n        if (vertex.enclose) \\n            gplot.vertex(x[use], y[use], radius = vertex.radius[use], sides = 50, col = \"#FFFFFFFF\", border = vertex.border[use], \\n                lty = vertex.lty[use])\\n        gplot.vertex(x[use], y[use], radius = vertex.radius[use], sides = vertex.sides[use], col = vertex.col[use], border = vertex.border[use], \\n            lty = vertex.lty[use], rot = vertex.rot[use])\\n    }\\n    if (displaylabels & (!all(label == \"\")) & (!all(use == FALSE))) {\\n        if (label.pos == 0) {\\n            xhat <- yhat <- rhat <- rep(0, n)\\n            xoff <- x[use] - mean(x[use])\\n            yoff <- y[use] - mean(y[use])\\n            roff <- sqrt(xoff^2 + yoff^2)\\n            for (i in (1:n)[use]) {\\n                ij <- unique(c(d[d[, 2] == i & d[, 1] != i, 1], d[d[, 1] == i & d[, 2] != i, 2]))\\n                ij.n <- length(ij)\\n                if (ij.n > 0) {\\n                  for (j in ij) {\\n                    dx <- x[i] - x[j]\\n                    dy <- y[i] - y[j]\\n                    dr <- sqrt(dx^2 + dy^2)\\n                    xhat[i] <- xhat[i] + dx/dr\\n                    yhat[i] <- yhat[i] + dy/dr\\n                  }\\n                  xhat[i] <- xhat[i]/ij.n\\n                  yhat[i] <- yhat[i]/ij.n\\n                  rhat[i] <- sqrt(xhat[i]^2 + yhat[i]^2)\\n                  if (rhat[i] != 0) {\\n                    xhat[i] <- xhat[i]/rhat[i]\\n                    yhat[i] <- yhat[i]/rhat[i]\\n                  }\\n                  else {\\n                    xhat[i] <- xoff[i]/roff[i]\\n                    yhat[i] <- yoff[i]/roff[i]\\n                  }\\n                }\\n                else {\\n                  xhat[i] <- xoff[i]/roff[i]\\n                  yhat[i] <- yoff[i]/roff[i]\\n                }\\n                if (xhat[i] == 0) \\n                  xhat[i] <- 0.01\\n                if (yhat[i] == 0) \\n                  yhat[i] <- 0.01\\n            }\\n            xhat <- xhat[use]\\n            yhat <- yhat[use]\\n        }\\n        else if (label.pos < 5) {\\n            xhat <- switch(label.pos, 0, -1, 0, 1)\\n            yhat <- switch(label.pos, -1, 0, 1, 0)\\n        }\\n        else if (label.pos == 6) {\\n            xoff <- x[use] - mean(x[use])\\n            yoff <- y[use] - mean(y[use])\\n            roff <- sqrt(xoff^2 + yoff^2)\\n            xhat <- xoff/roff\\n            yhat <- yoff/roff\\n        }\\n        else {\\n            xhat <- 0\\n            yhat <- 0\\n        }\\n        lw <- strwidth(label[use], cex = label.cex[use])/2\\n        lh <- strheight(label[use], cex = label.cex[use])/2\\n        if (boxed.labels) {\\n            rect(x[use] + xhat * vertex.radius[use] - (lh * label.pad + lw) * ((xhat < 0) * 2 + (xhat == 0) * 1), y[use] + \\n                yhat * vertex.radius[use] - (lh * label.pad + lh) * ((yhat < 0) * 2 + (yhat == 0) * 1), x[use] + xhat * vertex.radius[use] + \\n                (lh * label.pad + lw) * ((xhat > 0) * 2 + (xhat == 0) * 1), y[use] + yhat * vertex.radius[use] + (lh * label.pad + \\n                lh) * ((yhat > 0) * 2 + (yhat == 0) * 1), col = label.bg[use], border = label.border[use], lty = label.lty[use], \\n                lwd = label.lwd[use])\\n        }\\n        text(x[use] + xhat * vertex.radius[use] + (lh * label.pad + lw) * ((xhat > 0) - (xhat < 0)), y[use] + yhat * vertex.radius[use] + \\n            (lh * label.pad + lh) * ((yhat > 0) - (yhat < 0)), label[use], cex = label.cex[use], col = label.col[use], offset = 0)\\n    }\\n    if ((interactive | interact.bycomp) && ((length(x) > 0) && (!all(use == FALSE)))) {\\n        os <- c(0.2, 0.4) * par()$cxy\\n        textloc <- c(min(x[use]) - pad, max(y[use]) + pad)\\n        tm <- \"Select a vertex to move, or click \\\\\"Finished\\\\\" to end.\"\\n        tmh <- strheight(tm)\\n        tmw <- strwidth(tm)\\n        text(textloc[1], textloc[2], tm, adj = c(0, 0.5))\\n        fm <- \"Finished\"\\n        finx <- c(textloc[1], textloc[1] + strwidth(fm))\\n        finy <- c(textloc[2] - 3 * tmh - strheight(fm)/2, textloc[2] - 3 * tmh + strheight(fm)/2)\\n        finbx <- finx + c(-os[1], os[1])\\n        finby <- finy + c(-os[2], os[2])\\n        rect(finbx[1], finby[1], finbx[2], finby[2], col = \"white\")\\n        text(finx[1], mean(finy), fm, adj = c(0, 0.5))\\n        clickpos <- unlist(locator(1))\\n        if ((clickpos[1] %iin% finbx) && (clickpos[2] %iin% finby)) {\\n            cl <- match.call()\\n            cl$interactive <- FALSE\\n            cl$coord <- cbind(x, y)\\n            cl$dat <- dat\\n            return(eval(cl))\\n        }\\n        else {\\n            clickdis <- sqrt((clickpos[1] - x[use])^2 + (clickpos[2] - y[use])^2)\\n            selvert <- match(min(clickdis), clickdis)\\n            if (all(label == \"\")) \\n                label <- 1:n\\n            rect(textloc[1], textloc[2] - tmh/2, textloc[1] + tmw, textloc[2] + tmh/2, border = \"white\", col = \"white\")\\n            if (interact.bycomp) \\n                tm <- \"Where should I move this component?\"\\n            else tm <- \"Where should I move this vertex?\"\\n            tmh <- strheight(tm)\\n            tmw <- strwidth(tm)\\n            text(textloc[1], textloc[2], tm, adj = c(0, 0.5))\\n            fm <- paste(\"Vertex\", label[use][selvert], \"selected\")\\n            finx <- c(textloc[1], textloc[1] + strwidth(fm))\\n            finy <- c(textloc[2] - 3 * tmh - strheight(fm)/2, textloc[2] - 3 * tmh + strheight(fm)/2)\\n            finbx <- finx + c(-os[1], os[1])\\n            finby <- finy + c(-os[2], os[2])\\n            rect(finbx[1], finby[1], finbx[2], finby[2], col = \"white\")\\n            text(finx[1], mean(finy), fm, adj = c(0, 0.5))\\n            clickpos <- unlist(locator(1))\\n            if (interact.bycomp) {\\n                dx <- clickpos[1] - x[use][selvert]\\n                dy <- clickpos[2] - y[use][selvert]\\n                comp.mem <- component.dist(d, connected = \"weak\")$membership\\n                same.comp <- comp.mem[use] == comp.mem[use][selvert]\\n                x[use][same.comp] <- x[use][same.comp] + dx\\n                y[use][same.comp] <- y[use][same.comp] + dy\\n            }\\n            else {\\n                x[use][selvert] <- clickpos[1]\\n                y[use][selvert] <- clickpos[2]\\n            }\\n            cl <- match.call()\\n            cl$coord <- cbind(x, y)\\n            cl$dat <- dat\\n            return(eval(cl))\\n        }\\n    }\\n    invisible(cbind(x, y))\\n}","2":"1"},{"1":"function (expr, envir = parent.frame(), priority = c(\"first\", \"last\")) \\n{\\n    priority <- match.arg(priority)\\n    if (identical(envir, .GlobalEnv) && is.null(get_handlers(envir))) {\\n        message(\"Setting deferred event(s) on global environment.\\\\n\", \"  * Execute (and clear) with `deferred_run()`.\\\\n\", \\n            \"  * Clear (without executing) with `deferred_clear()`.\")\\n    }\\n    invisible(add_handler(envir, handler = list(expr = substitute(expr), envir = parent.frame()), front = priority == \"first\"))\\n}","2":"1"},{"1":"function (x, ...) \\n{\\n    UseMethod(\"HotellingsT2Test\")\\n}","2":"1"},{"1":"function (x, ...) \\n{\\n    UseMethod(\"MeanDiffCI\")\\n}","2":"1"},{"1":"function (x, ...) \\nUseMethod(\"ConoverTest\")","2":"1"},{"1":"function (x, ...) \\nUseMethod(\"DunnTest\")","2":"1"},{"1":"function (x, ...) \\nUseMethod(\"format\")","2":"1"},{"1":"function (x, ...) \\nUseMethod(\"JonckheereTerpstraTest\")","2":"1"},{"1":"function (x, ...) \\nUseMethod(\"YuenTTest\")","2":"1"},{"1":"function (x, ...) \\nUseMethod(\"ZTest\")","2":"1"},{"1":"function (y, ...) \\nUseMethod(\"PageTest\")","2":"1"},{"1":"gather","2":"1"},{"1":"gctorture2","2":"1"},{"1":"getDataURI","2":"1"},{"1":"getProperty","2":"1"},{"1":"ggballoonplot","2":"1"},{"1":"ggtexttable","2":"1"},{"1":"glue","2":"1"},{"1":"gridExtra::arrangeGrob","2":"1"},{"1":"has_name","2":"1"},{"1":"has_warning","2":"1"},{"1":"hcEEE","2":"1"},{"1":"hclust","2":"1"},{"1":"hexbin::hexplom","2":"1"},{"1":"hough_line","2":"1"},{"1":"iblkcol","2":"1"},{"1":"ignore(expect_true)","2":"1"},{"1":"iiply","2":"1"},{"1":"image_blank","2":"1"},{"1":"imdraw","2":"1"},{"1":"imlap","2":"1"},{"1":"imrow","2":"1"},{"1":"imsharpen","2":"1"},{"1":"imshift","2":"1"},{"1":"in_dir","2":"1"},{"1":"InitErgmTerm.myedges","2":"1"},{"1":"inner_join","2":"1"},{"1":"inpaint","2":"1"},{"1":"is_red","2":"1"},{"1":"is.writeable","2":"1"},{"1":"isTRUE","2":"1"},{"1":"join_rows","2":"1"},{"1":"kwic","2":"1"},{"1":"lattice::barchart","2":"1"},{"1":"lavaan::parameterEstimates","2":"1"},{"1":"layer_data","2":"1"},{"1":"levlnorm","2":"1"},{"1":"lfe::getfe","2":"1"},{"1":"lhs.vars","2":"1"},{"1":"lift_ld(cross, .filter = `==`)","2":"1"},{"1":"liply","2":"1"},{"1":"list.all","2":"1"},{"1":"list.any","2":"1"},{"1":"list.cases","2":"1"},{"1":"list.class","2":"1"},{"1":"list.common","2":"1"},{"1":"list.count","2":"1"},{"1":"list.dirs","2":"1"},{"1":"list.find","2":"1"},{"1":"list.findi","2":"1"},{"1":"list.loadfile.json","2":"1"},{"1":"list.loadfile.yaml","2":"1"},{"1":"list.table","2":"1"},{"1":"list.update","2":"1"},{"1":"ll.smlogit","2":"1"},{"1":"ll[[1L]]","2":"1"},{"1":"ll$foo","2":"1"},{"1":"local","2":"1"},{"1":"log1p","2":"1"},{"1":"log2","2":"1"},{"1":"map_data","2":"1"},{"1":"MASS::cov.rob","2":"1"},{"1":"MASS::lqs","2":"1"},{"1":"method_df","2":"1"},{"1":"mlogit.data","2":"1"},{"1":"mstepV","2":"1"},{"1":"mutate","2":"1"},{"1":"mutate_at","2":"1"},{"1":"n","2":"1"},{"1":"ncol","2":"1"},{"1":"nest","2":"1"},{"1":"nest_legacy","2":"1"},{"1":"new","2":"1"},{"1":"nfun","2":"1"},{"1":"nfun2","2":"1"},{"1":"nlme::nlme.nlsList","2":"1"},{"1":"nlme::nlsList","2":"1"},{"1":"norm_coords","2":"1"},{"1":"num_as_location2","2":"1"},{"1":"on.exit","2":"1"},{"1":"opts_chunk$set","2":"1"},{"1":"pairs","2":"1"},{"1":"parmax","2":"1"},{"1":"parmed","2":"1"},{"1":"parsd","2":"1"},{"1":"parvar","2":"1"},{"1":"pBCT","2":"1"},{"1":"periodic.part","2":"1"},{"1":"Plots","2":"1"},{"1":"pmap","2":"1"},{"1":"pratchet","2":"1"},{"1":"px.bottom","2":"1"},{"1":"px.diamond","2":"1"},{"1":"px.right","2":"1"},{"1":"px.top","2":"1"},{"1":"qflextable","2":"1"},{"1":"qGA","2":"1"},{"1":"raster::values","2":"1"},{"1":"rcompound","2":"1"},{"1":"read_xlsx","2":"1"},{"1":"read.tree","2":"1"},{"1":"Reduce","2":"1"},{"1":"remove_rownames","2":"1"},{"1":"require","2":"1"},{"1":"RhpcBLASctl::omp_get_max_threads","2":"1"},{"1":"rmixture","2":"1"},{"1":"rowid_to_column","2":"1"},{"1":"rownames_to_column","2":"1"},{"1":"runif","2":"1"},{"1":"rztnbinom","2":"1"},{"1":"sample.int","2":"1"},{"1":"saveRDS","2":"1"},{"1":"scale","2":"1"},{"1":"semi_join","2":"1"},{"1":"seq_along","2":"1"},{"1":"set","2":"1"},{"1":"set_global_state","2":"1"},{"1":"set_names","2":"1"},{"1":"SetAlpha","2":"1"},{"1":"setClass","2":"1"},{"1":"setnames","2":"1"},{"1":"setRefClass","2":"1"},{"1":"spark_context","2":"1"},{"1":"spdep::nb2listw","2":"1"},{"1":"splice","2":"1"},{"1":"split_connected","2":"1"},{"1":"square_add_one","2":"1"},{"1":"src_sqlite","2":"1"},{"1":"SSasympOff","2":"1"},{"1":"st_geometry","2":"1"},{"1":"st_geometrycollection","2":"1"},{"1":"st_sf","2":"1"},{"1":"stats::lm","2":"1"},{"1":"stri_detect_regex","2":"1"},{"1":"stri_replace_all_regex","2":"1"},{"1":"strptime","2":"1"},{"1":"summarise_at","2":"1"},{"1":"svycoxph","2":"1"},{"1":"svykm","2":"1"},{"1":"symbols","2":"1"},{"1":"Sys.chmod","2":"1"},{"1":"Sys.Date","2":"1"},{"1":"tail","2":"1"},{"1":"tbl_at_vars","2":"1"},{"1":"tibble::as_tibble","2":"1"},{"1":"tidygraph::play_erdos_renyi","2":"1"},{"1":"tobit","2":"1"},{"1":"tokens_compound","2":"1"},{"1":"tolower","2":"1"},{"1":"tram_data","2":"1"},{"1":"ui_code_block","2":"1"},{"1":"ui_done","2":"1"},{"1":"ui_info","2":"1"},{"1":"ui_line","2":"1"},{"1":"ui_oops","2":"1"},{"1":"ui_stop","2":"1"},{"1":"ui_todo","2":"1"},{"1":"ui_warn","2":"1"},{"1":"unif","2":"1"},{"1":"use_first","2":"1"},{"1":"vec_cast_no_fallback","2":"1"},{"1":"vec_ptype2_no_fallback","2":"1"},{"1":"vegdist","2":"1"},{"1":"warp","2":"1"},{"1":"watershed","2":"1"},{"1":"WEI2","2":"1"},{"1":"wisconsin","2":"1"},{"1":"with_foobar_cast","2":"1"},{"1":"with_foobar_ptype2","2":"1"},{"1":"with.jobjRef","2":"1"},{"1":"withCallingHandlers","2":"1"},{"1":"writeLines","2":"1"},{"1":"wsum","2":"1"},{"1":"xml_new_root","2":"1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>We can distinguish a few groups:</p>
<ul>
<li>assignments</li>
<li>reading (in a data frame, a vector)</li>
<li>parsing</li>
<li>defusing (<code>quote</code>, <code>substitute</code> and so on)</li>
<li>conversion or creation of new values</li>
<li>building calls and calling</li>
<li>working with environments</li>
<li>class assignments, reads and definitions</li>
<li>building logical values</li>
<li>formula</li>
<li>meta programming on functions (getting access to the body of the function, to the call stack)</li>
<li>‘NA’ corresponds to no function calls (or that it was not parsed successfully)</li>
<li>anonymous functions</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a>group_expr_resolved_functions &lt;-<span class="st"> </span>expr_resolved_call_arg <span class="op">%&gt;%</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="st">                            </span><span class="kw">mutate</span>(<span class="dt">function_expr2 =</span> <span class="kw">groupify_function</span>(expr_resolved_function)) <span class="op">%&gt;%</span></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="st">                            </span><span class="kw">mutate</span>(<span class="dt">group_function_expr =</span> <span class="kw">fct_collapse</span>(function_expr2, </span>
<span id="cb37-4"><a href="#cb37-4"></a>                              <span class="dt">assignment =</span> <span class="kw">c</span>(<span class="st">&quot;&lt;-&quot;</span>, <span class="st">&quot;[[&lt;-&quot;</span>, <span class="st">&quot;[&lt;-&quot;</span>, <span class="st">&quot;$&lt;-&quot;</span>, <span class="st">&quot;&lt;&lt;-&quot;</span>, <span class="st">&quot;=&quot;</span>, <span class="st">&quot;@&lt;-&quot;</span>),</span>
<span id="cb37-5"><a href="#cb37-5"></a>                              <span class="dt">slot_access =</span> <span class="kw">c</span>(<span class="st">&quot;[&quot;</span>, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;$&quot;</span>, <span class="st">&quot;slot&quot;</span>, <span class="st">&quot;@&quot;</span>, <span class="st">&quot;::&quot;</span>, <span class="st">&quot;:::&quot;</span>),</span>
<span id="cb37-6"><a href="#cb37-6"></a>                              <span class="dt">parsing =</span> <span class="kw">c</span>(<span class="st">&quot;parse&quot;</span>, <span class="st">&quot;str2lang&quot;</span>, <span class="st">&quot;str2expression&quot;</span>, <span class="st">&quot;parse_only&quot;</span>, <span class="st">&quot;base::parse&quot;</span>),</span>
<span id="cb37-7"><a href="#cb37-7"></a>                              <span class="dt">defusing =</span> <span class="kw">c</span>(<span class="st">&quot;quote&quot;</span>, <span class="st">&quot;substitute&quot;</span>, <span class="st">&quot;bquote&quot;</span>, <span class="st">&quot;expr&quot;</span>, <span class="st">&quot;quo&quot;</span>),</span>
<span id="cb37-8"><a href="#cb37-8"></a>                              <span class="dt">expressions =</span> <span class="kw">c</span>(<span class="st">&quot;as.list&quot;</span>, <span class="st">&quot;expression&quot;</span>, <span class="st">&quot;as.name&quot;</span>, <span class="st">&quot;as.expression&quot;</span>, <span class="st">&quot;list&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;as.data.frame&quot;</span>, <span class="st">&quot;as.character&quot;</span>, <span class="st">&quot;{&quot;</span>, <span class="st">&quot;modify_lang&quot;</span>),</span>
<span id="cb37-9"><a href="#cb37-9"></a>                              <span class="dt">calling =</span> <span class="kw">c</span>(<span class="st">&quot;call&quot;</span>, <span class="st">&quot;as.call&quot;</span>, <span class="st">&quot;do.call&quot;</span>),</span>
<span id="cb37-10"><a href="#cb37-10"></a>                              <span class="dt">environment =</span> <span class="kw">c</span>(<span class="st">&quot;environment&quot;</span>, <span class="st">&quot;as.environment&quot;</span>),</span>
<span id="cb37-11"><a href="#cb37-11"></a>                              <span class="dt">logical =</span> <span class="kw">c</span>(<span class="st">&quot;!&quot;</span>, <span class="st">&quot;&amp;&quot;</span>, <span class="st">&quot;|&quot;</span>, <span class="st">&quot;&amp;&amp;&quot;</span>, <span class="st">&quot;||&quot;</span>),</span>
<span id="cb37-12"><a href="#cb37-12"></a>                              <span class="dt">relation =</span> <span class="kw">c</span>(<span class="st">&quot;&lt;&quot;</span>, <span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;is.element&quot;</span>, <span class="st">&quot;&lt;=&quot;</span>, <span class="st">&quot;=&gt;&quot;</span>, <span class="st">&quot;!=&quot;</span>),</span>
<span id="cb37-13"><a href="#cb37-13"></a>                              <span class="dt">choice =</span> <span class="kw">c</span>(<span class="st">&quot;if&quot;</span>),</span>
<span id="cb37-14"><a href="#cb37-14"></a>                              <span class="dt">anonymous =</span> <span class="kw">c</span>(<span class="st">&quot;anonymous&quot;</span>),</span>
<span id="cb37-15"><a href="#cb37-15"></a>                              <span class="dt">primitive =</span> <span class="kw">c</span>(<span class="st">&quot;primitive&quot;</span>),</span>
<span id="cb37-16"><a href="#cb37-16"></a>                              <span class="dt">function_meta =</span> <span class="kw">c</span>(<span class="st">&quot;sys.calls&quot;</span>, <span class="st">&quot;function&quot;</span>, <span class="st">&quot;body&quot;</span>, <span class="st">&quot;missing&quot;</span>),</span>
<span id="cb37-17"><a href="#cb37-17"></a>                              <span class="dt">arithmetic =</span> <span class="kw">c</span>(<span class="st">&quot;+&quot;</span>, <span class="st">&quot;-&quot;</span>, <span class="st">&quot;*&quot;</span>, <span class="st">&quot;/&quot;</span>, <span class="st">&quot;%%&quot;</span>, <span class="st">&quot;^&quot;</span>),</span>
<span id="cb37-18"><a href="#cb37-18"></a>                              <span class="dt">formula =</span> <span class="kw">c</span>(<span class="st">&quot;~&quot;</span>, <span class="st">&quot;deriv&quot;</span>, <span class="st">&quot;D&quot;</span>, <span class="st">&quot;model.frame&quot;</span>, <span class="st">&quot;rootftfunc&quot;</span>, <span class="st">&quot;contest.lmerModLmerTest&quot;</span>, <span class="st">&quot;JacFunc&quot;</span>, <span class="st">&quot;gamlss.family&quot;</span>, <span class="st">&quot;contest1D.lmerModLmerTest&quot;</span>, <span class="st">&quot;contestMD.lmerModLmerTest&quot;</span>, <span class="st">&quot;reexpr&quot;</span>),                           </span>
<span id="cb37-19"><a href="#cb37-19"></a>                              <span class="dt">other_level =</span> <span class="st">&quot;other&quot;</span> ))</span></code></pre></div>
<pre><code>## Warning: Problem with `mutate()` input `group_function_expr`.
## x Unknown levels in `f`: @&lt;-, slot, @, str2lang, str2expression, parse_only, base::parse, quo, as.expression, modify_lang, call, as.call, as.environment, is.element, =&gt;, primitive, deriv, D, rootftfunc, contest.lmerModLmerTest, JacFunc, gamlss.family, contest1D.lmerModLmerTest, contestMD.lmerModLmerTest, reexpr
## ℹ Input `group_function_expr` is `fct_collapse(...)`.</code></pre>
<pre><code>## Warning: Unknown levels in `f`: @&lt;-, slot, @, str2lang, str2expression,
## parse_only, base::parse, quo, as.expression, modify_lang, call, as.call,
## as.environment, is.element, =&gt;, primitive, deriv, D, rootftfunc,
## contest.lmerModLmerTest, JacFunc, gamlss.family, contest1D.lmerModLmerTest,
## contestMD.lmerModLmerTest, reexpr</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a>group_expr_resolved_functions <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(group_function_expr, <span class="dt">wt =</span> nb_ev_calls) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(n)) <span class="op">%&gt;%</span><span class="st"> </span>knitr<span class="op">::</span><span class="kw">kable</span>()</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">group_function_expr</th>
<th align="right">n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">other</td>
<td align="right">600353</td>
</tr>
<tr class="even">
<td align="left">function_meta</td>
<td align="right">479058</td>
</tr>
<tr class="odd">
<td align="left">expressions</td>
<td align="right">234788</td>
</tr>
<tr class="even">
<td align="left">assignment</td>
<td align="right">132549</td>
</tr>
<tr class="odd">
<td align="left">slot_access</td>
<td align="right">86499</td>
</tr>
<tr class="even">
<td align="left">defusing</td>
<td align="right">86024</td>
</tr>
<tr class="odd">
<td align="left">arithmetic</td>
<td align="right">63222</td>
</tr>
<tr class="even">
<td align="left">formula</td>
<td align="right">43010</td>
</tr>
<tr class="odd">
<td align="left">logical</td>
<td align="right">3746</td>
</tr>
<tr class="even">
<td align="left">parsing</td>
<td align="right">2492</td>
</tr>
<tr class="odd">
<td align="left">environment</td>
<td align="right">1236</td>
</tr>
<tr class="even">
<td align="left">relation</td>
<td align="right">666</td>
</tr>
<tr class="odd">
<td align="left">calling</td>
<td align="right">78</td>
</tr>
<tr class="even">
<td align="left">choice</td>
<td align="right">20</td>
</tr>
<tr class="odd">
<td align="left">anonymous</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1"></a>group_expr_resolved_functions <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="st">  </span><span class="kw">geom_bar</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">fct_rev</span>(<span class="kw">fct_infreq</span>(group_function_expr)), <span class="dt">weight =</span> nb_ev_calls)) <span class="op">+</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="st">  </span><span class="kw">scale_y_sqrt</span>() <span class="op">+</span></span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="st">  </span><span class="kw">coord_flip</span>() <span class="op">+</span></span>
<span id="cb41-5"><a href="#cb41-5"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Category of calls&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;category&quot;</span> ) </span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/unnamed-chunk-9-1.png" width="960" style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a>group_expr_resolved_functions <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="st">  </span><span class="kw">geom_bar</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">fct_rev</span>(<span class="kw">fct_infreq</span>(group_function_expr)), <span class="dt">weight =</span> nb_ev_calls)) <span class="op">+</span></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="st">  </span><span class="kw">scale_y_sqrt</span>() <span class="op">+</span></span>
<span id="cb42-4"><a href="#cb42-4"></a><span class="st">  </span><span class="kw">coord_flip</span>() <span class="op">+</span></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Category of calls&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;category&quot;</span> ) <span class="op">+</span></span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="st">  </span><span class="kw">facet_wrap</span>(<span class="kw">vars</span>(eval_function))</span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/unnamed-chunk-10-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>We also look at the arity of the top-level function:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a>expr_resolved_call_arg <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(expr_expression_args_num, <span class="dt">sort =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span><span class="st"> </span>knitr<span class="op">::</span><span class="kw">kable</span>()</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">expr_expression_args_num</th>
<th align="right">n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">NA</td>
<td align="right">84184</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">58470</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right">30913</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="right">19628</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">21</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">4</td>
<td align="right">9</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1"></a>expr_resolved_call_arg <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="st">  </span><span class="kw">geom_bar</span>(<span class="kw">aes</span>(<span class="dt">x =</span> expr_resolved_args_num, <span class="dt">weight =</span> nb_ev_calls)) <span class="op">+</span></span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="st">  </span><span class="kw">scale_y_sqrt</span>() <span class="op">+</span></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="st">  </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Arity of calls&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;arity&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;n&quot;</span>)</span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/arity_expr_resolved_plot-1.png" width="960" style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a>expr_resolved_call_arg <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="st">  </span><span class="kw">geom_bar</span>(<span class="kw">aes</span>(<span class="dt">x =</span> expr_resolved_args_num, <span class="dt">weight =</span> nb_ev_calls)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="st">  </span><span class="kw">scale_y_sqrt</span>() <span class="op">+</span></span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="st">  </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb45-5"><a href="#cb45-5"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Arity of calls&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;arity&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;n&quot;</span>) <span class="op">+</span></span>
<span id="cb45-6"><a href="#cb45-6"></a><span class="st">  </span><span class="kw">facet_wrap</span>(<span class="kw">vars</span>(eval_function))</span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/arity_expr_resolved_plot_per_eval-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>Another interesting figure is the degreee of polymorphism of the <code>expr</code> argument: how many different types (for <code>expr_resolved</code>) are there for one call sites?</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1"></a>expr_resolved_polymorphism &lt;-<span class="st"> </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(eval_call_srcref) <span class="op">%&gt;%</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="st">        </span><span class="kw">summarise</span>(<span class="dt">polym_degree =</span> <span class="kw">vec_unique_count</span>(expr_resolved_type))</span></code></pre></div>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1"></a>expr_resolved_monomorphic &lt;-<span class="st"> </span>expr_resolved_polymorphism <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(polym_degree <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb48-2"><a href="#cb48-2"></a>nb_monomorphic &lt;-<span class="st"> </span>expr_resolved_monomorphic <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">nrow</span>()</span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a>expr_resolved_polymorphism <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="st">  </span><span class="kw">geom_bar</span>(<span class="kw">aes</span>(<span class="dt">x =</span> polym_degree)) <span class="op">+</span></span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="st">  </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>)) <span class="op">+</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Degree of polymorphism&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;degree&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;n&quot;</span>) </span></code></pre></div>
<p><img src="analysis_stable_files/figure-html/polymorphism-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>2511 call sites are not polymorphic, which represents 89.2324094% of the call sites.</p>
<p>From the monomorphic functions, we can deduce how many are <em>replaceable</em>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1"></a>expr_resolved_replaceable &lt;-<span class="st"> </span>expr_resolved_monomorphic <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">left_join</span>(eval_calls) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">can_replace =</span> <span class="kw">map_lgl</span>(expr_resolved,  is_replaceable_str))</span></code></pre></div>
<pre><code>## Joining, by = &quot;eval_call_srcref&quot;</code></pre>
</div>
<div id="provenance" class="section level2">
<h2>Provenance</h2>
<p>Some <code>eval</code> result from parsing text (directly or through a file) with <code>parse</code>.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a>parsed_evals &lt;-<span class="st"> </span>eval_calls <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(expr_parsed_expression))</span>
<span id="cb52-2"><a href="#cb52-2"></a>nb_parsed_evals &lt;-<span class="st"> </span>parsed_evals <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(<span class="dt">wt =</span> nb_ev_calls)</span></code></pre></div>
There are
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["n"],"name":[1],"type":["int"],"align":["right"]}],"data":[{"1":"398589"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
such calls,
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["n"],"name":[1],"type":["dbl"],"align":["right"]}],"data":[{"1":"7.854105"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>%.</p>
<p>In terms of call sites, there are 358 i.e. 12.7221038%.</p>
<p>We can differentiate further the provenance, i.e. whether the evaluated string comes from <code>file</code> or from <code>text</code>. However, we can only do it for <code>parse</code>, <code>str2lang</code> and <code>str2expression</code> at the top level of <code>expr_expression</code>, not buried in a function call.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1"></a><span class="cf">if</span>(<span class="st">&quot;parse_args_file&quot;</span> <span class="op">%in%</span><span class="st"> </span><span class="kw">names</span>(parsed_evals))</span>
<span id="cb53-2"><a href="#cb53-2"></a>{</span>
<span id="cb53-3"><a href="#cb53-3"></a>  parsed_files &lt;-<span class="st"> </span>parsed_evals <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(parse_args_file))</span>
<span id="cb53-4"><a href="#cb53-4"></a>  nb_file &lt;-<span class="st"> </span>parsed_files <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(<span class="dt">wt =</span> nb_ev_calls)</span>
<span id="cb53-5"><a href="#cb53-5"></a>  nb_file_call_sites &lt;-<span class="st"> </span><span class="kw">nb_eval_call_sites</span>(parsed_files)</span>
<span id="cb53-6"><a href="#cb53-6"></a>} <span class="cf">else</span></span>
<span id="cb53-7"><a href="#cb53-7"></a>{</span>
<span id="cb53-8"><a href="#cb53-8"></a>  nb_file &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb53-9"><a href="#cb53-9"></a>  nb_file_call_sites &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb53-10"><a href="#cb53-10"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a>parsed_texts &lt;-<span class="st"> </span>parsed_evals <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(parse_args_text) <span class="op">|</span><span class="st"> </span><span class="op">!</span><span class="kw">is.na</span>(parse_args_s))</span>
<span id="cb54-2"><a href="#cb54-2"></a>nb_text &lt;-<span class="st">  </span>parsed_texts <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(<span class="dt">wt =</span> nb_ev_calls)</span>
<span id="cb54-3"><a href="#cb54-3"></a>nb_text_call_sites &lt;-<span class="st"> </span><span class="kw">nb_eval_call_sites</span>(parsed_texts)</span></code></pre></div>
There are 0 calls with the <code>file</code> argument, and
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["n"],"name":[1],"type":["int"],"align":["right"]}],"data":[{"1":"396687"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
with the <code>text</code> argument, i.e. 
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["n"],"name":[1],"type":["dbl"],"align":["right"]}],"data":[{"1":"0"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
%, and
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["n"],"name":[1],"type":["dbl"],"align":["right"]}],"data":[{"1":"99.52282"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>% respectively.</p>
<p>There are 0 call sites with the <code>file</code> argument, and 351 with the <code>text</code> argument, i.e. 0%, and 98.0446927% respectively.</p>
</div>
<div id="consistence" class="section level2">
<h2>Consistence</h2>
</div>
</div>
<div id="other-faces-of-eval" class="section level1">
<h1>Other faces of <code>eval</code></h1>
</div>
<div id="case-studies" class="section level1">
<h1>Case studies</h1>
</div>
</div>


</div>




<script>
$(document).ready(function () {
 	    $('#content img')
 	  .addClass("image-lb");
  $('#content').magnificPopup({
	      type:'image',
	      closeOnContentClick: false,
	      closeBtnInside: false,
	      delegate: 'img',
	      gallery: {enabled: false },
	      image: {
	        verticalFit: true,
          titleSrc: 'alt'
	      }
 	    });
 	});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
