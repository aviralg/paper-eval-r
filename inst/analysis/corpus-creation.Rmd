---
title: "Corpus Creation"
output: 
  html_document: 
    theme: united
    toc: yes
    toc_float: yes
editor_options: 
  chunk_output_type: console
params:
  data_dir: /var/lib/R/project-evalR/revalstudy/data
  num_packages: 500
  output_dir: /var/lib/R/project-evalR/revalstudy/data
  which_dependencies:
    - Depends
    - Imports
---

```{r setup, include=FALSE}
for (x in c(
  "dplyr", 
  "DT", 
  "fs", 
  "readr",
  "purrr"
  )) {
  suppressPackageStartupMessages(library(x, character.only=TRUE))
}

knitr::opts_chunk$set(echo = TRUE)

# TODO: move into the package
source("inc/paths.R")
source("inc/setup.R")
source("inc/latextags.R")

create_tags(path(TAGS_DIR, "corpus.tex"), prefix="", default=TRUE)
```

## Description

The aim of this notebook is to prepare the corpus of R packages to be included in the paper.

### Output

- ``r CORPUS_FILE`` - the corpus in the corpus file (one package file line)
- ``r CORPUS_REVDEPS`` - CSV of package / reverse dependency pairs
- ``r CORPUS_REVDEPS_FILE`` - all unique reverse dependencies in the corpus file format

## Prepare the corpus

We are interested in TOP `r params$num_packages` packages based on the number of reverse dependencies.

```{r get all available packages}
# TODO this should be installed.packages() once they are installed
cran_packages_raw <- available.packages()
cran_packages <- as_tibble(cran_packages_raw) %>%
  select(package=Package, version=Version)
```

### Package reverse dependencies

There are two functions `package_dependencies` and `dependsOnPkgs`.
Not sure what is the difference, but the `dependsOnPkgs` is very slow.

```{r compute reverse dependencies}
pkgs_revdeps_raw <- 
  tools::package_dependencies(
    cran_packages$package,
    db=cran_packages_raw,
    which=params$which_dependencies,
    reverse=TRUE,
    recursive=FALSE
  ) %>% 
  imap_dfr(~tibble(package=.y, revdep=.x))

pkgs_revdeps <- 
  pkgs_revdeps_raw %>%
  count(package) %>%
  rename(revdeps=n)
```

### TOP packages based on number of reverse dependencies

```{r compute TOP n packages}
pkgs_top_revdeps <-
  pkgs_revdeps %>%
  top_n(n = params$num_packages, wt=revdeps) %>%
  arrange(desc(revdeps))

# cup the number of reverse dependencies to the required number
pkgs_top_revdeps <- head(pkgs_top_revdeps, min(nrow(pkgs_top_revdeps), params$num_packages))
```

### Missing packages from TOP 100 downloads

```{r get last month most downloaded packages}
pkgs_top_downloaded <-
  cranlogs::cran_top_downloads("last-month", 100)
```

```{r compute missing packages from the most downloaded ones}
missing <- setdiff(pkgs_top_downloaded$package, pkgs_top_revdeps$package)
missing_revdeps <- filter(pkgs_revdeps, package %in% missing)
missing_revdeps %>%
  left_join(pkgs_top_downloaded, by="package") %>%
  datatable()
```

### Corpus

Putting it all together and outputting the results.

```{r render selected packages}
pkgs_top_revdeps %>%
  left_join(pkgs_top_downloaded, by="package") %>%
  arrange(desc(revdeps)) %>%
  datatable()
```

```{r write down corpus}
pkgs_revdeps

write_lines(pkgs_top_revdeps$package, CORPUS_FILE)
write_csv(pkgs_revdeps, CORPUS_REVDEPS)
write_lines(unique(pkgs_revdeps_raw$revdep), CORPUS_REVDEPS_FILE)
write_lines(unique(), CORPUS_ALL_PACKAGES_FILE)
```
