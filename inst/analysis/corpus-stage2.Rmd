---
title: "Corpus Analysis"
output: html_document
params:
  base_dir: /var/lib/R/project-evalR
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
for (x in c(
  "dplyr", 
  "DT",
  "fs",
  "fst",
  "lubridate",
  "readr",
  "purrr",
  "stringr",
  "tidyr"
  )) {
  suppressPackageStartupMessages(library(x, character.only=TRUE))
}

knitr::opts_chunk$set(echo = TRUE)

# TODO: move into the package
source("inc/paths.R")
source("inc/setup.R")
```

```{r aux functions}
read_task_result <- function(path) {
  read_fst(path) %>% as_tibble() %>% mutate(package=basename(package))
}

read_parallel_log <- function(path) {
  read_fst(path) %>% 
    as_tibble() %>% 
    rename_all(tolower) %>%
    mutate(
      package=map_chr(command, ~basename(str_split(., " ")[[1]][2])),
      starttime=as_datetime(starttime),
      endtime=as_datetime(starttime + jobruntime),
      runtime=endtime-starttime,
      run_path=map_chr(command, ~dirname(str_split(., " ")[[1]][3]))
    ) %>%
    select(package, exitval, starttime, endtime, runtime, command, run_path)
}
```

## Load data

```{r loading raw data}
corpus_s1_raw     <- read_task_result(CORPUS_S1_DETAILS_FILE)
evals_raw         <- read_task_result(PACKAGE_EVALS_FILE)
coverage_raw      <- read_task_result(PACKAGE_COVERAGE_FILE)
metadata_raw      <- read_task_result(PACKAGE_METADATA_FILE)
functions_raw     <- read_task_result(PACKAGE_FUNCTIONS_FILE)
sloc_raw          <- read_task_result(PACKAGE_SLOC_FILE)
runnable_code_raw <- read_task_result(PACKAGE_RUNNABLE_CODE_FILE)
runs_raw          <- read_task_result(PACKAGE_RUNS_FILE)
trace_runs_raw    <- read_task_result(PACKAGE_TRACE_RUNS_FILE)

trace_log_raw     <- read_parallel_log(PACKAGE_TRACE_LOG_FILE)
```

## Process rawdata

### Metadata

```{r process metadata}
metadata <- select(metadata_raw, -name)
```

```{r process sloc}
sloc <- 
  sloc_raw %>%
  filter(path == "R" | path == "src") %>%
  select(-blank, -comment, -files, -path) %>%
  mutate(language=case_when(
    language == "R" ~ "package_r_code",
    language == "C" ~ "package_native_code",
    language == "C/C++ Header" ~ "package_native_code",
    language == "C++" ~ "package_native_code",
    startsWith(language, "Fortran") ~ "package_native_code",
    TRUE ~ as.character(NA)
  )) %>%
  filter(!is.na(language)) %>%
  group_by(package, language) %>%
  summarise(code=sum(code)) %>%
  spread(key=language, value=code, fill=0) %>%
  mutate(package_code=package_native_code + package_r_code)
```

```{r process functions}
functions <-
  functions_raw %>%
  count(package, exported) %>%
  mutate(exported=ifelse(exported, "funs_public", "funs_private")) %>%
  pivot_wider(
    names_from=exported, 
    values_from=n, 
    values_fill=list(n=0)
  )
```

### Runnable code

Next to the code itself, R packages have examples, tests and vignettes.
These can include snippets of R code which calls the package functions.
We extract this code and run it to narrow down the list of packages that can be considered into the final corpus.

```{r process runnable code}
runnable_code <- 
  runnable_code_raw %>%
  filter(language=="R") %>%
  select(package, path, code, files) %>%
  pivot_wider(
    names_from=path, 
    values_from=c(code, files), 
    values_fill=list(code=0, files=0)
  ) %>%
  # TODO we have old version of tidyr, names_glue is missing, so have to rename manually
  rename(
    runnable_code_examples=code_examples,
    runnable_code_tests=code_tests,
    runnable_code_vignettes=code_vignettes,
    runnable_files_examples=files_examples,
    runnable_files_tests=files_tests,
    runnable_files_vignettes=files_vignettes,
  ) %>%
  mutate(
    runnable_code=runnable_code_examples+runnable_code_tests+runnable_code_vignettes,
    runnable_files=runnable_files_examples+runnable_files_tests+runnable_files_vignettes
  ) %>%
  select(
    package,
    runnable_code,
    runnable_files,
    everything()
  )
```

### Coverage

```{r process coverage}
coverage <- coverage_raw %>%
  filter(type=="all", is.na(error), !is.na(coverage_expression)) %>% 
  select(-type, -error, coverage_expr=coverage_expression) %>%
  mutate(coverage_expr=coverage_expr/100, coverage_line=coverage_line/100)
```

### Package runs

```{r process package runs}
runs <-
  runs_raw %>%
  group_by(package) %>%
  summarise(runnable_success=sum(is.na(error)), runnable_error=sum(!is.na(error)), runnable_time=sum(time, na.rm=TRUE)) %>%
  mutate(runnable_rate=runnable_success/(runnable_success+runnable_error))
```

### Trace runs

```{r process trace runs}
trace_runs <-
  trace_runs_raw %>%
  group_by(package) %>%
  summarise(trace_runnable_success=sum(is.na(error)), trace_runnable_error=sum(!is.na(error)), trace_runnable_time=sum(time, na.rm=TRUE)) %>%
  mutate(trace_runnable_rate=trace_runnable_success/(trace_runnable_success+trace_runnable_error))
```

```{r process trace log}
trace_log <-
  trace_log_raw %>%
  select(package, trace_exitval=exitval, trace_start=starttime, trace_end=endtime, trace_runtime=runtime)
```

### Package evals

```{r process evals}
evals <- 
  evals_raw %>%
  count(package, fun_name) %>%
  group_by(package) %>%
  summarise(funs_with_eval=length(unique(fun_name)), evals=sum(n))
```

### Join

```{r joining data}
corpus_s1 <-
  corpus_s1_raw %>%
  left_join(metadata, by="package") %>%
  left_join(sloc, by="package") %>%
  left_join(functions, by="package") %>%
  left_join(runnable_code, by="package") %>%
  left_join(coverage, by="package") %>%
  left_join(runs, by="package") %>%
  left_join(trace_runs, by="package") %>%
  left_join(trace_log, by="package") %>%
  left_join(evals, by="package")
```

### Select corpus

```{r compute corpus}
corpus <-
  corpus_s1 %>%
  filter(
    trace_exitval == 0,
    coverage_expr > 0
  ) %>%
  arrange(desc(revdeps), desc(coverage_expr)) %>%
  head(CORPUS_NUM_PKGS)
```

```{r export corpus}
write_lines(corpus$package, CORPUS_FILE)
write_fst(corpus, CORPUS_DETAILS_FILE)
```