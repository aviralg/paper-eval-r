---
title: "Empirical Evaluation of eval in R"
author: "Pierre Donat-Bouillud"
output:
  rmdformats::readthedown:
        code_folding: hide
        lightbox: true
        gallery: false
        df_print: paged
        toc_depth: 3
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
params:
  base_dir: /var/lib/R/project-evalR
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center",
                      fig.retina = 2,
                      fig.width = 10,
                      cache.lazy = FALSE)

now <- Sys.time() 

library(tidyverse)
library(fst)

source("insights.R", local = knitr::knit_global())
source("preprocess.R", local = knitr::knit_global())
```

# Loading datafiles

```{r loading_fst}
eval_calls <- read_fst("/var/lib/R/project-evalR/run/package-evals-traced-test/calls.fst") %>%
  as_tibble() %>%
  deduplicate() %>% 
  add_types() %>%
  add_eval_source(eval_calls_raw) %>% add_eval_source_type()
```

# Description of the data files

```{r packages}

```


There are `r count(eval_calls, wt=nb_ev_calls)` eval calls and `r eval_calls %>% select(eval_call_srcref) %>% n_distinct()` eval call sites in the dataset.

# Classification of environments

We distinguish between 4 main categories of `eval` calls with respect to their `envir` argument:

- `envir` is not provided explicitly (and thus is the default argument, which semantically belongs to the absolute category)
- `envir` is a list or a data frame
- `envir` comes from an argument of the caller function
- `envir` is absolutely computed (with `parent.frame()` or equivalent)

## `envir` as default argument

```{r envir_default}
eval_calls_default <- eval_calls %>% filter(is.na(envir_expression))

eval_calls <- eval_calls %>% filter(!is.na(envir_expression))
```




##  `envir` as a list or data frame

```{r envir_list}
eval_calls_env_list <- eval_calls %>% filter(envir_type == "VECSXP")
```



## `envir` as an argument from the caller function

```{r envir_arg_caller}
eval_calls_arg_caller <- eval_calls %>% filter(!is.na(envir_from_arg))
```


Most of the eval calls directly use the argument, but some seem to modify it a lot:

```{r}
eval_calls_arg_caller %>% count(envir_from_arg, wt=nb_ev_calls, sort = TRUE) %>% knitr::kable()
```

But all those strange calls are due to Rcpp:

```{r arg_call_rcpp}
eval_calls_arg_caller %>% filter(envir_from_arg > 1, !str_detect(expr_expression, "C\\+\\+Constructor|C\\+\\+Field|C\\+\\+OverloadedMethods")) 
```

In the current dataset, there are no examples of sandbox usage but we should see adistance of 1 in that case.


## `envir` absolutely computed

```{r envir_absolute}
eval_calls_absolute <- eval_calls %>% anti_join(eval_calls_env_list) %>% anti_join(eval_calls_arg_caller)
```

Let's do a sanity check: is the environment class the same in that category?

```{r}
eval_calls_absolute <- eval_calls_absolute  %>% add_fake_srcref() %>% group_by(eval_call_srcref) %>%  mutate(envir_distinct = n_distinct(environment_class)) %>% ungroup()
```



```{r}
duration <- difftime(Sys.time(), now)
```

Notebook execution was `r duration` `r units(duration)`.
