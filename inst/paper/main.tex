\documentclass[conference]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings}
\newcommand{\missingNumber}{\textcolor{red}{XX}\xspace}
\newcommand{\missingPercentage}{\textcolor{red}{XX\%}\xspace}
\newcommand{\missingTable}{\textcolor{red}{XXTable}\xspace}
\newcommand{\missingGraph}{\textcolor{red}{XXGraph}\xspace}
\usepackage[usenames,dvipsnames]{xcolor} 
\usepackage{xspace} 


\lstset{ 
	language=R,                     % the language of the code
	basicstyle=\tiny\ttfamily, % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\tiny\color{Blue},  % the style that is used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it is 1, each line
	% will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	%frame=single,                   % adds a frame around the code
	rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
	tabsize=2,                      % sets default tabsize to 2 spaces
	captionpos=b,                   % sets the caption-position to bottom
	breaklines=true,                % sets automatic line breaking
	breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
	keywordstyle=\color{RoyalBlue},      % keyword style
	commentstyle=\color{YellowGreen},   % comment style
	stringstyle=\color{ForestGreen}      % string literal style
} 
\begin{document}

\title{A Large-Scale Study of the Use of Eval in R}
\author{\vspace{-.8cm}\IEEEauthorblockN{
    \it\Large The Eval that Data Scientists Do}%
  %\IEEEauthorblockA{ dept} \\ \and
}  
\maketitle

\renewcommand{\c}[1]{{\texttt{#1}}\xspace}
\newcommand{\miss}[1]{{\textcolor{red}{#1}}\xspace}

\begin{abstract}
  The \c{eval} function turns text into code. The widespread use of that
  capability hinders the static reasoning about software systems. This paper
  is a large-scale study of a corpus of \miss{3} million lines of R code.
  We performed static and dynamic analysis of our corpus and report that
  usage of \c{eval} is indeed wide spread. It is used by expert core
  developers of the language, experienced library developers, and end-users
  alike. The patterns of usage range from meta-programming to
  misunderstandings of what \c{eval} is good for. Case studies give example
  use-cases and some evidence that automated tools could be used to refactor
  some of the uses of \c{eval}.
\end{abstract}

\section{Introduction}

The \c{eval} function has a bad reputation. This function, under one name or
another and with various exact semantics, is available in many dynamic
languages. It is used to transform text into code and execute that code.  It
earned its reputation because of the challenges it poses for reasoning about
code that uses it.  The problem with eval is that the behavior of a system
departs from the source text of the program and becomes dependent on the
program's inputs. This brings challenge to program analysis and security.

While the worst case is indeed pretty bad, previous work has found that
in many cases eval can be fairly inoccuous or at least much less dangerous
that the worst case.

There has been research in understanding the behavior of eval in the context
of web programming and in particular the JavaScript language.

This paper looks at eval in the context of data science. We look at the use
of eval in the R programming language. And in particular we look at its use
in three different contexts.  The first context is the implementation of the
language, how is eval used by the core developers of R in the packages that
are part of the R virtual machine.  The secoond context is how it is used in
libraries. And the third context is how it is used by end users of the
language.

There are reasons to believe that usage patterns may be different. The core
R code is extremely stable, it has only been maintained for the last 20
years with very few far reaching changes. The libraries represent a more
lively ecosystem with new libraries added each day. Typically they are
developped by experience R developer.  Finally, end user code is often
written by non-programmers, data scientists who may or may not understand R.

To set up our experiements we have created a corpus composed of three
distinct data sets.  We have set out the 8 packages that are included with
the R virtual machine and refer to these as `` base'' packages.  We have
selected the 400 most widely included libraries and obtained a number of
client programs to exercises them.  Finally we have obtained 400 end users
programs from the Kaggle competition.

To understand the behavior of eval we perform a combination of static
analysis, dynamic analysis and manual inspection. The results presented
here summarize our findings.

Our infrastructure is publicly available, released in open source, and our
data, and code will be submitted to artifact evaluation.


\section{Related Work}

\cite{ecoop11}

Previous work looked at eval in JavaScript

Othere languages

Dynamic analysis


\section{Shades of Eval}

- Talk about environments
- How is it different from JS (takes language, env in R but string in JS).

\section{The Design of Eval}

There are four different kinds of \c{eval} in the \emph{base} package:  \c{eval}, \c{evalq}, \c{eval.parent},  \c{local}.
The most important one is \c{eval}: \lstinline|eval(expr, envir, enclos)|


- the four eval functions in base


- the arguments, expr and envir, enclos


- which expressions are evaluated, which ones are left unchanged

\section{Infrastructure}


\section{Corpus of R Programs}


\section{Threats to Validity}


\section{Research Question}
This section presents the results of our empirical study of eval in the R language.
\subsection{How many evals}

In our corpus eval is called \missingNumber times out of \missingNumber
total calls to all R functions. This is merely \missingPercentage of the total
number of calls. \missingTable breaks down the number of calls and callsites for
the four kinds of eval functions from the three source; core R, packages and
Kaggle code.

The core R packages are the biggest consumers of eval. Majority of calls,
\missingPercentage, originate from the core R packages. Kaggle code, which is
end-user code, has merely \missingNumber calls to eval.

Of the \missingNumber packages in our corpus, only \missingNumber packages call
eval. \missingTable shows the number of calls to eval made by the ten most
frequent callers to eval. \missingNumber packages account for over
\missingPercentage calls to eval.

\missingGraph shows the distribution of number of callsites to eval across these
packages. \missingNumber packages have a single eval callsite.


\subsection{How are they used}

- classify evals based on what they can be replaced with

\subsubsection{A taxonomy of \c{eval}}

We first classify \c{eval} depending on the resolved expression, \emph{i.e.}
the first argument of \c{eval} after all possible function calls and symbol
resolution in it have been executed.



\subsection{How to replace evals}


\subsection{How dangerous is eval}

\subsection{How many evals can be replaced}

\section{Case studies}

\subsection{base}


\section{Conclusion}

\bibliographystyle{IEEEtran}
\bibliography{bib/bibliography,bib/jv}

\end{document}


Eval is evil, we would like to replace it.
Research Questions
How often is eval used? 
How often it is used in base / other packages?
blocking: cannot find out precisely what comes from base
What is the source of evals?
Provenance (source arguments to eval)
How many evals are in libraries / vignettes
What is eval used for?
??Eval in the tidyverse
TODO: Classification of evals in  packages (Pierre)
TODO: look at the first function to get
binary / unary / assignment / other function
does it have {
evals that do nothing (they get values)
...
TODO: In the case of base package (Filip)
access default values of formals
simply implementation
weird replacement of calls (write.csv -> write.table)
accessing variable from another environment (instead of get)
evaling user input
Change of caller pattern: 
m <- match.call()
 m$name <- NULL
 m[[1L]] <- as.name("library")
eval(m, .GlobalEnv)
     - 	TODO: How dangerous is eval? (Aviral)
Does eval generate new code (create new functions)?
environment writes (reads)
system environment variables
connections
random number generator - setting seed
Does eval do dynamic code loading?
Does eval argument reflect on the call stack?
Calls to C Code
TODO: Could the eval be made safer?
TODO: Could some of the eval calls be replaced?
