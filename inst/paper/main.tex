\documentclass[conference]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\newcommand{\missingNumber}{\textcolor{red}{XX}\xspace}
\newcommand{\missingPercentage}{\textcolor{red}{XX\%}\xspace}
\newcommand{\missingTable}{\textcolor{red}{XXTable}\xspace}
\newcommand{\missingGraph}{\textcolor{red}{XXGraph}\xspace}
\usepackage{xcolor,xspace}
\begin{document}

\title{A Study of the Usage of Eval in R}

\author{\IEEEauthorblockN{For double blind review}%
  %\IEEEauthorblockA{ dept} \\ \and
}  
\maketitle

\renewcommand{\c}[1]{{\small\sf{#1}}\xspace}

\begin{abstract}

\end{abstract}

\section{Introduction}

The \c{eval} function has a bad reputation. This function, under one name or
another and with various exact semantics, is available in many dynamic
languages. It is used to transform text into code and execute that code.


- Why eval is used in R
- What the community says about using eval
- What existing tools do about eval
- Do people use eval for obvious things like looking up variable, if yes, it is
because they are unaware of alternatives?
- Why automating the transformation is a hard problem.
- What is the goal of the work? To replace eval with code for static analyssi or
for consumption by the users of the language?
- We only permit transformations that preserve code behavior?
- Do we accept overly complex code as the output?

Why do we do this dynamically? Because it raises a chicken-and-egg problem,
doing it statically would require us to reason about eval based code which may
not be possible in general.


What are the challenges? Why is it not trivial?
- Do we handle aliasing of eval?
- Simple cases can be subtle? (laziness for ex.

Why can't we replace eval(code) by code?

Intended user of the technique? Which version of R is targeted.

Contributions:
- Describe the use of eval in R
- Develop a tool to replace evals guided by dynamic traces


- cannot replace with (cite study of with construct).
- 
\textbf{*}

\section{Related Work}

\section{Eval in R}
- Talk about environments
- How is it different from JS (takes language, env in R but string in JS).

\section{The Design of Eval}

There are four different kinds of \texttt{eval} in the \emph{base} package:  \texttt{eval}, \texttt{evalq}, \texttt{eval.parent},  \texttt{local}.
The most important one is \texttt{eval}:



- the four eval functions in base
- the arguments, expr and envir, enclos
- which expressions are evaluated, which ones are left unchanged

\section{Infrastructure}


\section{Corpus of R Programs}


\section{Threats to Validity}


\section{Research Question}
This section presents the results of our empirical study of eval in the R language.
\subsection{How many evals}

In our corpus eval is called \missingNumber times out of \missingNumber
total calls to all R functions. This is merely \missingPercentage of the total
number of calls. \missingTable breaks down the number of calls and callsites for
the four kinds of eval functions from the three source; core R, packages and
Kaggle code.

The core R packages are the biggest consumers of eval. Majority of calls,
\missingPercentage, originate from the core R packages. Kaggle code, which is
end-user code, has merely \missingNumber calls to eval.

Of the \missingNumber packages in our corpus, only \missingNumber packages call
eval. \missingTable shows the number of calls to eval made by the ten most
frequent callers to eval. \missingNumber packages account for over
\missingPercentage calls to eval.

\missingGraph shows the distribution of number of callsites to eval across these
packages. \missingNumber packages have a single eval callsite.


\subsection{How are they used}

- classify evals based on what they can be replaced with

\subsubsection{A taxonomy of \texttt{eval}}

We first classify \texttt{eval} depending on the resolved expression, \emph{i.e.} the first argument of \texttt{eval} after all possible function calls and symbol resolution in it have been executed.



\subsection{How to replace evals}


\subsection{How dangerous is eval}

\subsection{How many evals can be replaced}

\section{Case studies}

\subsection{\texttt{base}}

\section{Related Work}
eval has been widely discussed in the research literature for the challenges it
imposes for code comprehension and automated code analyses.
Perhaps, EvalMenDo is the most popular exposition of eval and its
challenges for JavaScript. 

\textbf{Aviral}
- javascript
- ruby
- php

\section{Conclusion}
\textbf{*}


\section*{Acknowledgment}

\section*{References}

\end{document}


Eval is evil, we would like to replace it.
Research Questions
How often is eval used? 
How often it is used in base / other packages?
blocking: cannot find out precisely what comes from base
What is the source of evals?
Provenance (source arguments to eval)
How many evals are in libraries / vignettes
What is eval used for?
??Eval in the tidyverse
TODO: Classification of evals in  packages (Pierre)
TODO: look at the first function to get
binary / unary / assignment / other function
does it have {
evals that do nothing (they get values)
...
TODO: In the case of base package (Filip)
access default values of formals
simply implementation
weird replacement of calls (write.csv -> write.table)
accessing variable from another environment (instead of get)
evaling user input
Change of caller pattern: 
m <- match.call()
 m$name <- NULL
 m[[1L]] <- as.name("library")
eval(m, .GlobalEnv)
     - 	TODO: How dangerous is eval? (Aviral)
Does eval generate new code (create new functions)?
environment writes (reads)
system environment variables
connections
random number generator - setting seed
Does eval do dynamic code loading?
Does eval argument reflect on the call stack?
Calls to C Code
TODO: Could the eval be made safer?
TODO: Could some of the eval calls be replaced?
